{"text": "QUESTION:In Cangjie code language,How are generic constraints defined in Cangjie?\nANSWER:The function of generic constraints is to clarify the operation and capabilities of generic parameters when function, class, interface, struct, and enum are declared. Only when these constraints are declared can the corresponding member functions be called. \nGeneric constraints in Cangjie are used to specify the capabilities and operations that a generic type parameter must support. Constraints are declared using the where keyword followed by the type parameter and the constraint conditions.func id<T>(a: T) {\n    return a\n}"}
{"text": "QUESTION:In Cangjie code language,What types of generic constraints are available in Cangjie?\nANSWER:Constraints are broadly divided into interface constraints and subtype constraints. The syntax is to use the where keyword before the declaration body of a function or type to declare, for the declared generic parameters T1, T2, you can use where T1 <: Interface, T2 <: Type to declare generic constraints, and multiple constraints of the same type variant can use & join. For example: where T1 <: Interface1 & Interface2."}
{"text": "QUESTION:In Cangjie code language,How are interface generic constraints used in Cangjie?\nANSWER:The println function in Cangjie can accept a parameter of type as a string. If you need to convert a generic type variable to a string and print it on the command line, you can constrain the generic type variant, which is the ToString interface defined in core, which is obviously an interface constraint.package core // `ToString` is defined in core.\npublic interface ToString {\n    func toString(): String\n}\n\n//define a function called genericPrint:\nfunc genericPrint<T>(a: T) where T <: ToString {\n    println(a)\n}\nmain() {\n    genericPrint<Int64>(10)\n    return 0\n}\n\nError_case:\nfunc genericPrint<T>(a: T) where T <: ToString {\n    println(a)\n}\nmain() {\n    genericPrint<(Int64) -> Int64>({ i => 0 })  //rror that the generic type argument does not satisfy the constraint.\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,How are subtype generic constraints used in Cangjie?\nANSWER:In addition to the above representation of constraints through interfaces, you can also use subtypes to constrain a generic type variant. For example, if you want to declare a zoo type Zoo<T>, but the type parameter T needs to be constrained here, this constraint is that T needs to be a subtype of the animal type Animal with the run member function declared in the Animal type. It is stated that both subtypes, Dog and Fox, implement the run member function, so that<T> in the Zoo type, the run member function can be called on the animal instance stored in the animals array list:import std.collection.*\n\nabstract class Animal {\n    public func run(): String\n}\nclass Dog <: Animal {\n    public func run(): String {\n        return \"dog run\"\n    }\n}\nclass Fox <: Animal {\n    public func run(): String {\n        return \"fox run\"\n    }\n}\nclass Zoo<T> where T <: Animal {\n    var animals: ArrayList<Animal> = ArrayList<Animal>()\n    public func addAnimal(a: T) {\n        animals.append(a)\n    }\n    public func allAnimalRuns() {\n        for(a in animals) {\n            println(a.run())\n        }\n    }\n}\nmain() {\n    var zoo: Zoo<Animal> = Zoo<Animal>()\n    zoo.addAnimal(Dog())\n    zoo.addAnimal(Fox())\n    zoo.allAnimalRuns()\n    return 0\n}"}
