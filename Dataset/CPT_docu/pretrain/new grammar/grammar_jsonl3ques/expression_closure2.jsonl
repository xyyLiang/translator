{"text": "QUESTION:In Cangjie code language,What is a closure in Cangjie?\nANSWER:A closure in Cangjie is a function or lambda expression that captures variables from its surrounding scope. This allows the function or lambda to access and modify these variables even when it is called outside the original scope."}
{"text": "QUESTION:In Cangjie code language,How does variable capture work in closures in Cangjie?\nANSWER:Closures in Cangjie capture variables in the following scenarios:\nAccessing local variables defined outside the function or lambda in the default values of function parameters.\nAccessing local variables defined outside the function or lambda within the function or lambda body.\nAccessing instance member variables or this in functions or lambdas defined within a class or struct, but not as member functions.\nThe following scenarios do not count as variable capture:\nAccessing local variables defined within the function or lambda.\nAccessing function or lambda parameters.\nAccessing global variables and static member variables.\nAccessing instance member variables within instance member functions or properties, as this is passed as a parameter.func returnAddNum(): (Int64) -> Int64 {\n    let num: Int64 = 10\n    func add(a: Int64) {\n        return a + num\n    }\n    add\n}\nmain() {\n    let f = returnAddNum()\n    println(f(10))\n}"}
{"text": "QUESTION:In Cangjie code language,What are the rules for variable capture in closures in Cangjie?\nANSWER:Captured variables must be visible at the time the closure is defined; otherwise, a compile-time error occurs.\nCaptured variables must be initialized before the closure is defined; otherwise, a compile-time error occurs.func f() {\n    let x = 99\n    func f1() {\n        println(x)\n    }\n    let f2 = { =>\n        println(y)      // Error, cannot capture 'y' which is not defined yet\n    }\n    let y = 88\n    f1()          // Print 99.\n    f2()\n}"}
{"text": "QUESTION:In Cangjie code language,How are captured variables modified in closures in Cangjie?\nANSWER:If a captured variable is of a reference type, its mutable instance member variables can be modified within the closure."}
{"text": "QUESTION:In Cangjie code language,How do escaping closures work in Cangjie?\nANSWER:Closures that capture var-declared variables cannot escape their defining scope. They can only be called and cannot be assigned to variables, passed as arguments, returned from functions, or used as expressions.class C {\n    public var num: Int64 = 0\n}\nfunc returnIncrementer(): () -> Unit {\n    let c: C = C()\n    func incrementer() {\n        c.num++\n    }\n    incrementer\n}\nmain() {\n    let f = returnIncrementer()\n    f() // c.num increases by 1\n}\n\nError_case:\nfunc f() {\n    var x = 1\n    let y = 2\n    func g() {\n        println(x)  // OK, captured a mutable variable.\n    }\n    let b = g  // Error, g cannot be assigned to a variable\n    g  // Error, g cannot be used as an expression\n    g()  // OK, g can be invoked\n    g  // Error, g cannot be used as a return value.\n}"}
{"text": "QUESTION:In Cangjie code language,How does transitivity of variable capture work in closures in Cangjie?\nANSWER:If a function f calls another function g that captures a var variable, and the captured variable is not defined within f, then f also captures the variable. In this case, f cannot be used as a first-class citizen.func h(){\n    var x = 1\n    func g() {  x }   // captured a mutable variable\n    func f() {\n        g()      // invoked g\n    }\n    return f // Error\n}"}
{"text": "QUESTION:In Cangjie code language,How do static and global variables work in closures in Cangjie?\nANSWER:Accessing static member variables and global variables does not count as variable capture. Therefore, functions or lambdas that access var-declared global variables or static member variables can still be used as first-class citizens.class C {\n    static public var a: Int32 = 0\n    static public func foo() {\n        a++       // OK\n        return a\n    }\n}\nvar globalV1 = 0\nfunc countGlobalV1() {\n    globalV1++\n    C.a = 99\n    let g = C.foo  // OK\n}\nfunc g(){\n    let f = countGlobalV1 // OK\n    f()\n}"}
