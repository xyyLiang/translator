{"text": "QUESTION:In Cangjie code language,What synchronization mechanisms are available in Cangjie?\nANSWER:Cangjie provides several synchronization mechanisms to ensure thread safety in concurrent programming, including atomic operations, mutexes, and condition variables."}
{"text": "QUESTION:In Cangjie code language,How to use atomic operations in Cangjie?\nANSWER:Cangjie provides atomic operations for integer types, Bool, and reference types. Integer types include Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, and UInt64. These types support basic read/write, swap, and arithmetic operations.\nThe return value of swap and arithmetic operations is the value before the modification.\nCompareAndSwap is to determine whether the value of the current atomic variable is equal to the old value, and if it is equal to, replace it with the new value; Otherwise, it will not be replaced.\nEach of the above atomic methods has a corresponding method that can receive memory sort parameters, and currently memory sort parameters only support sequential consistency.\n| Operation        | Function                                         |\n| ---------------- | ------------------------------------------------ |\n| `load`           | Read the value                                   |\n| `store`          | Write a value                                    |\n| `swap`           | Swap values, returning the old value             |\n| `compareAndSwap` | Compare and swap, returning `true` if successful |\n| `fetchAdd`       | Add a value, returning the old value             |\n| `fetchSub`       | Subtract a value, returning the old value        |\n| `fetchAnd`       | Bitwise AND, returning the old value             |\n| `fetchOr`        | Bitwise OR, returning the old value              |\n| `fetchXor`       | Bitwise XOR, returning the old value             |//Taking the Int8 type as an example, the corresponding atomic operation type declaration is as follows:\nclass AtomicInt8 {\n    public func load(): Int8\n    public func store(val: Int8): Unit\n    public func swap(val: Int8): Int8\n    public func compareAndSwap(old: Int8, new: Int8): Bool\n    public func fetchAdd(val: Int8): Int8\n    public func fetchSub(val: Int8): Int8\n    public func fetchAnd(val: Int8): Int8\n    public func fetchOr(val: Int8): Int8\n    public func fetchXor(val: Int8): Int8\n}\n// how to use atomic operations to implement counting in a multithreaded program\nimport std.sync.*\nimport std.time.*\nimport std.collection.*\n\nlet count = AtomicInt64(0)\nmain(): Int64 {\n    let list = ArrayList<Future<Int64>>()\n    // create 1000 threads.\n    for (_ in 0..1000) {\n        let fut = spawn {\n            sleep(Duration.millisecond) // sleep for 1ms.\n            count.fetchAdd(1)\n        }\n        list.append(fut)\n    }\n    // Wait for all threads finished.\n    for (f in list) {\n        f.get()\n    }\n    let val = count.load()\n    println(\"count = ${val}\")\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,What are the detailed atomic operations available in Cangjie?\nANSWER:Cangjie provides a comprehensive set of atomic operations for integer types, Bool, and reference types. These operations ensure thread-safe modifications to shared variables.\nInteger Atomic Operations:\nload(): Reads the current value.\nstore(value): Writes a new value.\nswap(value): Swaps the current value with the given value and returns the old value.\ncompareAndSwap(oldValue, newValue): Atomically compares the current value with oldValue and swaps it with newValue if they match. Returns true if the swap was successful.\nfetchAdd(value): Adds the given value and returns the old value.\nfetchSub(value): Subtracts the given value and returns the old value.\nfetchAnd(value): Performs a bitwise AND with the given value and returns the old value.\nfetchOr(value): Performs a bitwise OR with the given value and returns the old value.\nfetchXor(value): Performs a bitwise XOR with the given value and returns the old value.\nBool Atomic Operations:\nload(): Reads the current value.\nstore(value): Writes a new value.\nswap(value): Swaps the current value with the given value and returns the old value.\ncompareAndSwap(oldValue, newValue): Atomically compares the current value with oldValue and swaps it with newValue if they match. Returns true if the swap was successful.\nReference Atomic Operations:\nAtomicReference<T>: A thread-safe reference type.\nload(): Reads the current value.\nstore(value): Writes a new value.\nswap(value): Swaps the current value with the given value and returns the old value.\ncompareAndSwap(oldValue, newValue): Atomically compares the current value with oldValue and swaps it with newValue if they match. Returns true if the swap was successful.import std.sync.*\n\nclass A {}\n\nmain() {\n    var obj: AtomicInt32 = AtomicInt32(1)\n    var x = obj.load() // x: 1, the type is Int32\n    x = obj.swap(2) // x: 1\n    x = obj.load() // x: 2\n    var y = obj.compareAndSwap(2, 3) // y: true, the type is Bool.\n    y = obj.compareAndSwap(2, 3) // y: false, the value in obj is no longer 2 but 3. Therefore, the CAS operation fails.\n    x = obj.fetchAdd(1) // x: 3\n    x = obj.load() // x: 4\n\n    var obj1 = AtomicBool(true)\n    var x1 = obj1.load() // x1: true, the type is Bool\n    println(x1)\n    var t1 = A()\n\n    var obj2 = AtomicReference(t1)\n    var x2 = obj2.load() // x2 and t1 are the same object\n    var y1 = obj2.compareAndSwap(x2, t1) // x2 and t1 are the same object, y1: true\n    println(y1)\n    var t2 = A()\n    var y2 = obj2.compareAndSwap(t2, A()) // x and t1 are not the same object, CAS fails, y2: false\n    println(y2)\n    y2 = obj2.compareAndSwap(t1, A()) // CAS successes, y2: true\n    println(y2)\n}"}
{"text": "QUESTION:In Cangjie code language,How to use a reentrant mutex in Cangjie?\nANSWER:A reentrant mutex ensures that only one thread can execute the critical section of code at a time. If a thread tries to acquire a lock held by another thread, it will be blocked until the lock is released.\nThe ReentrantMutex class provides the following methods:\nlock(): Acquires the lock.\ntryLock(): Tries to acquire the lock without blocking.\nunlock(): Releases the lock.\nWhen using reentrant mutexes, there are two rules that must be kept in mind:\n Before you can access the shared data, you must attempt to acquire a lock;\n Once the shared data has been processed, it must be unlocked so that other threads can acquire the lock.\n\nThe main member functions provided by ReentrantMutex are as follows:\npublic open class ReentrantMutex {\n    // Create a ReentrantMutex.\n    public init()\n    // Locks the mutex, blocks if the mutex is not available.\n    public func lock(): Unit\n    // Unlocks the mutex. If there are other threads blocking on this\n    // lock, then wake up one of them.\n    public func unlock(): Unit\n    // Tries to lock the mutex, returns false if the mutex is not\n    // available, otherwise returns true.\n    public func tryLock(): Bool\n}import std.sync.*\nimport std.time.*\nimport std.collection.*\n\nvar count: Int64 = 0\nlet mtx = ReentrantMutex()\n\nmain(): Int64 {\n    let list = ArrayList<Future<Unit>>()\n    // create 1000 threads.\n    for (i in 0..1000) {\n        let fut = spawn {\n            sleep(Duration.millisecond) // sleep for 1ms.\n            mtx.lock()\n            count++\n            mtx.unlock()\n        }\n        list.append(fut)\n    }\n    // Wait for all threads finished.\n    for (f in list) {\n        f.get()\n    }\n    println(\"count = ${count}\")\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,What are common errors when using mutexes in Cangjie?\nANSWER:When using mutexes in Cangjie, several common errors can occur if not used correctly:\nError Example 1: Not unlocking after accessing the critical section, causing other threads to block indefinitely.\nError Example 2: Calling unlock without holding the lock, which will throw an exception.\nError Example 3: Using tryLock without proper handling, leading to operations outside the lock's protection or calling unlock without holding the lock.import std.sync.*\n\nfun main() {\n    let mutex = ReentrantMutex()\n    let sharedVar = 0\n\n    // Error Example 1: Not unlocking\n    spawn {\n        mutex.lock()\n        sharedVar += 1 // Forgot to unlock\n    }\n\n    // Error Example 2: Unlocking without holding the lock\n    spawn {\n        mutex.unlock() // Will throw an exception\n    }\n\n    // Error Example 3: Improper tryLock usage\n    spawn {\n        if (mutex.tryLock()) {\n            sharedVar += 1\n            mutex.unlock()\n        } else {\n            sharedVar += 1 // Operating outside the lock's protection\n        }\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,What are the properties of a reentrant mutex in Cangjie?\nANSWER:A ReentrantMutex in Cangjie allows a thread to acquire the same lock multiple times. This is useful for nested locking scenarios. However, the number of unlock calls must match the number of lock calls to release the lock properly.import std.sync.*\nimport std.time.*\n\nvar count: Int64 = 0\nlet mtx = ReentrantMutex()\n\nfunc foo() {\n    mtx.lock()\n    count += 10\n    bar()\n    mtx.unlock()\n}\nfunc bar() {\n    mtx.lock()\n    count += 100\n    mtx.unlock()\n}\nmain(): Int64 {\n    let fut = spawn {\n        sleep(Duration.millisecond) // sleep for 1ms.\n        foo()\n    }\n    foo()\n    fut.get()\n    println(\"count = ${count}\")\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,How to use a monitor in Cangjie?\nANSWER:Monitor is a built-in data structure that binds a mutex and a single condition variable associated with it (i.e., a wait queue). Monitor can cause a thread to block and wait for a signal from another thread to resume execution. This is a mechanism that uses shared variables for thread synchronization, and mainly provides the following methods:\npublic class Monitor <: ReentrantMutex {\n    // Create a monitor.\n    public init()\n    // Wait for a signal, blocking the current thread.\n    public func wait(timeout!: Duration = Duration.Max): Bool\n    // Wake up one thread of those waiting on the monitor, if any.\n    public func notify(): Unit\n    // Wake up all threads waiting on the monitor, if any.\n    public func notifyAll(): Unit\n}\nBefore calling the wait, notify, or notifyAll methods of the Monitor object, you need to make sure that the current thread already holds the corresponding Monitor lock. The wait method consists of the following actions:\nAdd the current thread to the waiting queue corresponding to the monitor;\nBlock the current thread while completely releasing the Monitor lock and record the number of reentrants of the lock;\nWait for another thread to signal to that thread using the notify or notifyAll methods of the same Monitor instance;\nAfter the current thread is awakened, it will automatically try to reacquire the Monitor lock, and the reentrancy state of holding the lock is the same as the number of reentrants recorded in step 2; However, if an attempt to acquire a Monitor lock fails, the current thread is blocked on that Monitor lock.\nWhen a wait is performed on a monitor object, it must be under the protection of the lock, otherwise the operation of releasing the lock in the wait will throw an exception.import std.sync.*\nimport std.time.*\nvar mon = Monitor()\nvar flag: Bool = true\nmain(): Int64 {\n    let fut = spawn {\n        mon.lock()\n        while (flag) {\n            println(\"New thread: before wait\")\n            mon.wait()\n            println(\"New thread: after wait\")\n        }\n        mon.unlock()\n    }\n    // Sleep for 10ms, to make sure the new thread can be executed.\n    sleep(10 * Duration.millisecond)\n    mon.lock()\n    println(\"Main thread: set flag\")\n    flag = false\n    mon.unlock()\n    mon.lock()\n    println(\"Main thread: notify\")\n    mon.notifyAll()\n    mon.unlock()\n    // wait for the new thread finished.\n    fut.get()\n    return 0\n}\n\nError_case:\nimport std.sync.*\n\nvar m1 = Monitor()\nvar m2 = ReentrantMutex()\nvar flag: Bool = true\nvar count: Int64 = 0\n\nfunc foo1() {\n    spawn {\n        m2.lock()\n        while (flag) {\n            m1.wait() // Error：The lock used together with the condition variable must be the same lock and in the locked state. Otherwise, the unlock operation in `wait` throws an exception.\n        }\n        count = count + 1\n        m2.unlock()\n    }\n    m1.lock()\n    flag = false\n    m1.notifyAll()\n    m1.unlock()\n}\nfunc foo2() {\n    spawn {\n        while (flag) {\n            m1.wait() // Error：The `wait` of a conditional variable must be called with a lock held.\n        }\n        count = count + 1\n    }\n    m1.lock()\n    flag = false\n    m1.notifyAll()\n    m1.unlock()\n}\nmain() {\n    foo1()\n    foo2()\n    m1.wait()\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,How to use a MultiConditionMonitor in Cangjie?\nANSWER:MultiConditionMonitor is a built-in data structure that binds mutexes and a set of dynamically created condition variables associated with it. This class should only be used in scenarios where the Monitor class is not sufficient for complex inter-thread synchronization. The following methods are provided:\npublic class MultiConditionMonitor <: ReentrantMutex {\n   // Constructor.\n   init()\n   // Returns a new ConditionID associated with this monitor. May be used to implement\n   // \"single mutex -- multiple wait queues\" concurrent primitives.\n   // Throws IllegalSynchronizationStateException(\"Mutex is not locked by the current thread\") if the current thread does not hold this mutex.\n   func newCondition(): ConditionID\n   // Blocks until either a paired `notify` is invoked or `timeout` nanoseconds pass.\n   // Returns `true` if the specified condition was signalled by another thread or `false` on timeout.\n   // Spurious wakeups are allowed.\n   // Throws IllegalSynchronizationStateException(\"Mutex is not locked by the current thread\") if the current thread does not hold this mutex.\n   // Throws IllegalSynchronizationStateException(\"Invalid condition\") if `id` was not returned by `newCondition` of this MultiConditionMonitor instance.\n   func wait(id: ConditionID, timeout!: Duration = Duration.Max): Bool\n   // Wakes up a single thread waiting on the specified condition, if any (no particular admission policy implied).\n   // Throws IllegalSynchronizationStateException(\"Mutex is not locked by the current thread\") if the current thread does not hold this mutex.\n   // Throws IllegalSynchronizationStateException(\"Invalid condition\") if `id` was not returned by `newCondition` of this MultiConditionMonitor instance.\n   func notify(id: ConditionID): Unit\n   // Wakes up all threads waiting on the specified condition, if any (no particular admission policy implied).\n   // Throws IllegalSynchronizationStateException(\"Mutex is not locked by the current thread\") if the current thread does not hold this mutex.\n   // Throws IllegalSynchronizationStateException(\"Invalid condition\") if `id` was not returned by `newCondition` of this MultiConditionMonitor instance.\n   func notifyAll(id: ConditionID): Unit\n}\n\nnewCondition(): ConditionID: Creates a new condition variable and associates it with the current object, returning a specific ConditionID identifier\nwait(id: ConditionID, timeout! (: Duration = last.max): Bool: Wait for the signal to block the current thread\nnotify(id: ConditionID): Unit: Wakes up a thread waiting on the monitor (if any)\nnotifyAll(id: ConditionID): Unit: Wake up all threads waiting on Monitor (if any)\n\nAt initialization, MultiConditionMonitor does not have an instance of ConditionID associated with it. Each call to newCondition will create a new condition variable associated with the current object, and return the following type as a unique identifier:\npublic struct ConditionID {\n   private init() { ... } // constructor is intentionally private to prevent\n                          // creation of such structs outside of MultiConditionMonitor\n}\n\nNote that users cannot pass the ConditionID returned by one MultiConditionMonitor instance to another instance, or create a ConditionID manually (e.g. using unsafe). Because the data contained in the ConditionID (such as the index of the inner array, the direct address of the internal queue, or any other type of data, etc.) is related to the MultiConditionMonitor that created it, passing the \"external\" ConditionID into the MultiConditionMonitor results in an IllegalSynchronizationStateException.import std.sync.*\n\nclass BoundedQueue {\n    // Create a MultiConditionMonitor, two Conditions.\n    let m: MultiConditionMonitor = MultiConditionMonitor()\n    var notFull: ConditionID\n    var notEmpty: ConditionID\n\n    var count: Int64 // Object count in buffer.\n    var head: Int64  // Write index.\n    var tail: Int64  // Read index.\n\n    // Queue's length is 100.\n    let items: Array<Object> = Array<Object>(100, {i => Object()})\n\n    init() {\n        count = 0\n        head = 0\n        tail = 0\n\n        synchronized(m) {\n          notFull  = m.newCondition()\n          notEmpty = m.newCondition()\n        }\n    }\n\n    // Insert an object, if the queue is full, block the current thread.\n    public func put(x: Object) {\n        // Acquire the mutex.\n        synchronized(m) {\n          while (count == 100) {\n            // If the queue is full, wait for the \"queue notFull\" event.\n            m.wait(notFull)\n          }\n          items[head] = x\n          head++\n          if (head == 100) {\n            head = 0\n          }\n          count++\n\n          // An object has been inserted and the current queue is no longer\n          // empty, so wake up the thread previously blocked on get()\n          // because the queue was empty.\n          m.notify(notEmpty)\n        } // Release the mutex.\n    }\n\n    // Pop an object, if the queue is empty, block the current thread.\n    public func get(): Object {\n        // Acquire the mutex.\n        synchronized(m) {\n          while (count == 0) {\n            // If the queue is empty, wait for the \"queue notEmpty\" event.\n            m.wait(notEmpty)\n          }\n          let x: Object = items[tail]\n          tail++\n          if (tail == 100) {\n            tail = 0\n          }\n          count--\n\n          // An object has been popped and the current queue is no longer\n          // full, so wake up the thread previously blocked on put()\n          // because the queue was full.\n          m.notify(notFull)\n\n          return x\n        } // Release the mutex.\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How to use the synchronized keyword in Cangjie?\nANSWER:ReentrantMutex provides a convenient and flexible way to lock the lock, but because of its flexibility, it can also cause the problem of forgetting to unlock it, or throwing an exception when holding a mutex does not automatically release the lock. Therefore, the Cangjie programming language provides a synchronized keyword, which can be used with ReentrantMutex, which can automatically lock and unlock in the scope that follows it, to solve similar problems.import std.sync.*\nimport std.time.*\nimport std.collection.*\n\nvar count: Int64 = 0\nlet mtx = ReentrantMutex()\n\nmain(): Int64 {\n    let list = ArrayList<Future<Unit>>()\n    // create 1000 threads.\n    for (i in 0..1000) {\n        let fut = spawn {\n            sleep(Duration.millisecond) // sleep for 1ms.\n            // Use synchronized(mtx), instead of mtx.lock() and mtx.unlock().\n            synchronized(mtx) {\n                count++\n            }\n        }\n        list.append(fut)\n    }\n\n    // Wait for all threads finished.\n    for (f in list) {\n        f.get()\n    }\n    println(\"count = ${count}\")\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,How does the synchronized keyword work with ReentrantMutex in Cangjie?\nANSWER:The synchronized keyword in Cangjie is used to protect a block of code such that at most one thread can execute it at any given time. This is achieved by associating a ReentrantMutex instance with the synchronized block.\nLock Acquisition: A thread will automatically acquire the lock corresponding to the ReentrantMutex instance before entering the synchronized code block. If the lock cannot be obtained, the thread will be blocked.\nLock Release: A thread will automatically release the lock on the ReentrantMutex instance before exiting the synchronized code block.\nControl Flow: For control flow statements (e.g., break, continue, return, throw), the lock is also automatically released when the execution of the program jumps out of the synchronized block.import std.sync.*\nimport std.collection.*\n\nvar count: Int64 = 0\nvar mtx: ReentrantMutex = ReentrantMutex()\n\nmain(): Int64 {\n    let list = ArrayList<Future<Unit>>()\n    for (i in 0..10) {\n        let fut = spawn {\n            while (true) {\n                synchronized(mtx) {\n                    count = count + 1\n                    break\n                    println(\"in thread\")\n                }\n            }\n        }\n        list.append(fut)\n    }\n\n    // Wait for all threads finished.\n    for (f in list) {\n        f.get()\n    }\n\n    synchronized(mtx) {\n        println(\"in main, count = ${count}\")\n    }\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,How to use ThreadLocal in Cangjie?\nANSWER:Using ThreadLocal in the core package, you can create and use thread locals, each of which has its own storage space to hold these thread locals. As a result, each thread can safely access their respective thread local variables without being influenced by other threads.\npublic class ThreadLocal<T> {\n/* Construct a local variable of the Cangjie thread carrying null values */\npublic init()\n\n/* Obtain the value of the local variable of the Cangjie thread */\npublic func get(): Option<T> // If the value does not exist, it returns Option<T>.none. Return value Option<T> - the value of the local variable of the Cangjie thread\n\n/* Set the value of the local variable of the Cangjie thread through value */\npublic func set(value: Option<T>): Unit // If Option<T>.none is passed in, the value of this local variable will be deleted and cannot be obtained in subsequent thread operations. Parameter value - The value of the local variable that needs to be set.\n}main(): Int64 {\n    let tl = ThreadLocal<Int64>()\n    let fut1 = spawn {\n        tl.set(123)\n        println(\"tl in spawn1 = ${tl.get().getOrThrow()}\")\n    }\n    let fut2 = spawn {\n        tl.set(456)\n        println(\"tl in spawn2 = ${tl.get().getOrThrow()}\")\n    }\n    fut1.get()\n    fut2.get()\n    0\n}"}
