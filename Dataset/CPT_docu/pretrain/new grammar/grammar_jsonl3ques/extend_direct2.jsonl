{"text": "QUESTION:In Cangjie code language,How to use direct extension in Cangjie?\nANSWER:In Cangjie, the extend keyword is used to declare an extension. It is followed by the type being extended and the functionality added to that type. Once a function is extended to a type, such as String, instances of that type within the current package can access the function as if it were originally part of the type.extend String {\n    public func printSize() {\n        println(\"the size is ${this.size}\")\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How to extend generic types in Cangjie?\nANSWER:When extending generic types in Cangjie, there are two types of extension syntax:\nSpecific Generic Instance Extension: The extend keyword can be followed by a fully instantiated generic type. The added functionality is only available when the type matches exactly, and the type arguments must meet the constraints defined in the generic type.\nGeneric Parameter Extension: The extend keyword can introduce generic parameters for the extension. This allows extending uninstantiated or partially instantiated generic types. The generic parameters declared after extend must be directly or indirectly used in the extended generic type. The added functionality is only available when the type and constraints match exactly.// Specific Generic Instance Extension\nclass Foo<T> where T <: ToString {}\nextend Foo<Int64> {} // Ok\nclass Bar {}\nextend Foo<Bar> {} // Error\n// Generic Parameter Extension\nclass MyList<T> {\n    public let data: Array<T> = Array<T>()\n}\nextend<T> MyList<T> {} // OK\nextend<R> MyList<R> {} // OK\nextend<T, R> MyList<(T, R)> {} // OK\nextend MyList {} // Error\nextend<T, R> MyList<T> {} // Error\nextend<T, R> MyList<T, R> {} // Error"}
{"text": "QUESTION:In Cangjie code language,How to add conditional functionality to generic types in Cangjie?\nANSWER:For generic type extensions, additional generic constraints can be declared within the extension to implement functions that are only available under certain conditions.\nFor example, a type called Pair can be defined to store two elements (similar to a Tuple). If the Pair type should accommodate any type, the generic parameters should not have any constraints. However, if the elements can be compared for equality, the Pair type can also implement an equals function through an extension.class Pair<T1, T2> {\n    var first: T1\n    var second: T2\n    public init(a: T1, b: T2) {\n        first = a\n        second = b\n    }\n}\ninterface Eq<T> {\n    func equals(other: T): Bool\n}\nextend<T1, T2> Pair<T1, T2> where T1 <: Eq<T1>, T2 <: Eq<T2> {\n    public func equals(other: Pair<T1, T2>) {\n        first.equals(other.first) && second.equals(other.second)\n    }\n}\nclass Foo <: Eq<Foo> {\n    public func equals(other: Foo): Bool {\n        true\n    }\n}\nmain() {\n    let a = Pair(Foo(), Foo())\n    let b = Pair(Foo(), Foo())\n    println(a.equals(b)) // true\n}"}
