{"text": "QUESTION:In Cangjie code language,How to throw exceptions in Cangjie?\nANSWER:Exceptions in Cangjie are class types, and can be created like any other class object. The throw keyword is used to throw an exception. The expression following throw must be a subtype of Exception (note that Error cannot be manually thrown). For example:throw ArithmeticException(\"I am an Exception!\")\nIf an exception is thrown and not caught, the system will call the default exception handler."}
{"text": "QUESTION:In Cangjie code language,How to use basic try expressions in Cangjie?\nANSWER:Exception handling in Cangjie is done using try expressions, which can be divided into two types:\nOrdinary try expressions without resource management.\ntry-with-resources expressions for automatic resource management.\nA basic try expression consists of three parts:\ntry block: Begins with the keyword try and contains a block of code that may throw an exception.\ncatch block: Can contain zero or more catch blocks to handle specific exceptions. Each catch block specifies a pattern to match the thrown exception.\nfinally block: Contains cleanup code that is executed regardless of whether an exception was thrown or caught.main() {\n    try {\n        throw NegativeArraySizeException(\"I am an Exception!\")\n    } catch (e: NegativeArraySizeException) {\n        println(e)\n        println(\"NegativeArraySizeException is caught!\")\n    }\n    println(\"This will also be printed!\")\n}"}
{"text": "QUESTION:In Cangjie code language,What is the purpose of the finally block in Cangjie?\nANSWER:The finally block in a try expression is used for cleanup operations. It is executed regardless of whether an exception was thrown or caught. The finally block is optional, but it is commonly used to release resources or perform other necessary cleanup tasks.main() {\n    try {\n        throw NegativeArraySizeException(\"NegativeArraySizeException\")\n    } catch (e: NegativeArraySizeException) {\n        println(\"Exception info: ${e}.\")\n    } finally {\n        println(\"The finally block is executed.\")\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How to use try expressions in Cangjie?\nANSWER:A normal try expression consists of three parts: the try block, the catch block, and the finally block.The blocks immediately following the try and the scope of each catch block are independent of each other.\nTry expressions can appear anywhere expressions are allowed. The type of a try expression is determined in a similar way to the type of multi-branch syntax structures such as if and match expressions, and is the smallest common parent type of all branches except the finally branch. \nIn addition, when the value of the try expression is not used, its type is Unit, and the type of each branch is not required to have a minimum common parent type.open class C { }\nopen class D <: C { }\nclass E <: D { }\nmain () {\n    let x = try {\n        E()\n    } catch (e: Exception) {\n        D()\n    } finally {\n        C()\n    }\n    0\n}"}
{"text": "QUESTION:In Cangjie code language,How to use try-with-resources expressions in Cangjie?\nANSWER:The try-with-resources expression is primarily used to automatically release non-memory resources. Unlike normal try expressions, the catch block and finally block in the try-with-resources expression are optional, and one or more ResourceSpecifications can be inserted between the blocks after the try keyword to apply for a series of resources (ResourceSpecification does not affect the type of the entire try expression). The resource in this case corresponds to an object at the linguistic level, so a ResourceSpecification is really a series of objects that are instantiated (used between multiple instantiations, \"separated\").class Worker <: Resource {\n    var hasTools: Bool = false\n    let name: String\n\n    public init(name: String) {\n        this.name = name\n    }\n    public func getTools() {\n        println(\"${name} picks up tools from the warehouse.\")\n        hasTools = true\n    }\n\n    public func work() {\n        if (hasTools) {\n            println(\"${name} does some work with tools.\")\n        } else {\n            println(\"${name} doesn't have tools, does nothing.\")\n        }\n    }\n\n\n    public func isClosed(): Bool {\n        if (hasTools) {\n            println(\"${name} hasn't returned the tool.\")\n            false\n        } else {\n            println(\"${name} has no tools\")\n            true\n        }\n    }\n    public func close(): Unit {\n        println(\"${name} returns the tools to the warehouse.\")\n        hasTools = false\n    }\n}\n\nmain() {\n    try (r = Worker(\"Tom\")) {\n        r.getTools()\n        r.work()\n    }\n    try (r = Worker(\"Bob\")) {\n        r.work()\n    }\n    try (r = Worker(\"Jack\")) {\n        r.getTools()\n        throw Exception(\"Jack left, because of an emergency.\")\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How to use catch patterns in Cangjie?\nANSWER:Most of the time, you only want to catch exceptions of a certain type and its subtypes, and then use the type pattern of CatchPattern to handle it; However, sometimes it is necessary to handle all exceptions uniformly (such as the exception should not occur here, and the error will be reported uniformly), in which case you can use the wildcard pattern of CatchPattern to handle it.\nThe type pattern is syntactically formatted in two formats:\nIdentifier: ExceptionClass。 This format captures exceptions of type ExceptionClass and its subclasses, converts the captured exception instances into ExceptionClass, binds them to the variables defined by the Identifier, and then accesses the captured exception instances through the variables defined by the Identifier in the catch block.\ndentifier: ExceptionClass_1 | ExceptionClass_2 | ... | ExceptionClass_n。 This format can be obtained by the connector | Splice multiple exception classes with connectors | Relationships that represent \"or\": You can catch an exception of type ExceptionClass_1 and its subclass, or an exception of type ExceptionClass_2 and its subclass, and so on, or an exception of type ExceptionClass_n and its subclass (assuming n is greater than 1). The exception to be caught is caught when the type of the exception belongs to either of the OR relationships above or its subtypes. However, since it is not possible to statically determine the type of the caught exception, the type of the caught exception is converted to a defined by | Connect the smallest common parent class of all types, and bind the exception instance to the variable defined by the Identifier. As a result, in this type of mode, the member variables and member functions in the smallest common parent class of ExceptionClass_i(1 <= i <= n) can only be accessed through variables defined by the Identifier within the catch block. Of course, you can also use wildcards instead of Identifiers in type patterns, except that wildcards don't bind them.main(): Int64 {\n    try {\n        throw IllegalArgumentException(\"This is an Exception!\")\n    } catch (e: OverflowException) {\n        println(e.message)\n        println(\"OverflowException is caught!\")\n    } catch (e: IllegalArgumentException | NegativeArraySizeException) {\n        println(e.message)\n        println(\"IllegalArgumentException or NegativeArraySizeException is caught!\")\n    } finally {\n        println(\"finally is executed!\")\n    }\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,How to use wildcard pattern in Cangjie?\nANSWER:The syntax of the wildcard pattern is _, which catches any type of exception thrown within the sibling try block, which is equivalent to e:Exception in the type pattern, which catches the exception defined by the Exception subclass.// Catch with wildcardPattern.\ntry {\n    throw OverflowException()\n} catch (_) {\n    println(\"catch an exception!\")\n}"}
