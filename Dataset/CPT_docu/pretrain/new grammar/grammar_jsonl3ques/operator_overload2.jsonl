{"text": "QUESTION:In Cangjie code language,What is operator overloading in Cangjie?\nANSWER:Operator overloading in Cangjie allows you to define custom behavior for operators on user-defined types. This is achieved by defining functions with the operator keyword. When an operator is used on an instance of the type, the corresponding operator function is called automatically.open class Point {\n    var x: Int64 = 0\n    var y: Int64 = 0\n    public init (a: Int64, b: Int64) {\n        x = a\n        y = b\n    }\n    public operator func -(): Point {\n        Point(-x, -y)\n    }\n    public operator func +(right: Point): Point {\n        Point(this.x + right.x, this.y + right.y)\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How is operator overloading used in Cangjie?\nANSWER:Once an operator is overloaded for a type, you can use the operator directly on instances of that type. The corresponding operator function will be called automatically.main() {\n    let p1 = Point(8, 24)\n    let p2 = -p1      // p2 = Point(-8, -24)\n    let p3 = p1 + p2  // p3 = Point(0, 0)\n}"}
{"text": "QUESTION:In Cangjie code language,What are the rules for operator overloading in Cangjie?\nANSWER:Operator functions must be defined with the operator keyword.\nThe number of parameters in the operator function must match the requirements of the operator.\nOperator functions can only be defined within class, interface, struct, enum, or extend.\nOperator functions have instance member semantics and cannot be static.\nOperator functions cannot be generic.open class Point {\n    var x: Int64 = 0\n    var y: Int64 = 0\n    public init (a: Int64, b: Int64) {\n        x = a\n        y = b\n    }\n    public operator func -(): Point {\n        Point(-x, -y)\n    }\n    public operator func +(right: Point): Point {\n        Point(this.x + right.x, this.y + right.y)\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How is the indexing operator overloaded in Cangjie?\nANSWER:The indexing operator [] can be overloaded for both getting and setting values. The get form does not require a value parameter, while the set form requires a value parameter.class A {\n    operator func [](arg1: Int64, arg2: String): Int64 {\n        return 0\n    }\n}\nfunc f() {\n    let a = A()\n    let b: Int64 = a[1, \"2\"]\n    // b == 0\n}"}
{"text": "QUESTION:In Cangjie code language,How is the function call operator overloaded in Cangjie?\nANSWER:The function call operator () can be overloaded to allow instances of a type to be called like functions.open class A {\n    public init() {}\n    public operator func ()(): Unit {}\n}\n\nfunc test1() {\n    let a = A() // Ok, A() is call the constructor of A.\n    a() // Ok, a() is to call the operator () overloading function.\n}"}
{"text": "QUESTION:In Cangjie code language,What are the restrictions on operator overloading in Cangjie?\nANSWER:You cannot overload operators that are not listed in the appendix.\nYou cannot define custom operators.\nYou can't use this or super to call the () operator to overload the function. \nIf a type already supports an operator, you cannot overload it again through extension.open class A {\n    public init() {}\n    public init(x: Int64) {\n        this() // Ok, this() calls the constructor of A.\n    }\n    public operator func ()(): Unit {}\n\n    public func foo() {\n        this()  // Error, this() calls the constructor of A.\n        super() // Error\n    }\n}\nclass B <: A {\n    public init() {\n        super() // Ok, super()  calls the constructor of the super class.\n    }\n    public func goo() {\n        super() // Error\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How does operator overloading affect priority in Cangjie?\nANSWER:Overloading an operator does not change its inherent precedence and associativity. The precedence and associativity of operators are fixed and defined in the language specification.\nFor enumeration types, the constructor form is preferred when both the constructor form and the () operator overloaded function form are satisfied.enum E {\n    Y | X | X(Int64)\n\n    public operator func ()(p: Int64) {}\n    public operator func ()(p: Float64) {}\n}\n\nmain() {\n    let e = X(1) // Ok, X(1) is to call the constructor X(Int64).\n    X(1.0) // Ok, X(1.0) is to call the operator () overloading function.\n    let e1 = X\n    e1(1) // Ok, e1(1) is to call the operator () overloading function.\n    Y(1) // oK, Y(1) is to call the operator () overloading function.\n}"}
{"text": "QUESTION:In Cangjie code language,What operators can be overloaded in Cangjie?\nANSWER:Cangjie allows overloading of the following operators, listed in order of precedence from highest to lowest:\nOperator\tDescription\n()\tFunction call\n[]\tIndexing\n!\tLogical NOT\n-\tUnary minus (negation)\n**\tExponentiation (power)\n*\tMultiplication\n/\tDivision\n%\tModulus (remainder)\n+\tAddition\n-\tSubtraction\n<<\tBitwise left shift\n>>\tBitwise right shift\n<\tLess than\n<=\tLess than or equal to\n>\tGreater than\n>=\tGreater than or equal to\n==\tEquality\n!=\tInequality\n&\tBitwise AND\n^\tBitwise XOR\n|\tBitwise OR\nThese operators can be overloaded by defining corresponding operator functions within classes, interfaces, structs, enums, or extensions."}
{"text": "QUESTION:In Cangjie code language,What are the restrictions on overloading operators in Cangjie?\nANSWER:You cannot overload operators that are not listed in the table above.\nYou cannot define custom operators beyond those listed.\nIf a type already supports an operator, you cannot overload it again through extension.\nOverloading an operator does not change its inherent precedence and associativity."}
