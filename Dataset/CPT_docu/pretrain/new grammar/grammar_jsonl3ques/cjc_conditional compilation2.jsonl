{"text": "QUESTION:In Cangjie code language,What is conditional compilation in Cangjie?\nANSWER:Conditional compilation in Cangjie allows developers to compile code based on predefined or custom conditions. Cangjie supports conditional compilation for imports and declarations using the @When built-in compilation flag. Conditions are specified within square brackets [] and can include multiple conditions."}
{"text": "QUESTION:In Cangjie code language,How to use the @When flag in Cangjie?\nANSWER:The @When flag is used to specify conditions for conditional compilation. It can be applied to import nodes and declaration nodes (except package). Conditions are enclosed in square brackets [].\nCangjie does not support nested conditions. Conditions specified in code generated by macro expansion will result in a compilation error.@When[os == \"Linux\"]\nclass mc{}\n\nmain(): Int64 {\n    var a = mc()\n    return 0\n\nError_case:\n@When[os == \"Windows\"]\n@When[os == \"Linux\"]    // Error, illegal nested when conditional compilation\nimport std.ast.*\n@When[os == \"Windows\"]\n@When[os == \"Linux\"]    // Error, illegal nested when conditional compilation\nfunc A(){}\n}"}
{"text": "QUESTION:In Cangjie code language,What are the built-in compilation conditions in Cangjie?\nANSWER:Cangjie provides several built-in conditions for conditional compilation:\nos: Target platform's operating system (Windows, Linux, macOS).\nbackend: Target backend and processor architecture (cjnative, cjnative-x86_64, cjnative-aarch64).\ncjc_version: Version of the Cangjie compiler.\ndebug: Indicates whether debug mode is enabled.\ntest: Indicates whether unit testing is enabled."}
{"text": "QUESTION:In Cangjie code language,How to use the os condition in Cangjie?\nANSWER:The os condition checks the target platform's operating system. It supports == and != operators. Supported operating systems include Windows, Linux, and macOS.@When[os == \"Linux\"]\nfunc foo() {\n    print(\"Linux, \")\n}\n@When[os == \"Windows\"]\nfunc foo() {\n    print(\"Windows, \")\n}\n@When[os != \"Windows\"]\nfunc fee() {\n    println(\"NOT Windows\")\n}\n@When[os != \"Linux\"]\nfunc fee() {\n    println(\"NOT Linux\")\n}\nmain() {\n    foo()\n    fee()\n}"}
{"text": "QUESTION:In Cangjie code language,How to use the backend condition in Cangjie?\nANSWER:The backend condition checks the target backend and processor architecture. It supports == and != operators. Supported backends include cjnative, cjnative-x86_64, and cjnative-aarch64.@When[backend == \"cjnative-x86_64\"]\nfunc foo() {\n    print(\"cjnative-x86_64 backend, \")\n}\n@When[backend == \"cjnative-aarch64\"]\nfunc foo() {\n    print(\"cjnative-aarch64 backend, \")\n}\n@When[backend != \"cjnative-x86_64\"]\nfunc fee() {\n    println(\"NOT cjnative-x86_64 backend\")\n}\n@When[backend != \"cjnative-aarch64\"]\nfunc fee() {\n    println(\"NOT cjnative-aarch64 backend\")\n}\nmain() {\n    foo()\n    fee()\n}"}
{"text": "QUESTION:In Cangjie code language,How to use the cjc_version condition in Cangjie?\nANSWER:The cjc_version condition allows selecting code based on the Cangjie compiler version. It supports ==, !=, >, <, >=, and <= operators. The version format is xx.xx.xx, where each xx can be 1-2 digits.@When[cjc_version == \"0.18.6\"]\nfunc foo() {\n    println(\"cjc_version equals 0.18.6\")\n}\n@When[cjc_version != \"0.18.6\"]\nfunc foo() {\n    println(\"cjc_version is NOT equal to 0.18.6\")\n}\n@When[cjc_version > \"0.18.6\"]\nfunc fnn() {\n    println(\"cjc_version is greater than 0.18.6\")\n}\n@When[cjc_version <= \"0.18.6\"]\nfunc fnn() {\n    println(\"cjc_version is less than or equal to 0.18.6\")\n}\n@When[cjc_version < \"0.18.6\"]\nfunc fee() {\n    println(\"cjc_version is less than 0.18.6\")\n}\n@When[cjc_version >= \"0.18.6\"]\nfunc fee() {\n    println(\"cjc_version is greater than or equal to 0.18.6\")\n}\nmain() {\n    foo()\n    fnn()\n    fee()\n}"}
{"text": "QUESTION:In Cangjie code language,How to use the debug condition in Cangjie?\nANSWER:The debug condition checks whether debug mode is enabled (-g compilation option). It supports the logical NOT operator (!).@When[debug]\nfunc foo() {\n    println(\"debug\")\n}\n@When[!debug]\nfunc foo() {\n    println(\"NOT debug\")\n}\nmain() {\n    foo()\n}"}
{"text": "QUESTION:In Cangjie code language,How to use the test condition in Cangjie?\nANSWER:The test condition checks whether unit testing is enabled (--test compilation option). It supports the logical NOT operator (!).@When[test]\n@Test\nclass Tests {\n    @TestCase\n    public func case1(): Unit {\n        @Expect(\"run\", foo())\n    }\n}\n\nfunc foo() {\n    \"run\"\n}\n\n@When[!test]\nmain () {\n    println(foo())\n}"}
{"text": "QUESTION:In Cangjie code language,How to define and use custom compilation conditions in Cangjie?\nANSWER:Cangjie allows developers to define custom compilation conditions. Custom conditions must be valid identifiers and cannot overlap with built-in conditions. Values are string literals. Custom conditions are defined using the --cfg compilation option or in the cfg.toml configuration file.# Defining custom condition via command line\ncjc --cfg \"my_condition=value\"\n# Defining custom condition in cfg.toml\n[custom]\nmy_condition = \"value\""}
{"text": "QUESTION:In Cangjie code language,How to use multiple conditions in conditional compilation in Cangjie?\nANSWER:Cangjie supports combining multiple conditions using logical operators and parentheses to specify precedence.//source.cj\n@When[(test || feature == \"lion\") && !debug]\nfunc fee() {\n    println(\"feature lion\")\n}\nmain() {\n    fee()\n}"}
