{"text": "QUESTION:In Cangjie code language,What are I/O processing streams in Cangjie and how do they work?\nANSWER:Processing streams in Cangjie are streams that proxy and process other streams. They are used to add additional functionality to existing streams. Common processing streams in Cangjie include BufferedInputStream, BufferedOutputStream, StringReader, StringWriter, and ChainedInputStream. This section focuses on buffered streams and string streams."}
{"text": "QUESTION:In Cangjie code language,How to use buffered streams in Cangjie?\nANSWER:Buffered streams are used to improve the performance of I/O operations by reducing the number of I/O operations required. BufferedInputStream and BufferedOutputStream are provided in the Cangjie standard library to add buffering capabilities to streams.\nBufferedInputStream: What BufferedInputStream does is the ability to add buffering to another input stream. Essentially, BufferedInputStream is implemented via an array of internal buffers.When reading the data of a stream through BufferedInputStream, BufferedInputStream will read the entire buffer size of the data at once, and then use the read function to read the smaller data in multiple times. When the data in the buffer is read, the input stream fills the buffer again; And so on until all the data for the data stream has been read.If you construct a BufferedInputStream, you only need to pass another input stream in the constructor. If you need to specify the size of the buffer, you can also specify it by passing in an additional capacity parameter.\nBufferedOutputStream:What BufferedOutputStream does is the ability to add buffering to another output stream. BufferedOutputStream is also implemented via an array of internal buffers.When data is written to the output stream via BufferedOutputStream, the data written is first written to the internal buffer array; When the data in the buffer is filled, BufferedOutputStream will write the data in the buffer to the output stream once, and then empty the buffer to be written again. And so on until all the data is written.It should be noted that since the write operation of the output stream will not be triggered when there is not enough buffer written, when all the data is written to the BufferedOutputStream, you need to call the flush function to finally complete the write.If you construct a BufferedOutputStream, you only need to pass in another output stream in the constructor. If you need to specify the size of the buffer, you can also specify it with an additional capacity parameter.\nTo use BufferedInputStream and BufferedOutputStream, you need to import the io packageï¼šimport std.io.*//BufferedInputStream \nimport std.io.*\nmain(): Unit {\n    let arr1 = \"0123456789\".toArray()\n    let byteArrayStream = ByteArrayStream()\n    byteArrayStream.write(arr1)\n    let bufferedInputStream = BufferedInputStream(byteArrayStream)\n    let arr2 = Array<Byte>(20, item: 0)\n\n   /* Read the data in the stream and return the length of the read data */\n    let readLen = bufferedInputStream.read(arr2)\n    println(String.fromUtf8(arr2[..readLen])) // 0123456789\n}\n\n//BufferedOutputStream\nimport std.io.*\nmain(): Unit {\n    let arr1 = \"01234\".toArray()\n    let byteArrayStream = ByteArrayStream()\n    byteArrayStream.write(arr1)\n    let bufferedOutputStream = BufferedOutputStream(byteArrayStream)\n    let arr2 = \"56789\".toArray()\n\n    /* Write data to the stream. At this time, the data is in the buffer of the external stream */\n    bufferedOutputStream.write(arr2)\n\n    /* Call the flush function to actually write the data into the internal flow */\n    bufferedOutputStream.flush()\n    println(String.fromUtf8(byteArrayStream.readToEnd())) // 0123456789\n}"}
{"text": "QUESTION:In Cangjie code language,How to use string streams in Cangjie?\nANSWER:Cangjie provides StringReader and StringWriter to handle string data more conveniently. These streams are designed to work with text data and provide better performance and usability compared to manually converting between byte data and strings.\nStringReader: Reads text data from a string or an input stream. It provides methods to read lines or read based on specific conditions.\nStringWriter: Writes text data to a string or an output stream. It provides methods to write strings directly or write lines.\nTo use StringReader and StringWriter, you need to import the io package:import std.io.*//Example of using StringReader:\nimport std.io.*\nmain(): Unit {\n    let arr1 = \"012\\n346789\".toArray()\n    let byteArrayStream = ByteArrayStream()\n    byteArrayStream.write(arr1)\n    let stringReader = StringReader(byteArrayStream)\n\n    /* Read a line of data */\n    let line = stringReader.readln()\n    println(line ?? \"error\") // 012\n}\n\n//Examples of how to use StringWriter:\nimport std.io.*\nmain(): Unit {\nlet byteArrayStream = ByteArrayStream()\nlet stringWriter = StringWriter(byteArrayStream)\n\n/* Write a string */\nstringWriter.write(\"number\")\n\n/* Write a string and switch lines automatically */\nstringWriter.writeln(\" is:\")\n\n/* Write a number */\nF32 stringWriter. Write (100.0)\n\nstringWriter.flush()"}
