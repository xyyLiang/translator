{"text": "QUESTION:In Cangjie code language,What is the structure of a Cangjie program?\nANSWER:Cangjie programs are typically written in text files with the extension .cj. These programs and files are also known as source code and source files. In the final stage of program development, the source code is compiled into a specific format of binary files.In the top-level scope of the Cangjie program, you can define a series of variables, functions, and custom types (such as struct, class, enum, interface, etc.), where the variables and functions are called global variables and global functions, respectively. If you want to compile the Cangjie program into an executable file, you need to define a main function in the top-level scope as the program entry, which can have arguments of Array<String>type or no arguments, and its return value type can be an integer type or Unit type."}
{"text": "QUESTION:In Cangjie code language,What can be defined in the top-level scope of a Cangjie program?\nANSWER:In the top-level scope of a Cangjie program, you can define a series of variables, functions, and custom types (such as struct, class, enum, and interface). The variables and functions defined here are called global variables and global functions. To compile a Cangjie program into an executable file, a main function must be defined in the top-level scope as the program entry point. The main function can have an Array<String>or no arguments, and its return value type can be an integer type or Unit type.let a = 2023\nfunc b() {}\nstruct C {}\nclass D {}\nenum E { F | G }\n\nmain() {\n    println(a)\n}"}
{"text": "QUESTION:In Cangjie code language,What are the requirements for the main function in Cangjie?\nANSWER:The main function serves as the entry point of a Cangjie program. It can have an Array<String>or no arguments, and its return value type can be an integer type or Unit type.When defining the main function, you don't need to write the func modifier. In addition, if you need to get command-line arguments when a program starts, you can declare and use Array<String> type arguments.main() {\n    println(a)\n}"}
{"text": "QUESTION:In Cangjie code language,What can be defined in a local scope in Cangjie?\nANSWER:In non-top-level scopes, custom types cannot be defined, but variables and functions can be defined. These are called local variables and local functions. Variables and functions defined inside custom types are called member variables and member functions.func a() {\n    let b = 2023 // Local variable\n    func c() { // Local function\n        println(b)\n    }\n    c()\n}\nclass A {\n    let b = 2024\n    public func c() {\n        println(b)\n    }\n}\n\nmain() {\n    a()\n    A().c()\n}\n//Compiling and running this program will output:2023/n2024"}
{"text": "QUESTION:In Cangjie code language,How are variables defined in Cangjie?\nANSWER:Variables are defined in the following form: “Modifier variable name: Variable type = initial value”\nA variable consists of the corresponding variable name, data (value) and several attributes, and the developer accesses the data corresponding to the variable through the variable name, but the access operation needs to comply with the constraints of the relevant attributes (such as data type, variability, visibility, etc.).\nModifiers are used to set various properties of variables, and there can be one or more of them,and commonly used modifiers include:Variability modifiers: let and var,Visibility modifiers, such as private and public,Static modifiers: Static.\nThe variable name should be a valid Cangjie identifier.\nThe variable type specifies the type of data held by the variable.\nThe initial value is a cangjie expression, which is used to initialize the variable, if the variable type is marked, you need to ensure that the initial value type and the variable type are consistent.main() {\n    let a: Int64 = 20\n    var b: Int64 = 12\n    b = 23\n    println(\"${a}${b}\")\n}\n//Compiling and running this program will output:2023"}
{"text": "QUESTION:In Cangjie code language,What are the commonly used modifiers in Cangjie?\nANSWER:Modifiers are used to set various properties of variables, and there can be one or more of them, and commonly used modifiers include:1.Variability modifiers: let and var, corresponding to immutable and variable attributes, respectively, variability determines whether the value of a variable can be changed after initialization, and Cangjie variables are also divided into two categories: immutable and mutable.2.Visibility modifiers, such as private and public, affect the referencable range of global variables and member variables, as detailed in the following sections.3.Static modifiers: Static, which affect how member variables are stored and referenced, see the following sections.Variability modifiers are necessary when defining Cangjie variables, and on top of that, other modifiers can be added as needed.let a: Int64 = 10 // Immutable variable\nvar b: Int64 = 20 // Mutable variable\nb = 30 // Changing the value of a mutable variable\n\nError_case:\nlet a: Int64 = 10\na = 20 // Error: Cannot reassign immutable variable"}
{"text": "QUESTION:In Cangjie code language,When must variables be initialized in Cangjie?\nANSWER:The initial value is a cangjie expression, which is used to initialize the variable, if the variable type is marked, you need to ensure that the initial value type and the variable type are consistent.The variable name should be a valid Cangjie identifier.The variable type specifies the type of data held by the variable. When the initial value has an explicit type, the variable type annotation can be omitted, and the compiler can automatically infer the variable type.When you define a global variable or a static member variable, you must specify an initial value. When defining a local variable or an instance member variable, you can omit the initial value, but you need to specify the variable type, and initialize the variable before it is referenced, otherwise the compilation will cause an error.main() {\n    let a: Int64 = 2023\n    let b = a //variable type annotations can be omitted when the initial value has an explicit type\n    println(\"a - b = ${a - b}\")\n}"}
{"text": "QUESTION:In Cangjie code language,What are the differences between the initialization of local variables and global variables in Cangjie?\nANSWER:When defining a local variable, you can leave it uninitialized, but be sure to give the initial value to the variable before it is referenced.Global variables and static member variables must be initialized when defined, otherwise the compilation will result in an error.It should be noted that when the compiler cannot determine whether certain scenarios will be initialized or whether immutable variables have been initialized repeatedly, it will tend to compile with a conservative policy and report an errormain() {\n    let text: String\n    text = \"it's string type\"\n    println(text)\n}\n\nError_case:\nlet global: Int64 // Error, variable in top-level scope must be initialized\nclass Player {\n    static let score: Int32 // Error, static variable 'score' needs to be initialized when declaring\n}"}
{"text": "QUESTION:In Cangjie code language,What are the value and reference types in Cangjie?\nANSWER:From the compiler implementation level, any variable will always be associated with a value (usually through memory address/register), but when used, for some variables, the value itself will be directly used, which is called a value type variable, and for other variables, this value is used as an index and the data indicated by this index is used, which is called a reference type variable."}
{"text": "QUESTION:In Cangjie code language,What is the difference between value and reference types in Cangjie?\nANSWER:Value-type variables are typically assigned on the thread stack, and each variable has its own copy of the data; Reference-type variables are typically assigned in the process heap, multiple variables can reference the same data object, and actions performed on one variable can affect other variables.At the linguistic level, a value-type variable is exclusive to the data/storage space it binds, while the data/storage space bound to a reference-type variable can be shared with other reference-type variables.There are some behavioral differences when using value-type variables and reference-type variables:1.When assigning a value to a value type variable, a copy operation is usually generated, and the original bound data/storage space is overwritten. When assigning a value to a reference type variable, the reference relationship is only changed, and the original bound data/storage space will not be overwritten.2.Variables defined with let require that the variables cannot be assigned values after they have been initialized. For reference types, this only limits the fact that the reference relationship cannot be changed, but the referenced data can be modified.3.In the Cangjie programming language, types such as class and array belong to reference types, and other underlying data types and types such as struct belong to value types.struct Copy {\n    var data = 2012\n}\nclass Share {\n    var data = 2012\n}\nmain() {\n    let c1 = Copy()\n    var c2 = c1\n    c2.data = 2023\n    println(\"${c1.data}, ${c2.data}\")\n    let s1 = Share()\n    let s2 = s1\n    s2.data = 2023\n    println(\"${s1.data}, ${s2.data}\")\n}\n// Running the above program, it will output:2012, 2023/n2023, 2023\n\nError_case:\nstruct Copy {\n    var data = 2012\n}\n\nmain() {\n    let c1 = Copy()\n    let c2 = c1\n    c2.data = 2023 // Error, cannot assign to immutable value\n}"}
{"text": "QUESTION:In Cangjie code language,What are the scope rules in Cangjie?\nANSWER:Cangjie uses curly braces {} to define new scopes. In a Cangjie source file, the scope of the code that is not surrounded by any curly braces \"{}\" is called the \"top-level scope\".The scope rules are as follows:\n1.The binding relationship between the program element defined in the current scope and its name is valid in the current scope and its inner scope, and the corresponding program element can be directly accessed through this name.2.The binding relationship between the program element and the name defined in the inner scope is invalid in the outer scope.3.The inner scope can be redefined with the name in the outer scope, and according to Rule 1, the naming in the inner scope is equivalent to obscuring the definition of the same name in the outer scope, for which the inner scope can be said to be of a higher level than the outer scope.4.Cangjie does not allow the use of separate curly braces \"{}\", which must rely on other syntactic constructs such as if, match, function body, class body, and struct.let element = \"仓颉\"\nmain() {\n    println(element)\n    let element = 9\n    if (element > 0) {\n        let element = 2023\n        println(element)\n    }\n    println(element)\n}\n// Running the above program, it will output:仓颉/n2023/n9"}
