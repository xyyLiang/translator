{"text": "QUESTION:In Cangjie code language,What is a match expression in Cangjie?\nANSWER:Cangjie supports two types of match expressions: those with a match value and those without a match value.\nMatch expressions with a match value: These expressions start with the match keyword followed by the value to be matched and a series of case branches enclosed in curly braces.\nMatch expressions without a match value: These expressions start with the match keyword followed by a series of case branches with boolean expressions or _ instead of patterns.\nMatch expressions are used to destructure and match values against various patterns, allowing for expressive and type-safe handling of different cases."}
{"text": "QUESTION:In Cangjie code language,How does a match expression with a match value work in Cangjie?\nANSWER:A match expression with a match value starts with the match keyword followed by the value to be matched. Each case branch consists of a pattern (or multiple patterns separated by |), an optional pattern guard, and a block of code to execute if the pattern matches.\nPattern matching: The match value is compared against each pattern in order. If a pattern matches and the pattern guard (if present) evaluates to true, the corresponding code block is executed.\nExhaustiveness: The match expression must cover all possible values of the match value. If the compiler cannot determine that all cases are covered, it will report an error.\nWildcard pattern: The wildcard pattern _ can be used to match any value and is often used as the last case to cover all remaining possibilities.main() {\n    let x = 0\n    match (x) {\n        case 1 => let r1 = \"x = 1\"\n                  print(r1)\n        case 0 => let r2 = \"x = 0\" // Matched.\n                  print(r2)\n        case _ => let r3 = \"x != 1 and x != 0\"\n                  print(r3)\n    }\n}\n//output：x = 0"}
{"text": "QUESTION:In Cangjie code language,How does a match expression without a match value work in Cangjie?\nANSWER:A match expression without a match value starts with the match keyword followed by a series of case branches with boolean expressions or _. Each case branch consists of a boolean expression and a block of code to execute if the expression evaluates to true.\nBoolean expressions: The match expression evaluates each boolean expression in order. If an expression evaluates to true, the corresponding code block is executed.\nOrder of evaluation: The match expression stops evaluating as soon as a true expression is found.main() {\n    let x = -1\n    match {\n        case x > 0 => print(\"x > 0\")\n        case x < 0 => print(\"x < 0\") // Matched.\n        case _ => print(\"x = 0\")\n    }\n}\n//output：x < 0"}
{"text": "QUESTION:In Cangjie code language,What is the type of a match expression in Cangjie?\nANSWER:The type of a match expression in Cangjie depends on the context and the types of the code blocks in the case branches.\nContextual type: If the context has a specific type requirement, each case branch must have a type that is a subtype of the required type.\nLeast common supertype: If the context does not specify a type, the type of the match expression is the least common supertype of the types of the code blocks in the case branches.\nUnit type: If the match expression's value is not used, its type is Unit, and the types of the code blocks do not need to have a common supertype.//the context type information is clear\nlet x = 2\nlet s: String = match (x) {\n    case 0 => \"x = 0\"\n    case 1 => \"x = 1\"\n    case _ => \"x != 0 and x != 1\" // Matched.\n}\n//with no context type information\nlet x = 2\nlet s = match (x) {\n    case 0 => \"x = 0\"\n    case 1 => \"x = 1\"\n    case _ => \"x != 0 and x != 1\" // Matched.\n}"}
