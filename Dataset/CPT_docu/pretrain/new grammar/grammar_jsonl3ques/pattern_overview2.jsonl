{"text": "QUESTION:In Cangjie code language,What is pattern matching in Cangjie?\nANSWER:Pattern matching in Cangjie is a powerful feature that allows you to destructure and match values against various patterns. This is particularly useful for handling complex data structures and enum types. Cangjie supports several types of patterns, including constant patterns, wildcard patterns, binding patterns, tuple patterns, type patterns, and enum patterns."}
{"text": "QUESTION:In Cangjie code language,What is a constant pattern in Cangjie?\nANSWER:A constant pattern matches a specific value, such as an integer, float, character, boolean, string, or Unit. The type of the constant pattern must match the type of the value being matched.\nRune literals: When matching against a Rune type, both Rune literals and single-character string literals can be used.\nByte literals: When matching against a Byte type, a string literal representing an ASCII character can be used.main() {\n    let score = 90\n    let level = match (score) {\n        case 0 | 10 | 20 | 30 | 40 | 50 => \"D\"\n        case 60 => \"C\"\n        case 70 | 80 => \"B\"\n        case 90 | 100 => \"A\" // Matched.\n        case _ => \"Not a valid score\"\n    }\n    println(level) // Output: A\n}"}
{"text": "QUESTION:In Cangjie code language,What is a wildcard pattern in Cangjie?\nANSWER:A wildcard pattern is represented by the underscore _ and matches any value. It is typically used as the last case to catch all unmatched values."}
{"text": "QUESTION:In Cangjie code language,What is a binding pattern in Cangjie?\nANSWER:A binding pattern binds the matched value to a variable identifier. This allows you to access the matched value within the case block.\nBinding pattern limitations: Binding patterns cannot be used with the | operator to combine multiple patterns.\nScope of binding: The variable introduced by a binding pattern is immutable and has a scope that extends from its introduction to the end of the case block.main() {\n    let x = -10\n    let y = match (x) {\n        case 0 => \"zero\"\n        case n => \"x is not zero and x = ${n}\" // Matched.\n    }\n    println(y)\n}\n\nError_case:\nmain() {\n    let opt = Some(0)\n    match (opt) {\n        case x | x => {} // Error, variable cannot be introduced in patterns connected by '|'\n        case Some(x) | Some(x) => {} // Error, variable cannot be introduced in patterns connected by '|'\n        case x: Int64 | x: String => {} // Error, variable cannot be introduced in patterns connected by '|'\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,What is a tuple pattern in Cangjie?\nANSWER:The tuple pattern is used to match the value of the tuple and is defined similarly to the tuple literal: (p_1, p_2, ..., p_n), except that the p_1 to p_n (n greater than or equal to 2) is a pattern (it can be any of the patterns described in this section, multiple patterns are separated by commas) and not an expression.\nA tuple pattern matches a tuple value and can contain multiple patterns separated by commas. Each element in the tuple is matched against the corresponding pattern.\nTuple pattern limitations: All elements in the tuple pattern must be valid patterns.\nTuple pattern scope: The variables introduced by binding patterns within a tuple pattern are scoped to the case block.main() {\n    let tv = (\"Alice\", 24)\n    let s = match (tv) {\n        case (\"Bob\", age) => \"Bob is ${age} years old\"\n        case (\"Alice\", age) => \"Alice is ${age} years old\" // Matched, \"Alice\" is a constant pattern, and 'age' is a variable pattern.\n        case (name, 100) => \"${name} is 100 years old\"\n        case (_, _) => \"someone\"\n    }\n    println(s)\n}"}
{"text": "QUESTION:In Cangjie code language,What is a type pattern in Cangjie?\nANSWER:A type pattern checks if a value is a subtype of a specified type. It can be used to perform type checks and casts. Type patterns can be written as _ : Type or id : Type.\nFor the value v to be matched and the type pattern id: Type (or _: Type), first determine whether the runtime type of v is a subtype of Type, if it is true, it will be regarded as a successful match, otherwise it will be regarded as a failed match; If the match is successful, the type of v is converted to Type and bound to id (for _: Type, there is no binding).open class Base {\n    var a: Int64\n    public init() {\n        a = 10\n    }\n}\nclass Derived <: Base {\n    public init() {\n        a = 20\n    }\n}\nmain() {\n    var d = Derived()\n    var r = match (d) {\n        case b: Base => b.a // Matched.\n        case _ => 0\n    }\n    println(\"r = ${r}\") //outputï¼šr = 20\n}"}
{"text": "QUESTION:In Cangjie code language,What is an enum pattern in Cangjie?\nANSWER:The enum pattern is used to match instances of the enum type, and its definition is similar to the enum constructor: the parameterless constructor C or the parametric constructor C(p_1, p_2, ..., p_n), and the type prefix of the constructor can be omitted, except that p_1 to p_n (n greater than or equal to 1) is the pattern.\nGiven an enum instance ev and an enum pattern ep, an ep is said to match an ev if and only if the constructor name of the ev is the same as the constructor name of the ep, and the value at each location in the EV parameter list matches the pattern at the corresponding location in the ep.enum TimeUnit {\n    | Year(UInt64)\n    | Month(UInt64)\n}\n\n\nmain() {\n    let x = Year(2)\n    let s = match (x) {\n        case Year(n) => \"x has ${n * 12} months\" // Matched.\n        case TimeUnit.Month(n) => \"x has ${n} months\"\n    }\n    println(s) //output:x has 24 months\n}"}
{"text": "QUESTION:In Cangjie code language,How are nested patterns used in Cangjie?\nANSWER:Tuple patterns and enum patterns can be nested to match complex data structures. This allows for more expressive and concise pattern matching.enum TimeUnit {\n    | Year(UInt64)\n    | Month(UInt64)\n}\nenum Command {\n    | SetTimeUnit(TimeUnit)\n    | GetTimeUnit\n    | Quit\n}\nmain() {\n    let command = (SetTimeUnit(Year(2022)), SetTimeUnit(Year(2024)))\n    match (command) {\n        case (SetTimeUnit(Year(year)), _) => println(\"Set year ${year}\")\n        case (_, SetTimeUnit(Month(month))) => println(\"Set month ${month}\")\n        case _ => ()\n    }\n}\n//output:Set year 2022"}
