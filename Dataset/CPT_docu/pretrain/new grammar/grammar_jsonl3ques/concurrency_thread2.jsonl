{"text": "QUESTION:In Cangjie code language,How to create a new thread in Cangjie?\nANSWER:To execute a piece of code concurrently, you can create a new Cangjie thread using the spawn keyword and passing a parameterless lambda expression. The lambda expression represents the code to be executed in the new thread.import std.sync.*\nimport std.time.*\n\nmain(): Int64 {\n    spawn { =>\n        println(\"New thread before sleeping\")\n        sleep(100 * Duration.millisecond) // sleep for 100ms.\n        println(\"New thread after sleeping\")\n    }\n    println(\"Main thread\")\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,How to use Future to wait for a thread to complete in Cangjie?\nANSWER:The spawn expression in Cangjie returns a Future<T> object, where T is the return type of the lambda expression passed to spawn. The Future<T> type provides methods to wait for the thread to complete and to retrieve its result.\nget(): Blocks the current thread until the spawned thread completes and returns its result. If the thread has already completed, it returns the result immediately.\nget(ns: Int64): Blocks the current thread until the spawned thread completes or until the specified timeout ns (in nanoseconds) is reached. If the thread has not completed within the timeout, it returns None.\n <T> Future's prototype statement reads:\n\npublic class Future<T> {\n    // Blocking the current thread, waiting for the result of the thread corresponding to the current Future object.\n    // If an exception occurs in the corresponding thread, the method will throw the exception.\n    public func get(): T\n\n    // Blocking the current thread, waiting for the result of the thread corresponding to the current Future object.\n    // If the corresponding thread has not completed execution within ns nanoseconds, the method will return a Option<T>.None.\n    // If `ns` <= 0, its behavior is the same as `get()`.\n    public func get(ns: Int64): Option<T>\n\n    // Non-blocking method that immediately returns Option<T>.None if thread has not finished execution.\n    // Returns the computed result otherwise.\n    // If an exception occurs in the corresponding thread, the method will throw the exception.\n    public func tryGet(): Option<T>\n}import std.sync.*\nimport std.time.*\n\nmain(): Int64 {\n    let fut: Future<Unit> = spawn { =>\n        println(\"New thread before sleeping\")\n        sleep(100 * Duration.millisecond) // sleep for 100ms.\n        println(\"New thread after sleeping\")\n    }\n    println(\"Main thread\")\n    fut.get() // wait for the thread to finish.\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,What methods does the Future class provide in Cangjie?\nANSWER:The Future<T> class in Cangjie provides the following methods:\nget(): T: Waits for the thread to complete and returns its result.\nget(ns: Int64): Option<T>: Waits for the thread to complete or until the specified timeout ns (in nanoseconds) is reached. Returns None if the timeout is reached.\ntryGet(): Option<T>: Attempts to get the result without blocking. Returns None if the thread has not completed yet.import std.sync.*\nimport std.time.*\n\nmain(): Int64 {\n    let fut: Future<Unit> = spawn { =>\n        println(\"New thread before sleeping\")\n        sleep(100 * Duration.millisecond) // sleep for 100ms.\n        println(\"New thread after sleeping\")\n    }\n    fut.get() // wait for the thread to finish.\n    println(\"Main thread\")\n    return 0\n}"}
{"text": "QUESTION:In Cangjie code language,How to access thread properties in Cangjie?\nANSWER:Each Future<T> object in Cangjie has an associated Thread object, which provides access to thread properties such as thread ID. The Thread class cannot be instantiated directly and can only be obtained through the thread property of Future<T> or the static property currentThread.\ncurrentThread: Returns the Thread object representing the currently executing thread.\nid: Returns the unique identifier of the thread.\nhasPendingCancellation: Indicates whether the thread has a pending cancellation request.\nSome of the methods of the Thread class are defined as follows (for a complete description of the methods, please refer to the Cangjie Programming Language Library API).\nclass Thread {\n    ... ...\n    // Get the currently running thread\n    static prop currentThread: Thread\n\n    // Get the unique identifier (represented as an integer) of the thread object\n    prop id: Int64\n\n    // Check whether the thread has any cancellation request\n    prop hasPendingCancellation: Bool\n}main(): Unit {\n    let fut = spawn {\n        println(\"Current thread id: ${Thread.currentThread.id}\")\n    }\n    println(\"New thread id: ${fut.thread.id}\")\n    fut.get()\n}"}
{"text": "QUESTION:In Cangjie code language,How to terminate a thread in Cangjie?\nANSWER:In Cangjie, you can send a termination request to a thread using the cancel() method of Future<T>. However, this method does not directly stop the thread. Developers need to check the hasPendingCancellation property of the Thread class to determine if a termination request has been made.\nIt is up to the developer to implement the logic for terminating the thread. If the developer ignores the termination request, the thread will continue to execute until it completes normally.import std.sync.SyncCounter\n\nmain(): Unit {\n    let syncCounter = SyncCounter(1)\n    let fut = spawn {\n        syncCounter.waitUntilZero()  // block until the syncCounter becomes zero\n        if (Thread.currentThread.hasPendingCancellation) {  // Check cancellation request\n            println(\"cancelled\")\n            return\n        }\n        println(\"hello\")\n    }\n    fut.cancel()    // Send cancellation request\n    syncCounter.dec()\n    fut.get() // Join thread\n}"}
