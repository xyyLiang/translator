{"text": "QUESTION:In Cangjie code language,What are lambda expressions in Cangjie?\nANSWER:Lambda expressions in Cangjie are anonymous functions that can be defined inline. They have the syntax { p1: T1, ..., pn: Tn => expressions | declarations }, where => is preceded by a list of parameters, separated by multiple parameters, and separated by : for each parameter name and parameter type. => can also be without arguments. => is followed by a lambda expression body, which is a set of expressions or a sequence of declarations. The scope of the parameter name of a lambda expression is the same as that of the function, which is the part of the function body of the lambda expression, and its scope level can be regarded as equivalent to the variable defined in the function body of the lambda expression.let f1 = { a: Int64, b: Int64 => a + b }\nvar display = { =>   // Parameterless lambda expression.\n    println(\"Hello\")\n    println(\"World\")\n}"}
{"text": "QUESTION:In Cangjie code language,What is the syntax of lambda expressions in Cangjie?\nANSWER:The syntax of a lambda expression in Cangjie is { p1: T1, ..., pn: Tn => expressions | declarations }. The => symbol separates the parameter list from the body. The parameter list can be empty, and the body can contain expressions or declarations.Lambda expressions, with or without arguments, cannot omit => unless it is used as a trailing lambda.var display = { => println(\"Hello\") }\nfunc f2(lam: () -> Unit) {}\nlet f2Res = f2 { println(\"World\") } // OK to omit the =>"}
{"text": "QUESTION:In Cangjie code language,How are parameters specified in lambda expressions in Cangjie?\nANSWER:Lambda expressions can have zero or more parameters. Parameters are specified before the => symbol, with each parameter name followed by its type, separated by a colon. Multiple parameters are separated by commas. Parameter types can be omitted if the compiler can infer them.\nThe type annotation of parameters in lambda expressions can be defaulted. In the following cases, if the parameter type is omitted, the compiler will attempt to perform type inference, and when the compiler cannot infer the type, it will compile with an error:When a lambda expression is assigned to a variable, its parameter type is inferred based on the variable type;When a lambda expression is used as an argument to a function call expression, its argument type is inferred based on the parameter type of the function.// The parameter types are inferred from the type of the variable sum1\nvar sum1: (Int64, Int64) -> Int64 = { a, b => a + b }\nvar sum2: (Int64, Int64) -> Int64 = { a: Int64, b => a + b }\nfunc f(a1: (Int64) -> Int64): Int64 {\n    a1(1)\n}\nmain(): Int64 {\n    // The parameter type of lambda is inferred from the type of function f\n    f({ a2 => a2 + 10 })\n}"}
{"text": "QUESTION:In Cangjie code language,How is type inference handled in lambda expressions in Cangjie?\nANSWER:The compiler in Cangjie can infer the types of lambda expression parameters and return types in certain contexts. If the types cannot be inferred, the compiler will report an error.\nParameter types: Can be inferred when the lambda is assigned to a variable or passed as an argument to a function.\nReturn type: Is inferred from the expressions in the lambda body or from the context where the lambda is used."}
{"text": "QUESTION:In Cangjie code language,How is the return type determined in lambda expressions in Cangjie?\nANSWER:The return type of a lambda expression in Cangjie is always inferred from the context or the expressions within the lambda body. If the return type cannot be inferred, the compiler will report an error.func f(a1: (Int64) -> Int64): Int64 {\n    a1(1)\n}\nmain(): Int64 {\n    f({ a2: Int64 => a2 + 10 })\n}"}
{"text": "QUESTION:In Cangjie code language,How are lambda expressions called immediately in Cangjie?\nANSWER:Lambda expressions in Cangjie can be called immediately after definition. This is useful for executing code blocks inline without defining a separate function.\nLambda expressions can also be assigned to a variable and called using the variable name.let r1 = { a: Int64, b: Int64 => a + b }(1, 2) // r1 = 3\nlet r2 = { => 123 }()                          // r2 = 123"}
{"text": "QUESTION:In Cangjie code language,How are lambda expressions assigned to variables in Cangjie?\nANSWER:Lambda expressions can be assigned to variables, allowing them to be stored and called later. The variable type must match the lambda expression's type.func f() {\n    var g = { x: Int64 => println(\"x = ${x}\") }\n    g(2)\n}"}
