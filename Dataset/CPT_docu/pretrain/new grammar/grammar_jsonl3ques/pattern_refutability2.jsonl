{"text": "QUESTION:In Cangjie code language,What is pattern refutability in Cangjie?\nANSWER:Patterns in Cangjie can be classified into two categories based on their refutability:\nRefutable patterns: These patterns might not match the value being matched. They are used in contexts where the match expression must cover all possible cases.\nIrrefutable patterns: These patterns always match the value being matched. They are used in contexts where the match expression does not need to cover all possible cases.\nThe refutability of patterns affects how they can be used in match expressions and other contexts."}
{"text": "QUESTION:In Cangjie code language,What are refutable patterns in Cangjie?\nANSWER:Refutable patterns are those that might not match the value being matched. They are used in match expressions where the compiler checks for exhaustiveness.\nConstant patterns: These are refutable because they match a specific value.\nType patterns: These are refutable because they check if a value is a subtype of a specified type.\nEnum patterns: These are refutable if the enum type has multiple constructors or if the pattern includes refutable sub-patterns.func constPat(x: Int64) {\n    match (x) {\n        case 1 => \"one\"\n        case 2 => \"two\"\n        case _ => \"_\"\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,What are irrefutable patterns in Cangjie?\nANSWER:Irrefutable patterns always match the value being matched. They are used in contexts where the match expression does not need to cover all possible cases.\nWildcard patterns: These always match any value.\nBinding patterns: These always match any value and bind it to a variable.\nTuple patterns: These are irrefutable if all sub-patterns are irrefutable.\nEnum patterns: These are irrefutable if the enum type has only one constructor and all sub-patterns are irrefutable.//The wildcard pattern is the irrefutable pattern. For example, in the example below, no matter what the value of x is, _ will always match it.\nfunc wildcardPat(x: Int64) {\n    match (x) {\n        case _ => \"_\"\n    }\n}\n//The binding mode is the irrefutable mode. For example, in the example below, no matter what the value of x is, binding pattern A will always match it.\nfunc wildcardPat(x: Int64) {\n    match (x) {\n        case _ => \"_\"\n    }\n}\n//A Tuple pattern is an irrefutable pattern if and only if every pattern it contains is an irrefutable pattern. \nfunc tuplePat(x: (Int64, Int64)) {\n    match (x) {\n        case (1, 2) => \"(1, 2)\"\n        case (a, 2) => \"(${a}, 2)\"\n        case (a, b) => \"(${a}, ${b})\"\n    }\n}\n//The type pattern is the refutable pattern. \ninterface I {}\nopen class Base <: I {}\nclass Derived <: Base {}\n\nfunc typePat(x: I) {\n    match (x) {\n        case a: Derived => \"Derived\"\n        case b: Base => \"Base\"\n        case _ => \"Other\"\n    }\n}\n//The enum pattern is an irrefutable pattern if and only if there is only one argumentative constructor in the corresponding enum type, and the other patterns included in the enum pattern are also irrefutable patterns.\nenum E1 {\n    A(Int64)\n}\n\nenum E2 {\n    B(Int64) | C(Int64)\n}\n\nfunc enumPat1(x: E1) {\n    match (x) {\n        case A(1) => \"A(1)\"\n        case A(a) => \"A(${a})\"\n    }\n}\n\nfunc enumPat2(x: E2) {\n    match (x) {\n        case B(b) => \"B(${b})\"\n        case C(c) => \"C(${c})\"\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,What are the rules for pattern refutability in Cangjie?\nANSWER:The refutability of patterns in Cangjie follows specific rules:\nConstant patterns: Refutable.\nWildcard patterns: Irrefutable.\nBinding patterns: Irrefutable.\nTuple patterns: Irrefutable if all sub-patterns are irrefutable.\nType patterns: Refutable.\nEnum patterns: Irrefutable if the enum type has only one constructor and all sub-patterns are irrefutable; otherwise, refutable.\nThese rules determine how patterns can be used in match expressions and other contexts."}
