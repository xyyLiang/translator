{"text": "QUESTION:In Cangjie code language,What is the basic concept of I/O streams in Cangjie?\nANSWER:In Cangjie, I/O operations refer to interactions with external entities such as keyboards, files, and networks. All I/O mechanisms in Cangjie are based on streams, which represent sequences of byte data. Streams abstract the process of reading from and writing to external data sources, providing a unified interface for various I/O operations.Stream is primarily geared towards processing raw binary data, and the smallest unit of data in Stream is a byte.\nInputStream: Represents a stream for reading data from an external source into memory. It provides a read function that writes readable data into a buffer and returns the number of bytes read.\nOutputStream: Represents a stream for writing data from memory to an external destination. It provides a write function that writes data from a buffer to the stream. Some OutputStreams have buffering strategies and require a flush operation to ensure data is written to the external destination.\nWith this layer of abstraction, the Cangjie programming language can use a unified interface to interact with external data.\nDepending on the differences in data flow responsibilities, Stream can be simply divided into two categories:\nNode streams: Directly provide data sources, and node streams are usually constructed in a way that relies on some direct external resource (such as files, networks, etc.).\nProcessing streams: Only other data streams can be proxied for processing, and processing streams are usually constructed in a way that relies on other streams."}
{"text": "QUESTION:In Cangjie code language,How to use InputStream in Cangjie?\nANSWER:The Cangjie programming language uses the InputStream interface type to represent the input stream, and it provides a read function, which will write readable data to the buffer, and the return value represents the total number of bytes read.\nThe InputStream interface defines:\ninterface InputStream {\n    func read(buffer: Array<Byte>): Int64\n}\nWhen you have an input stream, you can read bytes like the following code, and the read data is written to the read parameter group.import std.io.InputStream\nmain() {\n    let input: InputStream = ...\n    let buf = Array<Byte>(256, item: 0)\n    while (input.read(buf) > 0) {\n        println(buf)\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How to use OutputStream in Cangjie?\nANSWER:The Cangjie programming language uses the OutputStream interface type to represent the output stream, and it provides a write function that writes the data from the buffer to the bound stream.\nIn particular, there are some output streams that do not write to external memory immediately, but have a buffering strategy that only writes when the conditions are met or flush is actively called, in order to improve performance.To handle these flush operations uniformly, there is a default implementation of flush in OutputStream that helps smooth out the differences in API calls.When you have an output stream, you can write byte data.\nThe OutputStream interface defines:\ninterface OutputStream {\n    func write(buffer: Array<Byte>): Unit\n    func flush(): Unit {\n        // 空实现\n    }\n}import std.io.OutputStream\nmain() {\n    let output: OutputStream = ...\n    let buf = Array<Byte>(256, item: 111)\n    output.write(buf)\n    output.flush()\n}"}
