{"text": "QUESTION:In Cangjie code language,How to extend a type to implement an interface in Cangjie?\nANSWER:In Cangjie, a type can be extended to implement an interface even if it does not originally implement it. This is done using the extend keyword, followed by the and type the interface to be implemented. For example, the Array type can be extended to implement the PrintSizeable interface by adding a member function printSize.interface PrintSizeable {\n    func printSize(): Unit\n}\nextend<T> Array<T> <: PrintSizeable {\n    public func printSize() {\n        println(\"The size is ${this.size}\")\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How to extend a type to implement multiple interfaces in Cangjie?\nANSWER:A type can implement multiple interfaces in a single extension by separating them with &. The order of the interfaces does not matter. For example, Foo can be extended to implement I1, I2, and I3 simultaneously.interface I1 {\n    func f1(): Unit\n}\ninterface I2 {\n    func f2(): Unit\n}\ninterface I3 {\n    func f3(): Unit\n}\nclass Foo {}\nextend Foo <: I1 & I2 & I3 {\n    public func f1(): Unit {}\n    public func f2(): Unit {}\n    public func f3(): Unit {}\n}"}
{"text": "QUESTION:In Cangjie code language,How to extend a type to implement an interface conditionally in Cangjie?\nANSWER:Additional generic constraints can be declared in an interface extension to implement an interface only under specific conditions. For example, the Pair type can be extended to implement the Eq interface, allowing Pair to be used as a type that satisfies the Eq constraint.class Pair<T1, T2> {\n    var first: T1\n    var second: T2\n    public init(a: T1, b: T2) {\n        first = a\n        second = b\n    }\n}\ninterface Eq<T> {\n    func equals(other: T): Bool\n}\nextend<T1, T2> Pair<T1, T2> <: Eq<Pair<T1, T2>> where T1 <: Eq<T1>, T2 <: Eq<T2> {\n    public func equals(other: Pair<T1, T2>) {\n        first.equals(other.first) && second.equals(other.second)\n    }\n}\nclass Foo <: Eq<Foo> {\n    public func equals(other: Foo): Bool {\n        true\n    }\n}\nmain() {\n    let a = Pair(Foo(), Foo())\n    let b = Pair(Foo(), Foo())\n    println(a.equals(b)) // true\n}"}
{"text": "QUESTION:In Cangjie code language,How to extend a type to implement an interface when the type already has the required functions?\nANSWER:If a type already contains the functions or properties required by an interface, it can be extended to implement the interface without redefining those functions or properties. For example, Array already has a size function, so it can be extended to implement the Sizeable interface without adding a new function.interface Sizeable {\n    prop size: Int64\n}\n\n\nextend<T> Array<T> <: Sizeable {}\n\n\nmain() {\n    let a: Sizeable = Array<Int64>()\n    println(a.size)\n}\n//outputï¼š0"}
