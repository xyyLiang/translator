{"text": "QUESTION:In Cangjie code language,What is a trailing lambda in Cangjie?\nANSWER:A trailing lambda is a syntactic sugar that allows a lambda expression to be placed outside the parentheses of a function call, making the function call look more like a language construct. This is useful for enhancing the readability and extensibility of the language.\nWhen the last parameter of a function is of a function type and the corresponding argument is a lambda, the lambda can be placed outside the parentheses.func myIf(a: Bool, fn: () -> Int64) {\n    if(a) {\n        fn()\n    } else {\n        0\n    }\n}\nfunc test() {\n    myIf(true, { => 100 }) // General function call\n    myIf(true) {        // Trailing closure call\n        100\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,What is a pipeline expression in Cangjie?\nANSWER:A pipeline expression is a syntactic sugar that simplifies the description of a series of data processing steps. The syntax is e1 |> e2, which is equivalent to let v = e1; e2(v).\ne2 must be a function type expression, and the type of e1 must be a subtype of the parameter type of e2.func inc(x: Array<Int64>): Array<Int64> { // Increasing the value of each element in the array by '1'\n    let s = x.size\n    var i = 0\n    for (e in x where i < s) {\n        x[i] = e + 1\n        i++\n    }\n    x\n}\nfunc sum(y: Array<Int64>): Int64 { // Get the sum of elements in the array.\n    var s = 0\n    for (j in y) {\n        s += j\n    }\n    s\n}\nlet arr: Array<Int64> = Array<Int64>([1, 3, 5])\nlet res = arr |> inc |> sum // res = 12"}
{"text": "QUESTION:In Cangjie code language,What is a composition expression in Cangjie?\nANSWER:A composition expression represents the combination of two single-parameter functions. The syntax is f ~> g, which is equivalent to { x => g(f(x)) }.\nBoth f and g must be function type expressions with a single parameter. The return type of f(x) must be a subtype of the parameter type of g.//Example 1:\nfunc f(x: Int64): Float64 {\n    Float64(x)\n}\nfunc g(x: Float64): Float64 {\n    x\n}\nvar fg = f ~> g // The same as { x: Int64 => g(f(x)) }\n\n//Example 2:\n\nfunc f(x: Int64): Float64 {\n    Float64(x)\n}\nlet lambdaComp = ({x: Int64 => x}) ~> f // The same as { x: Int64 => f({x: Int64 => x}(x)) }\n\n//Example 3:\nfunc h1<T>(x: T): T { x }\nfunc h2<T>(x: T): T { x }\nvar hh = h1<Int64> ~> h2<Int64> // The same as { x: Int64 => h2<Int64>(h1<Int64>(x)) }"}
{"text": "QUESTION:In Cangjie code language,What are varargs in Cangjie?\nANSWER:Varargs are a special function call syntactic sugar that allows passing a sequence of arguments instead of an array literal when the last non-named parameter of a function is of type Array. The number of arguments can be zero or more."}
{"text": "QUESTION:In Cangjie code language,What are the restrictions of varargs in Cangjie?\nANSWER:Only the last non-named parameter can be a vararg.\nNamed parameters cannot use varargs.\nVarargs are supported in global functions, static member functions, instance member functions, local functions, constructors, function variables, lambdas, function call operator overloads, and index operator overloads.\nVarargs are not supported in other operator overloads, composition, or pipeline expressions."}
{"text": "QUESTION:In Cangjie code language,How does function overloading resolution work in Cangjie?\nANSWER:Function overloading resolution in Cangjie prioritizes functions that do not use varargs. If no matching function is found, the compiler will attempt to resolve using varargs.func f<T>(x: T) where T <: ToString {\n    println(\"item: ${x}\")\n}\nfunc f(arr: Array<Int64>) {\n    println(\"array: ${arr}\")\n}\nmain() {\n    f()\n    f(1)\n    f(1, 2)\n}\n//outputï¼š\n//array: []\n//item: 1\n//array: [1, 2]"}
