{"text": "QUESTION:In Cangjie code language,What is a mut function in Cangjie?\nANSWER:A mut function is a special instance member function that can modify the struct instance itself. The mut keyword is used to decorate such functions, indicating that they have the ability to mutate the struct instance.\nThe mut function is decorated with an additional mut keyword than the normal instance member function.struct Foo {\n    var i = 0\n    public mut func g() {\n        i += 1  // Ok\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,How are mut functions used in Cangjie?\nANSWER:mut functions can be called on mutable instances of a struct to modify their state. \nmut can only decorate instance member functions, not static member functions.\nThe this keyword within a mut function has special semantics, allowing it to modify the struct's fields in place.This in the mut function cannot be captured and cannot be used as an expression. Lambda or nested functions in mut functions can't capture instance member variables of a struct.struct A {\n    public mut func f(): Unit {} // Ok\n    public mut operator func +(rhs: A): A { // Ok\n        A()\n    }\n    public mut static func g(): Unit {} // Error, static member functions cannot be modified with 'mut'\n}\n\nError_case:\nstruct Foo {\n    var i = 0\n    public mut func f(): Foo {\n        let f1 = { => this } // Error, 'this' in mut functions cannot be captured\n        let f2 = { => this.i = 2 } // Error, instance member variables in mut functions cannot be captured\n        let f3 = { => this.i } // Error, instance member variables in mut functions cannot be captured\n        let f4 = { => i } // Error, instance member variables in mut functions cannot be captured\n        this // Error, 'this' in mut functions cannot be used as expressions\n    }\n}"}
{"text": "QUESTION:In Cangjie code language,What are the restrictions on mut functions in Cangjie?\nANSWER:mut functions can only be defined within struct, interface, or extensions of struct.\nmut functions cannot be defined within class because class is a reference type and its instance members can be modified without the mut keyword.\nmut functions cannot capture this or be used as expressions.\nLambdas or nested functions within a mut function cannot capture the struct's instance member variables.\nmut functions cannot be used on let-declared variables of struct type.\nNon-mut instance member functions (including lambdas) cannot directly access mut functions within the same type."}
{"text": "QUESTION:In Cangjie code language,How are mut functions used in interfaces in Cangjie?\nANSWER:Instance member functions in interfaces can also be decorated with the mut keyword. When a struct implements an interface, it must match the mut decoration of the interface functions. Types other than struct cannot use the mut keyword when implementing interface functions.interface I {\n    mut func f(): Unit\n}\nstruct Foo <: I {\n    public var i = 0\n    public mut func f(): Unit {\n        i += 1\n    }\n}\nmain() {\n    let a = Foo()\n    a.f() // Error, 'a' is of type struct and is declared with 'let', the 'mut' function cannot be accessed via 'a'\n    var b = Foo()\n    b.f() // Ok\n    let c: I = Foo()\n    c.f() // OK, variable c is of interface type I, not a struct type, access is allowed here.\n}"}
{"text": "QUESTION:In Cangjie code language,What escape restrictions apply to mut functions in Cangjie?\nANSWER:To prevent escape, variables of struct type cannot use mut functions as first-class citizens. They can only call these mut functions directly.Non-mut instance member functions (including lambda expressions) can't directly access mut functions of their type, and vice versa.interface I {\n    mut func f(): Unit\n}\nstruct Foo <: I {\n    var i = 0\n    public mut func f(): Unit {\n        i += 1\n    }\n}\nmain() {\n    var a = Foo()\n    var fn = a.f // Error, mut function 'f' of 'a' cannot be used as a first class citizen.\n    var b: I = Foo()\n    fn = b.f // Ok\n}\n\nError_case:\nstruct Foo {\n    var i = 0\n    public mut func f(): Unit {\n        i += 1\n        g() // Ok\n    }\n    public func g(): Unit {\n        f() // Error, mut functions cannot be invoked in non-mut functions\n    }\n}\n\ninterface I {\n    mut func f(): Unit {\n        g() // Ok\n    }\n    func g(): Unit {\n        f() // Error, mut functions cannot be invoked in non-mut functions\n    }\n}"}
