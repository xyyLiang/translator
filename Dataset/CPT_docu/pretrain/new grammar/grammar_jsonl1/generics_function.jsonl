{"text": "'Cangjie programming language_generics_function_generic_function_definition': 'In Cangjie code language, A generic function in Cangjie is a function that declares one or more type parameters. These type parameters are specified within angle brackets <...> immediately following the function name. The type parameters can be used in the function's parameter list, return type, and body.'\n\nCode_Example:\nfunc id<T>(a: T): T {\n    return a\n}"}
{"text": "'Cangjie programming language_generics_function_generic_function_global': 'In Cangjie code language, Global generic functions are defined at the top level and can be used throughout the program. They allow for flexible and reusable code by operating on different data types without sacrificing type safety.\nAnother complex example is the composition of a generic function that declares three types of form parameters, namely T1, T2, and T3, and its function is to combine two functions f: (T1) -> T2, g: (T2) -> T3 into a function of type (T1) -> T3.'\n\nCode_Example:\nfunc composition<T1, T2, T3>(f: (T1) -> T2, g: (T2) -> T3): (T1) -> T3 {\n    return {x: T1 => g(f(x))}\n}"}
{"text": "'Cangjie programming language_generics_function_generic_function_local': 'In Cangjie code language, Local generic functions are defined within other functions and can be used to encapsulate reusable logic within a specific scope. They follow the same syntax as global generic functions.'\n\nCode_Example:\nfunc foo(a: Int64) {\n    func id<T>(a: T): T { a }\n    func double(a: Int64): Int64 { a + a }\n    return (id<Int64> ~> double)(a) == (double ~> id<Int64>)(a)\n}\nmain() {\n    println(foo(1))\n    return 0\n}\n// Output:true"}
{"text": "'Cangjie programming language_generics_function_generic_function_member': 'In Cangjie code language, Member functions of class, struct, and enum can also be generic. They allow for type flexibility within the context of the containing type.\nWhen extending a type with an extend declaration, the functions in the extension can also be generic\nIt should be noted here that the generic member function declared in the class cannot be decorated by open, and an error will be reported if it is decorated by open.'\n\nCode_Example:\nclass A {\n    func foo<T>(a: T): Unit where T <: ToString {\n        println(\"${a}\")\n    }\n}\nstruct B {\n    func bar<T>(a: T): Unit where T <: ToString {\n        println(\"${a}\")\n    }\n}\nenum C {\n    | X | Y\n    func coo<T>(a: T): Unit where T <: ToString {\n        println(\"${a}\")\n    }\n}\nmain() {\n    var a = A()\n    var b = B()\n    var c = C.X\n    a.foo<Int64>(10)\n    b.bar<String>(\"abc\")\n    c.coo<Bool>(false)\n    return 0\n}\n\nError_case_code:\nclass A {\n    public open func foo<T>(a: T): Unit where T <: ToString { // Error, open generic function is not allowed\n        println(\"${a}\")\n    }\n}"}
{"text": "'Cangjie programming language_generics_function_generic_function_static': 'In Cangjie code language, Static generic functions can be defined within interface, class, struct, enum, and extend. They can be used to provide type-safe operations that do not depend on instance state.'\n\nCode_Example:\nimport std.collection.*\nclass ToPair {\n    public static func fromArray<T>(l: ArrayList<T>): (T, T) {\n        return (l[0], l[1])\n    }\n}\nmain() {\n    var res: ArrayList<Int64> = ArrayList([1,2,3,4])\n    var a: (Int64, Int64) = ToPair.fromArray<Int64>(res)\n    return 0\n}"}
{"text": "'Cangjie programming language_generics_function_generic_function_restrictions': 'In Cangjie code language, Generic member functions in classes: Cannot be open.\nGeneric functions in extensions: Can be defined to extend the functionality of existing types.'"}
