{"text": "'Cangjie programming language_function_syntactic sugar_trailing_lambda': 'In Cangjie code language, A trailing lambda is a syntactic sugar that allows a lambda expression to be placed outside the parentheses of a function call, making the function call look more like a language construct. This is useful for enhancing the readability and extensibility of the language.\nWhen the last parameter of a function is of a function type and the corresponding argument is a lambda, the lambda can be placed outside the parentheses.'\n\nCode_Example:\nfunc myIf(a: Bool, fn: () -> Int64) {\n    if(a) {\n        fn()\n    } else {\n        0\n    }\n}\nfunc test() {\n    myIf(true, { => 100 }) // General function call\n    myIf(true) {        // Trailing closure call\n        100\n    }\n}"}
{"text": "'Cangjie programming language_function_syntactic sugar_pipeline_expression': 'In Cangjie code language, A pipeline expression is a syntactic sugar that simplifies the description of a series of data processing steps. The syntax is e1 |> e2, which is equivalent to let v = e1; e2(v).\ne2 must be a function type expression, and the type of e1 must be a subtype of the parameter type of e2.'\n\nCode_Example:\nfunc inc(x: Array<Int64>): Array<Int64> { // Increasing the value of each element in the array by '1'\n    let s = x.size\n    var i = 0\n    for (e in x where i < s) {\n        x[i] = e + 1\n        i++\n    }\n    x\n}\nfunc sum(y: Array<Int64>): Int64 { // Get the sum of elements in the array.\n    var s = 0\n    for (j in y) {\n        s += j\n    }\n    s\n}\nlet arr: Array<Int64> = Array<Int64>([1, 3, 5])\nlet res = arr |> inc |> sum // res = 12"}
{"text": "'Cangjie programming language_function_syntactic sugar_composition_expression': 'In Cangjie code language, A composition expression represents the combination of two single-parameter functions. The syntax is f ~> g, which is equivalent to { x => g(f(x)) }.\nBoth f and g must be function type expressions with a single parameter. The return type of f(x) must be a subtype of the parameter type of g.'\n\nCode_Example:\n//Example 1:\nfunc f(x: Int64): Float64 {\n    Float64(x)\n}\nfunc g(x: Float64): Float64 {\n    x\n}\nvar fg = f ~> g // The same as { x: Int64 => g(f(x)) }\n\n//Example 2:\n\nfunc f(x: Int64): Float64 {\n    Float64(x)\n}\nlet lambdaComp = ({x: Int64 => x}) ~> f // The same as { x: Int64 => f({x: Int64 => x}(x)) }\n\n//Example 3:\nfunc h1<T>(x: T): T { x }\nfunc h2<T>(x: T): T { x }\nvar hh = h1<Int64> ~> h2<Int64> // The same as { x: Int64 => h2<Int64>(h1<Int64>(x)) }"}
{"text": "'Cangjie programming language_function_syntactic sugar_varargs': 'In Cangjie code language, Varargs are a special function call syntactic sugar that allows passing a sequence of arguments instead of an array literal when the last non-named parameter of a function is of type Array. The number of arguments can be zero or more.'"}
{"text": "'Cangjie programming language_function_syntactic sugar_varargs_restrictions': 'In Cangjie code language, Only the last non-named parameter can be a vararg.\nNamed parameters cannot use varargs.\nVarargs are supported in global functions, static member functions, instance member functions, local functions, constructors, function variables, lambdas, function call operator overloads, and index operator overloads.\nVarargs are not supported in other operator overloads, composition, or pipeline expressions.'"}
{"text": "'Cangjie programming language_function_syntactic sugar_function_overloading_resolution': 'In Cangjie code language, Function overloading resolution in Cangjie prioritizes functions that do not use varargs. If no matching function is found, the compiler will attempt to resolve using varargs.'\n\nCode_Example:\nfunc f<T>(x: T) where T <: ToString {\n    println(\"item: ${x}\")\n}\nfunc f(arr: Array<Int64>) {\n    println(\"array: ${arr}\")\n}\nmain() {\n    f()\n    f(1)\n    f(1, 2)\n}\n//outputï¼š\n//array: []\n//item: 1\n//array: [1, 2]"}
