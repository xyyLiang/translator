{"text": "'Cangjie programming language_package_import_import_statement': 'In Cangjie code language, In Cangjie, the import statement is used to import top-level declarations or definitions from other packages. The syntax is import fullPackageName.itemName, where fullPackageName is the full package path and itemName is the name of the declaration. The import statement must be placed after the package declaration and before other declarations or definitions in the source file.'\n\nCode_Example:\npackage a\nimport std.math.*\nimport package1.foo\nimport {package1.foo, package2.bar}"}
{"text": "'Cangjie programming language_package_import_import_multiple_items': 'In Cangjie code language, If multiple items belong to the same package, you can use the syntax import fullPackageName.{itemName1, itemName2} to import them together.'\n\nCode_Example:\nimport package1.{foo, bar, fuzz}\n// This is equivalent to:\nimport package1.foo\nimport package1.bar\nimport package1.fuzz"}
{"text": "'Cangjie programming language_package_import_import_all': 'In Cangjie code language, You can use the syntax import packageName.* to import all visible top-level declarations or definitions from a package.'\n\nCode_Example:\nimport package1.*\nimport {package1.*, package2.*}"}
{"text": "'Cangjie programming language_package_import_import_rules': 'In Cangjie code language, The scope of imported members is lower than that of members declared in the current package.\nIf the module name or package name of an exported package is altered, importing it will result in an error.\nOnly visible top-level declarations or definitions can be imported; importing invisible ones will result in an error.\nImporting declarations or definitions from the current package is prohibited.\nCircular dependencies between packages are not allowed; the compiler will report an error if they exist.'\n\nError_case_code:\n// pkga/a.cj\npackage pkga    // Error, packages pkga pkgb are in circular dependencies.\nimport pkgb.*\nclass C {}\npublic struct R {}\n\n// pkgb/b.cj\npackage pkgb\nimport pkga.*\n\n// pkgc/c1.cj\npackage pkgc\nimport pkga.C // Error, 'C' is not accessible in package 'pkga'.\nimport pkga.R // OK, R is an external top-level declaration of package pkga.\nimport pkgc.f1 // Error, package 'pkgc' should not import itself.\npublic func f1() {}\n\n// pkgc/c2.cj\npackage pkgc\nfunc f2() {\n    /* OK, the imported declaration is visible to all source files of the same package\n     * and accessing import declaration by its name is supported.\n     */\n    R()\n\n    // OK, accessing imported declaration by fully qualified name is supported.\n    pkga.R()\n\n    // OK, the declaration of current package can be accessed directly.\n    f1()\n\n    // OK, accessing declaration of current package by fully qualified name is supported.\n    pkgc.f1()\n}"}
{"text": "'Cangjie programming language_package_import_import_shadowing': 'In Cangjie code language, If an imported declaration or definition has the same name as a top-level declaration in the current package and does not constitute function overloading, the imported declaration will be shadowed.\nIf the imported declaration or definition has the same name and constitutes function overloading, the function call will be resolved according to the rules of function overloading.'\n\nCode_Example:\n// pkga/a.cj\npackage pkga\n\npublic struct R {}            // R1\npublic func f(a: Int32) {}    // f1\npublic func f(a: Bool) {} // f2\n\n// pkgb/b.cj\npackage pkgb\nimport pkga.*\n\nfunc f(a: Int32) {}         // f3\nstruct R {}                 // R2\n\nfunc bar() {\n    R()     // OK, R2 shadows R1.\n    f(1)    // OK, invoke f3 in current package.\n    f(true) // OK, invoke f2 in the imported package\n}"}
{"text": "'Cangjie programming language_package_import_implicit_core_import': 'In Cangjie code language, Types like String and Range can be used directly because the compiler implicitly imports all public declarations from the core package.'"}
{"text": "'Cangjie programming language_package_import_import_as_renaming': 'In Cangjie code language, The namespaces of different packages are separated, so there may be top-level declarations with the same name between different packages. When importing top-level declarations with the same name for different packages, you can use import packageName.name as newName to rename them to avoid conflicts. If there are no name conflicts, you can still rename the imported content by importing as. import as has the following rules:\nWhen an imported declaration is renamed using import as, the current package can only use the new name after the rename, and the original name cannot be used.\nIf there is a conflict between the renamed name and other names in the top-level scope of the current package, and the declarations corresponding to these names are all function types, the reloaded function will be participated, otherwise the weight definition will be incorrect.\nYou can rename package names in the form of import pkg as newPkgName to solve the naming conflict of packages with the same name in different modules.'\n\nCode_Example:\n// a.cj\npackage p1\npublic func f1() {}\n\n// d.cj\npackage p2\npublic func f3() {}\n\n// b.cj\npackage p1\npublic func f2() {}\n\n// c.cj\npackage pkgc\npublic func f1() {}\n\n// main.cj\nimport p1 as A\nimport p1 as B\nimport p2.f3 as f  // OK\nimport pkgc.f1 as a\nimport pkgc.f1 as b // OK\n\nfunc f(a: Int32) {}\n\nmain() {\n    A.f1()  // OK, package name conflict is resolved by renaming package name.\n    B.f2()  // OK, package name conflict is resolved by renaming package name.\n    p1.f1() // Error, the original package name cannot be used.\n    a()     // Ok.\n    b()     // Ok.\n    pkgc.f1()    // Error, the original name cannot be used.\n}"}
{"text": "'Cangjie programming language_package_import_import_reexport': 'In Cangjie code language, Imports can be modified by private, internal, protected, or public. Only imports modified by public, protected, or internal can re-export their members (if the members are not shadowed or hidden due to name conflicts). Other packages can directly import and use these re-exported members based on visibility, without needing to import from the original package.\nprivate import: The imported content is only accessible within the current file. private is the default modifier for imports.\ninternal import: The imported content is accessible within the current package and its subpackages. Non-current packages need to import explicitly.\nprotected import: The imported content is accessible within the current module. Non-current packages need to import explicitly.\npublic import: The imported content is accessible externally. Non-current packages need to import explicitly.'\n\nCode_Example:\n//In the example below, B is a subpackage of A, where the function F defined in B is reexported via public import.\n\npackage a\npublic import a.b.f\npublic let x = 0\n\ninternal package a.b\npublic func f() { 0 }\n\nimport a.f  // Ok\nlet _ = f() // Ok\n\nError_case_code:\npublic import a.b // Error, cannot re-export package"}
