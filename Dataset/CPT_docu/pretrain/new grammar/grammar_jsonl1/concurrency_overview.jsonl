{"text": "'Cangjie programming language_concurrency_overview_concurrency_overview': 'In Cangjie code language, Concurrency is an essential feature in modern programming languages. Cangjie provides a preemptive threading model for concurrency. Threads can be divided into two concepts: language threads and native threads.\nLanguage threads are the basic execution units of the concurrency model in a programming language. Cangjie aims to provide a friendly, efficient, and unified concurrency interface for developers, abstracting away differences between operating system threads and user-space threads. This is achieved through the concept of Cangjie threads. In most cases, developers only need to write concurrent code targeting Cangjie threads.\nNative threads are the threads used in the language implementation (usually operating system threads) that serve as the underlying execution carriers for language threads. Different programming languages implement language threads in various ways. For example, some languages directly create threads via operating system calls, resulting in a 1:1 threading model where each language thread corresponds to one native thread. Others implement special threading models where multiple language threads are scheduled and executed on multiple native threads, known as the M:N threading model. Cangjie currently uses the M:N threading model, where Cangjie threads are lightweight user-space threads that are preemptive and more efficient than operating system threads.\nCangjie threads are lightweight user-space threads scheduled and executed by underlying native threads. Multiple Cangjie threads can be executed by a single native thread. If a Cangjie thread blocks (e.g., waiting for a mutex), the native thread will suspend it and continue executing the next ready Cangjie thread. The blocked Cangjie thread will be rescheduled for execution by the native thread once it becomes ready again.\nIn most cases, developers only need to focus on Cangjie threads for concurrency programming without worrying about these details. However, when performing cross-language programming, developers should be cautious when calling foreign functions that may block, such as IO-related system calls. For example, in the following code, a new thread calls the foreign function socket_read. When the native thread schedules and executes this Cangjie thread, the system call will block the native thread until the function completes. During this blocking period, the native thread cannot schedule other Cangjie threads, reducing the program's throughput.\nNOTE: In this document, Cangjie threads will be referred to simply as threads when there is no ambiguity.'\n\nCode_Example:\nforeign socket_read(sock: Int64): CPointer<Int8>\n\nlet fut = spawn {\n    let sock: Int64 = ...\n    let ptr = socket_read(sock)\n}"}
