{"text": "'Cangjie programming language_extend_direct_direct_extension': 'In Cangjie code language, In Cangjie, the extend keyword is used to declare an extension. It is followed by the type being extended and the functionality added to that type. Once a function is extended to a type, such as String, instances of that type within the current package can access the function as if it were originally part of the type.'\n\nCode_Example:\nextend String {\n    public func printSize() {\n        println(\"the size is ${this.size}\")\n    }\n}"}
{"text": "'Cangjie programming language_extend_direct_generic_extension': 'In Cangjie code language, When extending generic types in Cangjie, there are two types of extension syntax:\nSpecific Generic Instance Extension: The extend keyword can be followed by a fully instantiated generic type. The added functionality is only available when the type matches exactly, and the type arguments must meet the constraints defined in the generic type.\nGeneric Parameter Extension: The extend keyword can introduce generic parameters for the extension. This allows extending uninstantiated or partially instantiated generic types. The generic parameters declared after extend must be directly or indirectly used in the extended generic type. The added functionality is only available when the type and constraints match exactly.'\n\nCode_Example:\n// Specific Generic Instance Extension\nclass Foo<T> where T <: ToString {}\nextend Foo<Int64> {} // Ok\nclass Bar {}\nextend Foo<Bar> {} // Error\n// Generic Parameter Extension\nclass MyList<T> {\n    public let data: Array<T> = Array<T>()\n}\nextend<T> MyList<T> {} // OK\nextend<R> MyList<R> {} // OK\nextend<T, R> MyList<(T, R)> {} // OK\nextend MyList {} // Error\nextend<T, R> MyList<T> {} // Error\nextend<T, R> MyList<T, R> {} // Error"}
{"text": "'Cangjie programming language_extend_direct_conditional_extension': 'In Cangjie code language, For generic type extensions, additional generic constraints can be declared within the extension to implement functions that are only available under certain conditions.\nFor example, a type called Pair can be defined to store two elements (similar to a Tuple). If the Pair type should accommodate any type, the generic parameters should not have any constraints. However, if the elements can be compared for equality, the Pair type can also implement an equals function through an extension.'\n\nCode_Example:\nclass Pair<T1, T2> {\n    var first: T1\n    var second: T2\n    public init(a: T1, b: T2) {\n        first = a\n        second = b\n    }\n}\ninterface Eq<T> {\n    func equals(other: T): Bool\n}\nextend<T1, T2> Pair<T1, T2> where T1 <: Eq<T1>, T2 <: Eq<T2> {\n    public func equals(other: Pair<T1, T2>) {\n        first.equals(other.first) && second.equals(other.second)\n    }\n}\nclass Foo <: Eq<Foo> {\n    public func equals(other: Foo): Bool {\n        true\n    }\n}\nmain() {\n    let a = Pair(Foo(), Foo())\n    let b = Pair(Foo(), Foo())\n    println(a.equals(b)) // true\n}"}
