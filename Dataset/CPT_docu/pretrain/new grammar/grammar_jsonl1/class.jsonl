{"text": "'Cangjie programming language_class_class_definition': 'In Cangjie code language, Classes in Cangjie are defined using the class keyword, followed by the class name and a body enclosed in curly braces. The class body can contain member variables, properties, static initializers, constructors, member functions, and operator functions.\n class can only be defined at the top level of the source file.'\n\nCode_Example:\nclass Rectangle {\n    let width: Int64\n    let height: Int64\n    public init(width: Int64, height: Int64) {\n        this.width = width\n        this.height = height\n    }\n    public func area() {\n        width * height\n    }\n}"}
{"text": "'Cangjie programming language_class_class_abstract': 'In Cangjie code language, Abstract classes in Cangjie are defined using the abstract keyword. They can contain abstract functions (functions without bodies) and must be inherited by subclasses. Abstract classes cannot be instantiated directly.\nAbstract functions: Must be defined in abstract classes and implemented by subclasses.\nModifiers: Abstract classes can be marked with open or sealed to control inheritance.\nAbstract functions that define private are forbidden in abstract classes;\nYou can't create instances for abstract classes;\nA non-abstract subclass of an abstract class must implement all abstract functions in the parent class.'\n\nCode_Example:\nabstract class AbRectangle {\n    public func foo(): Unit\n}"}
{"text": "'Cangjie programming language_class_class_member_variables': 'In Cangjie code language, Class member variables in Cangjie can be instance member variables or static member variables. Static member variables are marked with the static keyword and must have an initial value if no static initializer is provided.\nInstance member variables: Can be defined without initial values but must have a type annotation.\nStatic member variables: Must be accessed through the class name.'\n\nCode_Example:\n//static member variables\nclass Rectangle {\n    let width = 10\n    static let height = 20\n}\n//Instance member variables\nlet l = Rectangle.height // l = 20\nclass Rectangle {\n    let width = 10\n    let height: Int64\n    init(h: Int64){\n        height = h\n    }\n}\nlet rec = Rectangle(20)\nlet l = rec.height // l = 20"}
{"text": "'Cangjie programming language_class_class_static_initializer': 'In Cangjie code language, Static initializers in classes are defined using the static init keyword. They are used to initialize static member variables. A class can have at most one static initializer.'\n\nCode_Example:\nclass Rectangle {\n    static let degree: Int64\n    static init() {\n        degree = 180\n    }\n}\n\nError_case_code:\nclass Rectangle {\n    static let degree: Int64\n    static init() {\n        degree = 180\n    }\n    static init() { // Error, redefinition with the previous static init function\n        degree = 180\n    }\n}"}
{"text": "'Cangjie programming language_class_class_constructors': 'In Cangjie code language, Classes in Cangjie support regular constructors and primary constructors.\nRegular constructors: Defined using the init keyword. They must initialize all instance member variables.\nMain constructors: Have the same name as the class and can include both regular parameters and member variable parameters. Member variable parameters serve both as member variable definitions and constructor parameters.'\n\nCode_Example:\n// Regular constructor\nclass Rectangle {\n    let width: Int64\n    let height: Int64\n\n    public init(width: Int64) {\n        this.width = width\n        this.height = width\n    }\n\n    public init(width: Int64, height: Int64) { // Ok: overloading with the first init function\n        this.width = width\n        this.height = height\n    }\n}\n// Main constructors\nclass Rectangle {\n    public Rectangle(let width: Int64, let height: Int64) {}\n}"}
{"text": "'Cangjie programming language_class_class_destructor': 'In Cangjie code language, Classes in Cangjie can define a destructor, which is a function named ~init that is called when an instance of the class is garbage collected. Destructors are used to release system resources.\nDestructors: Must not have parameters, return types, or generic type parameters.\nRestrictions: Classes with destructors cannot be open, and destructors cannot be defined in extensions.'\n\nCode_Example:\nclass C {\n    var p: CString\n    init(s: String) {\n        p = unsafe { LibC.mallocCString(s) }\n        println(s)\n    }\n    ~init() {\n        unsafe { LibC.free(p) }\n    }\n}"}
{"text": "'Cangjie programming language_class_class_destructor_limitations': 'In Cangjie code language, Destructor have no parameters, no return types, no generic type parameters, no modifiers, and can't be called explicitly.\nClasses with destructor cannot be decorated by open, and only non-open classes can have destructor.\n A class can define a maximum of one destructor \nDestructor cannot be defined in extensions.\n The timing of the destructor being triggered is uncertain.\nThe destructor may execute on any one thread.\n  The order in which multiple destructor are executed is indeterminate.\nDestructor throwing out uncaught exceptions is undefined behavior.\nCreating threads in a destructor or using the thread synchronization feature is an undefined behavior.\nIf the object can continue to be accessed after the destructor is executed, it is an undefined behavior.\nIf an object throws an exception during initialization, the destructor of the incompletely initialized object will not be executed.'"}
{"text": "'Cangjie programming language_class_class_member_functions': 'In Cangjie code language, Class member functions in Cangjie can be instance member functions or static member functions. Instance member functions can access instance member variables, while static member functions can only access static member variables.\nInstance member functions: Can be abstract or non-abstract. Abstract functions must be implemented by subclasses.\nStatic member functions: Must be accessed through the class name.'\n\nCode_Example:\nclass Rectangle {\n    let width: Int64 = 10\n    let height: Int64 = 20\n    public func area() {\n        this.width * this.height\n    }\n    public static func typeName(): String {\n        \"Rectangle\"\n    }\n}"}
{"text": "'Cangjie programming language_class_class_instance_abstract': 'In Cangjie code language, Depending on whether there is a function body or not, instance member functions can be divided into abstract member functions and non-abstract member functions. Abstract member functions do not have a function body, but can only be defined in abstract classes or interfaces (see the Interfaces section for details). It is important to note that abstract instance member functions have open semantics by default, and the open modifier is optional and must be decorated with public or protected.\nA non-abstract function must have a function body, in which the instance member variables can be accessed via this.'\n\nCode_Example:\nclass Rectangle {\n    let width: Int64 = 10\n    let height: Int64 = 20\n    public func area() {\n        this.width * this.height\n    }\n}"}
{"text": "'Cangjie programming language_class_class_access_modifiers': 'In Cangjie code language, Class members (including member variables, properties, constructors, and member functions) can be modified with four access modifiers: private, internal, protected, and public. The default access modifier is internal.\nprivate: Visible only within the class definition.\ninternal: Visible only within the current package and subpackages.\nprotected: Visible only within the current module and subclasses.\npublic: Visible both within and outside the module.'\n\nCode_Example:\npackage a\npublic open class Rectangle {\n    public var width: Int64\n    protected var height: Int64\n    private var area: Int64\n    public init(width: Int64, height: Int64) {\n        this.width = width\n        this.height = height\n        this.area = this.width * this.height\n    }\n    init(width: Int64, height: Int64, multiple: Int64) {\n        this.width = width\n        this.height = height\n        this.area = width * height * multiple\n    }\n}\nfunc samePkgFunc() {\n    var r = Rectangle(10, 20) // Ok: constructor 'Rectangle' can be accessed here\n    r.width = 8               // Ok: public 'width' can be accessed here\n    r.height = 24             // Ok: protected 'height' can be accessed here\n    r.area = 30               // Error, private 'area' cannot be accessed here\n}\n\npackage b\nimport a.*\npublic class Cuboid <: Rectangle {\n    private var length: Int64\n    public init(width: Int64, height: Int64, length: Int64) {\n        super(width, height)\n        this.length = length\n    }\n    public func volume() {\n        this.width * this.height * this.length // Ok: protected 'height' can be accessed here\n    }\n}\nmain() {\n    var r = Rectangle(10, 20, 2) // Error, Rectangle has no `public` constructor with three parameters\n    var c = Cuboid(20, 20, 20)\n    c.width = 8               // Ok: public 'width' can be accessed here\n    c.height = 24             // Error, protected 'height' cannot be accessed here\n    c.area = 30               // Error, private 'area' cannot be accessed here\n}"}
{"text": "'Cangjie programming language_class_class_this_type': 'In Cangjie code language, The This type in Cangjie is a placeholder for the current class type. It can only be used as the return type of instance member functions. When a subclass object calls a function defined in a superclass that returns This, the return type is recognized as the subclass type.'\n\nCode_Example:\nopen class C1 {\n    func f(): This {  // its type is `() -> C1`\n        return this\n    }\n    func f2() { // its type is `() -> C1`\n        return this\n    }\n    public open func f3(): C1 {\n        return this\n    }\n}\nclass C2 <: C1 {\n    // member function f is inherited from C1, and its type is `() -> C2` now\n    public override func f3(): This { // Ok\n        return this\n    }\n}\nvar obj1: C2 = C2()\nvar obj2: C1 = C2()\nvar x = obj1.f()    // During compilation, the type of x is C2\nvar y = obj2.f()    // During compilation, the type of y is C1"}
{"text": "'Cangjie programming language_class_class_object_creation': 'In Cangjie code language, Class objects in Cangjie are created by calling the class constructor. Unlike structs, class instances are reference types, meaning multiple variables can point to the same object.\nOnce an object is created, it is possible to access (public-decorated) instance member variables and instance member functions through the object. \nIf you want to modify the value of a member variable through an object (which is discouraged, it is better to change it through a member function), you need to define the member variable in the class type as a soft member variable (i.e. use var definition). \nDifferent from struct, when an object is assigned or passed parameters, the object is not copied, multiple variables point to the same object, and if you modify the value of a member in the object through one variable, the corresponding member variables in other variables will also be modified.'\n\nCode_Example:\nlet r = Rectangle(10, 20) // r.width = 10, r.height = 20\nlet width = r.width       // width = 10\nlet height = r.height     // height = 20\nlet a = r.area()          // a = 200\n\n//modify the value of a member variable through an object\nclass Rectangle {\n    public var width: Int64\n    public var height: Int64\n    ...\n}\nmain() {\n    let r = Rectangle(10, 20) // r.width = 10, r.height = 20\n    r.width = 8               // r.width = 8\n    r.height = 24             // r.height = 24\n    let a = r.area()          // a = 192\n}\n\n//an object is assigned or passed parameters\nmain() {\n    var r1 = Rectangle(10, 20) // r1.width = 10, r1.height = 20\n    var r2 = r1                // r2.width = 10, r2.height = 20\n    r1.width = 8               // r1.width = 8\n    r1.height = 24             // r1.height = 24\n    let a1 = r1.area()         // a1 = 192\n    let a2 = r2.area()         // a2 = 192\n}"}
{"text": "'Cangjie programming language_class_class_inheritance': 'In Cangjie code language, Like most programming languages that support classes, classes in Cangjie also support inheritance. If class B inherits class A, then A is said to be the parent class and B is the child class. The child class inherits all members of the parent class except for the private member and the constructor.\nAbstract classes are always inheritable, so the open modifier is optional when defining an abstract class, or you can use the sealed modifier to modify the abstract class, indicating that the abstract class can only be inherited in this package. However, the inheritance of non-abstract classes is conditional: they must be defined with the open modifier. When an instance member with an open modifier is inherited by class, the open modifier is also inherited. The compiler alerts you when there are open-modified members in a class that is not open-modified.\nYou can specify the parent class that it inherits with <: at the child class definition, but the parent class must be inheritable. \nclass only supports single inheritance, so it is not legal for a class like the following to inherit the code of two classes (& is the syntax for classes implementing multiple interfaces).Because classes are single-inherited, any class can have at most one direct parent. For a class with a parent class specified at definition, its immediate parent is the class specified at definition, and for a class that is not specified at definition, its immediate parent is of type Object. Object is the parent of all classes (note that Object has no direct parent, and there are no members in the Object).Because the child class inherits from the parent class, the objects of the child class can naturally be used as objects of the parent class, but not vice versa.\n The type defined by class does not allow inheritance of the type itself.'\n\nCode_Example:\nopen class A {\n    let a: Int64 = 10\n}\n\nclass B <: A { // Ok: 'B' Inheritance 'A'\n    let b: Int64 = 20\n}\n\nError_case_code:\nopen class A {\n    let a: Int64 = 10\n}\nclass B <: A { // Ok: 'B' Inheritance 'A'\n    let b: Int64 = 20\n}\nclass C <: B { // Error, 'B' is not inheritable\n    let c: Int64 = 30\n}\n\n//it is not legal for a class inherit the code of two classes\nopen class A {\n    let a: Int64 = 10\n}\nopen class B {\n    let b: Int64 = 20\n}\nclass C <: A & B { // Error, 'C' can only inherit one class\n    let c: Int64 = 30\n}\n\n\n//an object of type A cannot be assigned to a variable of type B\nopen class A {\n    let a: Int64 = 10\n}\nclass B <: A {\n    let b: Int64 = 20\n}\nlet a: A = B() // Ok: subclass objects can be assigned to superclass variables\nlet b: B = A() // Error, superclass objects can not be assigned to subclass variables\n\n\n// The type defined by class does not allow inheritance of the type itself.\nclass A <: A {}  // Error, 'A' inherits itself."}
{"text": "'Cangjie programming language_class_abstract _class_inheritance': 'In Cangjie code language, Abstract classes can use the sealed modifier, which means that the modified class definition can only be inherited by other classes within the package in which the definition is located. Sealed already has public/open semantics, so if the public/open modifier is provided when defining a sealed abstract class, the compiler will alert. A subclass of sealed can be not a sealed class, can still be decorated with open/sealed, or does not use any inherited modifiers. If a subclass of the sealed class is decorated with open, its subclass can be inherited outside the package. Sealed can be undecorated by public.'\n\nCode_Example:\npackage A\npublic sealed abstract class C1 {}   // Warning, redundant modifier, 'sealed' implies 'public'\nsealed open abstract class C2 {}     // Warning, redundant modifier, 'sealed' implies 'open'\nsealed abstract class C3 {}          // OK, 'public' is optional when 'sealed' is used\nclass S1 <: C1 {}  // OK\npublic open class S2 <: C1 {}   // OK\npublic sealed abstract class S3 <: C1 {}  // OK\nopen class S4 <: C1 {}   // OK\n\npackage B\nimport A.*\nclass SS1 <: S2 {}  // OK\nclass SS2 <: S3 {}  // Error, S3 is sealed class, cannot be inherited here.\nsealed class SS3 {} // Error, 'sealed' cannot be used on non-abstract class."}
{"text": "'Cangjie programming language_class_class_parent_constructor_call': 'In Cangjie code language, The init constructor of a child class can call the parent class constructor in the form super(args), or the other constructors of the class in the form this(args), but only one in between. If called, it must be at the first expression in the constructor body, and there must not be any expressions or declarations before that.\nIn the main constructor of a subclass, you can call the parent constructor in the form super(args), but you cannot call other constructors in the class in the form this(args).\nIf the constructor of a child class does not explicitly call the parent class constructor, nor does it explicitly call other constructors, the compiler inserts a call to the argumentless constructor of the immediate parent class at the beginning of the constructor body. If the parent class does not have a parameterless constructor, a compilation error will be reported.'\n\nCode_Example:\nopen class A {\n    A(let a: Int64) {}\n}\nclass B <: A {\n    let b: Int64\n    init(b: Int64) {\n        super(30)\n        this.b = b\n    }\n    init() {\n        this(20)\n    }\n}\n\nError_case_code:\nopen class A {\n    let a: Int64\n    init() {\n        a = 100\n    }\n}\nopen class B <: A {\n    let b: Int64\n    init(b: Int64) {\n        // OK, `super()` added by compiler\n        this.b = b\n    }\n}\nopen class C <: B {\n    let c: Int64\n    init(c: Int64) {  // Error, there is no non-parameter constructor in super class\n        this.c = c\n    }\n}"}
{"text": "'Cangjie programming language_class_class_override_and_redefine': 'In Cangjie code language, Override: Subclasses can override non-abstract instance member functions of the parent class using the override keyword.\nRedefine: Subclasses can redefine non-abstract static member functions of the parent class using the redef keyword.\nFor overridden functions, the version of the call (so-called dynamic distribution) is determined at the time of call based on the runtime type of the variable (which is determined by the object that is actually assigned to the variable). \nFor static functions, you can redefine a non-abstract static function of the same name in the parent class in the subclass, that is, define a new implementation for a static function in the parent class in the subclass. When redefined, a static function of the same name in a subclass is required to be decorated with redef, where redef is optional.\nFor functions to be redefined, the version to be called will be determined based on the type of class. \nIf an abstract function or an open-decorated function has named parameters, then the function that implements the function or override decorated needs to keep the same named parameters.'\n\nCode_Example:\n//the function f in subclass B overrides the function f in parent class A\nopen class A {\n    public open func f(): Unit {\n        println(\"I am superclass\")\n    }\n}\nclass B <: A {\n    public override func f(): Unit {\n        println(\"I am subclass\")\n    }\n}\nmain() {\n    let a: A = A()\n    let b: A = B()\n    a.f()\n    b.f()\n}\n\n//static functions\nopen class C {\n    public static func foo(): Unit {\n        println(\"I am class C\")\n    }\n}\nclass D <: C {\n    public redef static func foo(): Unit {\n        println(\"I am class D\")\n    }\n}\nmain() {\n    C.foo()\n    D.foo()\n}\n\n//abstract function or an open-decorated function has named parameters\nopen class A {\n    public open func f(a!: Int32): Int32 {\n        a + 1\n    }\n}\nclass B <: A {\n    public override func f(a!: Int32): Int32 { // Ok\n        a + 2\n    }\n}\nclass C <: A {\n    public override func f(b!: Int32): Int32 { // Error\n        b + 3\n    }\n}\nmain() {\n    B().f(a: 0)\n    C().f(b: 0)\n}"}
