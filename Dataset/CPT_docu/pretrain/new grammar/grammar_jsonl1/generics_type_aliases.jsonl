{"text": "'Cangjie programming language_generics_type_aliases_typealias_definition': 'In Cangjie code language, Type aliases in Cangjie are defined using the type keyword, followed by the alias name, an equals sign =, and the original type. Type aliases can only be defined at the top level of a source file, and the original type must be visible at the point of alias definition.'\n\nCode_Example:\ntype I64 = Int64"}
{"text": "'Cangjie programming language_generics_type_aliases_typealias_restrictions': 'In Cangjie code language, Type aliases must be defined at the top level of a source file.\nThe original type must be visible at the point of alias definition.\nType aliases cannot be defined within functions or other scopes.\nType aliases cannot be used in type conversion expressions.'\n\nError_case_code:\n//Type aliases can only be defined at the top level of the source file, and the original type must be visible at the alias definition. \nmain() {\n    type I64 = Int64 // Error, type aliases can only be defined at the top level of the source file\n}\nclass LongNameClassA { }\ntype B = LongNameClassB // Error, type 'LongNameClassB' is not defined\n//Circular references (direct or indirect) are prohibited in one (or more) type alias definitions.\ntype A = (Int64, A) // Error, 'A' refered itself\ntype B = (Int64, C) // Error, 'B' and 'C' are circularly refered\ntype C = (B, Int64)"}
{"text": "'Cangjie programming language_generics_type_aliases_typealias_usage': 'In Cangjie code language, Type aliases can be used in the following scenarios:\nAs a type.\nAs a constructor name when the original type is a class or struct.\nTo access static members of a class, interface, or struct.\nAs the type name for enum constructors when the original type is an enum.\nIt should be noted that the current user-defined type alias cannot be used in type conversion expressions.'\n\nCode_Example:\n//Used as a type\ntype A = B\nclass B {}\nvar a: A = B() // Use type alias A as type B\n\n//Used as constructor\ntype A = B\nclass B {}\nfunc foo() { A() }  // Use type alias A as constructor of B\n\n//Use A to access static method\ntype A = B\nclass B {\n    static var b : Int32 = 0;\n    static func foo() {}\n}\nfunc foo() {\n    A.foo() // Use A to access static method in class B\n    A.b\n}\n\n//As an enum constructor type name\nenum TimeUnit {\n    Day | Month | Year\n}\ntype Time = TimeUnit\nvar a = Time.Day  \nvar b = Time.Month   // Use type alias Time to access constructors in TimeUnit\n\nError_case_code:\ntype MyInt = Int32\nMyInt(0)  // Error, no matching function for operator '()' function call"}
{"text": "'Cangjie programming language_generics_type_aliases_typealias_generic': 'In Cangjie code language, Type aliases can also declare type parameters, but they cannot use where to declare constraints on their parameters, and the constraints on generic variables will be explained later.\nWhen the name of a generic type is too long, you can use a type alias to declare a shorter alias for it.'\n\nCode_Example:\nstruct RecordData<T> {\n    var a: T\n    public init(x: T){\n        a = x\n    }\n}\ntype RD<T> = RecordData<T>\nmain(): Int64 {\n    var struct1: RD<Int32> = RecordData<Int32>(2)\n    return 1\n}"}
