{"text": "'Cangjie programming language_generics_subtype_generic_subtype_relationship': 'In Cangjie code language, In Cangjie, instantiated generic types can have subtype relationships. These relationships are determined by the type parameters and the type constructors.'\n\nCode_Example:\ninterface I<X, Y> { }\nclass C<Z> <: I<Z, Z> { }\n//In this example, C<Bool> is a subtype of I<Bool, Bool>, and C<D> is a subtype of I<D, D>."}
{"text": "'Cangjie programming language_generics_subtype_generic_subtype_morph': 'In Cangjie code language, According to class C<Z> <: I<Z, Z> { }, C<Bool> <: I<Bool, Bool> and C<D> <: I<D, D> etc. It can be interpreted as \"For all Z types (without type variables), there is C<Z> <: I<Z, Z> true\".\nI<D> <: I<C> is not true (even if D <: C is true) because in the Cangjie language, the user-defined type constructor is not deformed at its type parameters.\nA morph is defined as if A and B are (instantiated) types, T is a type constructor, and has a type parameter X (e.g. interface T<X>).\nIf T(A) <: T(B) is indeformed if and only if A = B.\nIf T(A) <: T(B) if and only if A <: B then T is covariant at X.\nIf T(A) <: T(B) is and only if B <: A then T is inverted at X.\nBecause in the current Cangjie, all user-defined generic types are unchanged at all their type variants, so given interface I<X> and types A and B, only A = B can get I<A> <<B>: I; Conversely, if you know I<A> <: I<B>, you can also deduce A = B (except for built-in types: built-in tuple types are covariant for each of their element types; The built-in function type is inverted at its input parameter type and covariant at its return type. ï¼‰'"}
