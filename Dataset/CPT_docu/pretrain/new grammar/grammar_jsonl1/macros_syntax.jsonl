{"text": "'Cangjie programming language_macros_syntax_syntax_node_overview': 'In Cangjie code language, In the Cangjie language, the compilation process first converts code into Tokens through lexical analysis, and then parses the Tokens into a syntax tree. Each node in the syntax tree represents an expression, declaration, type, pattern, etc. The Cangjie standard library std.ast package provides classes corresponding to each type of node, with appropriate inheritance relationships. The main abstract classes include:\nNode: The parent class of all syntax nodes.\nTypeNode: The parent class of all type nodes.\nExpr: The parent class of all expression nodes.\nDecl: The parent class of all declaration nodes.\nPattern: The parent class of all pattern nodes.'"}
{"text": "'Cangjie programming language_macros_syntax_parsing_tokens_to_nodes': 'In Cangjie code language, There are two main methods to parse Tokens into syntax nodes in Cangjie:\nUsing parsing functions: Functions like parseExpr and parseDecl can parse Tokens into expressions or declarations.\nUsing node constructors: Most syntax nodes support an init(input: Tokens) constructor to parse Tokens directly into specific node types.'\n\nCode_Example:\nlet tks1 = quote(a + b)\nlet tks2 = quote(u + v, x + y)\nlet tks3 = quote(\n    func f1(x: Int64) { return x + 1 }\n)\nlet tks4 = quote(\n    func f2(x: Int64) { return x + 2 }\n    func f3(x: Int64) { return x + 3 }\n)\n\nlet binExpr1 = parseExpr(tks1)\nlet (binExpr2, mid) = parseExprFragment(tks2)\nlet (binExpr3, _) = parseExprFragment(tks2, startFrom: mid + 1) // 跳过逗号\nprintln(\"binExpr1 = ${binExpr1.toTokens()}\")\nprintln(\"binExpr2 = ${binExpr2.toTokens()}, binExpr3 = ${binExpr3.toTokens()}\")\nlet funcDecl1 = parseDecl(tks3)\nlet (funcDecl2, mid2) = parseDeclFragment(tks4)\nlet (funcDecl3, _) = parseDeclFragment(tks4, startFrom: mid2)\nprintln(\"${funcDecl1.toTokens()}\")\nprintln(\"${funcDecl2.toTokens()}\")\nprintln(\"${funcDecl3.toTokens()}\")"}
{"text": "'Cangjie programming language_macros_syntax_node_components': 'In Cangjie code language, Syntax nodes in Cangjie have various components that can be accessed and modified. For example:\nBinaryExpr nodes have leftExpr, op, and rightExpr components.\nFuncDecl nodes have identifier, funcParams, declType, and block components.\nEach component is a public mut prop and can be viewed or updated.'\n\nCode_Example:\n//BinaryExpr \nlet binExpr = BinaryExpr(quote(x * y))\nbinExpr.leftExpr = BinaryExpr(quote(a + b))\nprintln(binExpr.toTokens())\nbinExpr.op = Token(TokenKind.ADD)\nprintln(binExpr.toTokens())\n\n//FuncDecl \nlet funcDecl = FuncDecl(quote(func f1(x: Int64) { x + 1 }))\nfuncDecl.identifier = Token(TokenKind.IDENTIFIER, \"foo\")\nprintln(\"Number of parameters: ${funcDecl.funcParams.size}\")\nfuncDecl.funcParams[0].identifier = Token(TokenKind.IDENTIFIER, \"a\")\nprintln(\"Number of nodes in body: ${funcDecl.block.nodes.size}\")\nlet binExpr = (funcDecl.block.nodes[0] as BinaryExpr).getOrThrow()\nbinExpr.leftExpr = parseExpr(quote(a))\nprintln(funcDecl.toTokens())"}
{"text": "'Cangjie programming language_macros_syntax_quote_interpolation_of_nodes': 'In Cangjie code language, Any syntax node can be interpolated in a quote expression in Cangjie. For example, you can interpolate a BinaryExpr node or a list of nodes (ArrayList). Interpolation is done using $(node). When interpolating complex expressions, it is recommended to use parentheses to ensure correct scope.'\n\nCode_Example:\nvar binExpr = BinaryExpr(quote(1 + 2))\nlet a = quote($(binExpr))\nlet b = quote($binExpr)\nlet c = quote($(binExpr.leftExpr))\nlet d = quote($binExpr.leftExpr)\nprintln(\"a: ${a.toTokens()}\")\nprintln(\"b: ${b.toTokens()}\")\nprintln(\"c: ${c.toTokens()}\")\nprintln(\"d: ${d.toTokens()}\")"}
{"text": "'Cangjie programming language_macros_syntax_updating_syntax_tree': 'In Cangjie code language, You can update the syntax tree by modifying the components of syntax nodes. For example, you can replace parts of an expression or change function declarations. The std.ast library provides methods to update nodes and reflect these changes in the syntax tree.'"}
