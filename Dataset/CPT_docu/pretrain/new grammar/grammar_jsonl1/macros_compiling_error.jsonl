{"text": "'Cangjie programming language_macros_compiling_error_macro_compilation_and_usage': 'In Cangjie code language, Macro definitions and calls cannot be in the same package. The macro package must be compiled first, followed by the package that uses the macro. The macro definition must be public to be exported and used by another package.\nThe source directory structure should separate macro definitions and macro calls into different subdirectories. If the macro definition and macro call files are not in the same directory, the --import-path option must be used to specify the path to the macro definition's compiled output.'\n\nCode_Example:\n# Linux platform\n#First, compile the macro definition file to generate the default dynamic library file in the specified directory (allowing the path of the dynamic library to be specified, but not the name of the dynamic library).\ncjc macros/m.cj --compile-macro --output-dir ./target\n#Compile files that use macros. Once the macro replacement is completed, an executable file is generated\ncjc src/demo.cj -o demo --import-path ./target --output-dir ./target\n# Run the executable file\n./target/demo\n\n# Windows platform\n# Current directory: src\nFirst, compile the macro definition file to generate the default dynamic library file in the specified directory (allowing the path of the dynamic library to be specified, but not the name of the dynamic library).\ncjc macros/m.cj --compile-macro --output-dir ./target\nCompile files that use macros. Once the macro replacement is completed, an executable file is generated\ncjc src/demo.cj -o demo.exe --import-path ./target --output-dir ./target"}
{"text": "'Cangjie programming language_macros_compiling_error_parallel_macro_expansion': 'In Cangjie code language, Parallel macro expansion can be enabled by adding the --parallel-macro-expansion option during compilation. The compiler will automatically analyze dependencies between macro calls and execute independent macro calls in parallel, reducing overall compilation time.\nHowever, using parallel macro expansion can be risky if the macro functions depend on global variables.'\n\nCode_Example:\nmacro package define\nimport std.ast.*\nimport std.collection.*\n\nvar Counts = HashMap<String, Int64>()\n\npublic macro Inner(input: Tokens) {\n    for (t in input) {\n        if (t.value.size == 0) {\n            continue\n        }\n        // Count the occurrence times of all valid token values\n        if (!Counts.contains(t.value)) {\n            Counts[t.value] = 0\n        }\n        Counts[t.value] = Counts[t.value] + 1\n    }\n    return input\n}\npublic macro B(input: Tokens) {\n    return input\n}"}
{"text": "'Cangjie programming language_macros_compiling_error_diagreport_error_reporting': 'In Cangjie code language, The diagReport function in the std.ast package allows custom error reporting for macro definitions. It provides the same output format as the native compiler and supports warning and error messages.\nThe function prototype is:public func diagReport(level: DiagReportLevel, tokens: Tokens, message: String, hint: String): Unit\nParameters:\nlevel: The severity level of the message (e.g., \"warning\", \"error\").\ntokens: The Tokens related to the error message.\nmessage: The main error message.\nhint: Additional hint information.'\n\nCode_Example:\n// macro_definition.cj\nmacro package macro_definition\nimport std.ast.*\npublic macro testDef(input: Tokens): Tokens {\n    for (i in 0..input.size) {\n        if (input[i].kind == IDENTIFIER) {\n            diagReport(DiagReportLevel.ERROR, input[i..(i + 1)],\n                       \"This expression is not allowed to contain identifier\",\n                       \"Here is the illegal identifier\")\n        }\n    }\n    return input\n}\n\n// macro_call.cj\npackage macro_calling\nimport std.ast.*\nimport macro_definition.*\nmain(): Int64 {\n    let a = @testDef(1)\n    let b = @testDef(a)\n    let c = @testDef(1 + a)\n    return 0\n}\n\n//During the compilation of macro call files, the following error message may appear:\nerror: This expression is not allowed to contain identifier\n ==> call.cj:9:22:\n  |\n9 |     let b = @testDef(a)\n  |                      ^ Here is the illegal identifier\n  |\n\nerror: This expression is not allowed to contain identifier\n  ==> call.cj:10:26:\n   |\n10 |     let c = @testDef(1 + a)\n   |                          ^ Here is the illegal identifier\n   |\n\n2 errors generated, 2 errors printed."}
{"text": "'Cangjie programming language_macros_compiling_error_debug_macro_mode': 'In Cangjie code language, The --debug-macro option can be used to generate debug files that show the expanded macro code. This helps developers identify issues in macro-generated code. The debug mode generates a temporary file with the expanded macro code.\nNote: Debug mode may not work correctly in certain edge cases involving line breaks or nested macros.'\n\nCode_Example:\n# Compilation command with debug mode\ncjc --debug-macro src/macro_call.cj -o src/macro_call.cjo"}
