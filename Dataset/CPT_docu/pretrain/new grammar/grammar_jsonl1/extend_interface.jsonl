{"text": "'Cangjie programming language_extend_interface_interface_extension': 'In Cangjie code language, In Cangjie, a type can be extended to implement an interface even if it does not originally implement it. This is done using the extend keyword, followed by the and type the interface to be implemented. For example, the Array type can be extended to implement the PrintSizeable interface by adding a member function printSize.'\n\nCode_Example:\ninterface PrintSizeable {\n    func printSize(): Unit\n}\nextend<T> Array<T> <: PrintSizeable {\n    public func printSize() {\n        println(\"The size is ${this.size}\")\n    }\n}"}
{"text": "'Cangjie programming language_extend_interface_multiple_interface_extension': 'In Cangjie code language, A type can implement multiple interfaces in a single extension by separating them with &. The order of the interfaces does not matter. For example, Foo can be extended to implement I1, I2, and I3 simultaneously.'\n\nCode_Example:\ninterface I1 {\n    func f1(): Unit\n}\ninterface I2 {\n    func f2(): Unit\n}\ninterface I3 {\n    func f3(): Unit\n}\nclass Foo {}\nextend Foo <: I1 & I2 & I3 {\n    public func f1(): Unit {}\n    public func f2(): Unit {}\n    public func f3(): Unit {}\n}"}
{"text": "'Cangjie programming language_extend_interface_conditional_interface_extension': 'In Cangjie code language, Additional generic constraints can be declared in an interface extension to implement an interface only under specific conditions. For example, the Pair type can be extended to implement the Eq interface, allowing Pair to be used as a type that satisfies the Eq constraint.'\n\nCode_Example:\nclass Pair<T1, T2> {\n    var first: T1\n    var second: T2\n    public init(a: T1, b: T2) {\n        first = a\n        second = b\n    }\n}\ninterface Eq<T> {\n    func equals(other: T): Bool\n}\nextend<T1, T2> Pair<T1, T2> <: Eq<Pair<T1, T2>> where T1 <: Eq<T1>, T2 <: Eq<T2> {\n    public func equals(other: Pair<T1, T2>) {\n        first.equals(other.first) && second.equals(other.second)\n    }\n}\nclass Foo <: Eq<Foo> {\n    public func equals(other: Foo): Bool {\n        true\n    }\n}\nmain() {\n    let a = Pair(Foo(), Foo())\n    let b = Pair(Foo(), Foo())\n    println(a.equals(b)) // true\n}"}
{"text": "'Cangjie programming language_extend_interface_existing_function_extension': 'In Cangjie code language, If a type already contains the functions or properties required by an interface, it can be extended to implement the interface without redefining those functions or properties. For example, Array already has a size function, so it can be extended to implement the Sizeable interface without adding a new function.'\n\nCode_Example:\ninterface Sizeable {\n    prop size: Int64\n}\n\n\nextend<T> Array<T> <: Sizeable {}\n\n\nmain() {\n    let a: Sizeable = Array<Int64>()\n    println(a.size)\n}\n//outputï¼š0"}
