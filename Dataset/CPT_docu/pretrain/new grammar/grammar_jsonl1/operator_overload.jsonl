{"text": "'Cangjie programming language_operator_overload_operator_overloading_definition': 'In Cangjie code language, Operator overloading in Cangjie allows you to define custom behavior for operators on user-defined types. This is achieved by defining functions with the operator keyword. When an operator is used on an instance of the type, the corresponding operator function is called automatically.'\n\nCode_Example:\nopen class Point {\n    var x: Int64 = 0\n    var y: Int64 = 0\n    public init (a: Int64, b: Int64) {\n        x = a\n        y = b\n    }\n    public operator func -(): Point {\n        Point(-x, -y)\n    }\n    public operator func +(right: Point): Point {\n        Point(this.x + right.x, this.y + right.y)\n    }\n}"}
{"text": "'Cangjie programming language_operator_overload_operator_overloading_usage': 'In Cangjie code language, Once an operator is overloaded for a type, you can use the operator directly on instances of that type. The corresponding operator function will be called automatically.'\n\nCode_Example:\nmain() {\n    let p1 = Point(8, 24)\n    let p2 = -p1      // p2 = Point(-8, -24)\n    let p3 = p1 + p2  // p3 = Point(0, 0)\n}"}
{"text": "'Cangjie programming language_operator_overload_operator_overloading_rules': 'In Cangjie code language, Operator functions must be defined with the operator keyword.\nThe number of parameters in the operator function must match the requirements of the operator.\nOperator functions can only be defined within class, interface, struct, enum, or extend.\nOperator functions have instance member semantics and cannot be static.\nOperator functions cannot be generic.'\n\nCode_Example:\nopen class Point {\n    var x: Int64 = 0\n    var y: Int64 = 0\n    public init (a: Int64, b: Int64) {\n        x = a\n        y = b\n    }\n    public operator func -(): Point {\n        Point(-x, -y)\n    }\n    public operator func +(right: Point): Point {\n        Point(this.x + right.x, this.y + right.y)\n    }\n}"}
{"text": "'Cangjie programming language_operator_overload_operator_overloading_indexing': 'In Cangjie code language, The indexing operator [] can be overloaded for both getting and setting values. The get form does not require a value parameter, while the set form requires a value parameter.'\n\nCode_Example:\nclass A {\n    operator func [](arg1: Int64, arg2: String): Int64 {\n        return 0\n    }\n}\nfunc f() {\n    let a = A()\n    let b: Int64 = a[1, \"2\"]\n    // b == 0\n}"}
{"text": "'Cangjie programming language_operator_overload_operator_overloading_call': 'In Cangjie code language, The function call operator () can be overloaded to allow instances of a type to be called like functions.'\n\nCode_Example:\nopen class A {\n    public init() {}\n    public operator func ()(): Unit {}\n}\n\nfunc test1() {\n    let a = A() // Ok, A() is call the constructor of A.\n    a() // Ok, a() is to call the operator () overloading function.\n}"}
{"text": "'Cangjie programming language_operator_overload_operator_overloading_restrictions': 'In Cangjie code language, You cannot overload operators that are not listed in the appendix.\nYou cannot define custom operators.\nYou can't use this or super to call the () operator to overload the function. \nIf a type already supports an operator, you cannot overload it again through extension.'\n\nCode_Example:\nopen class A {\n    public init() {}\n    public init(x: Int64) {\n        this() // Ok, this() calls the constructor of A.\n    }\n    public operator func ()(): Unit {}\n\n    public func foo() {\n        this()  // Error, this() calls the constructor of A.\n        super() // Error\n    }\n}\nclass B <: A {\n    public init() {\n        super() // Ok, super()  calls the constructor of the super class.\n    }\n    public func goo() {\n        super() // Error\n    }\n}"}
{"text": "'Cangjie programming language_operator_overload_operator_overloading_priority': 'In Cangjie code language, Overloading an operator does not change its inherent precedence and associativity. The precedence and associativity of operators are fixed and defined in the language specification.\nFor enumeration types, the constructor form is preferred when both the constructor form and the () operator overloaded function form are satisfied.'\n\nCode_Example:\nenum E {\n    Y | X | X(Int64)\n\n    public operator func ()(p: Int64) {}\n    public operator func ()(p: Float64) {}\n}\n\nmain() {\n    let e = X(1) // Ok, X(1) is to call the constructor X(Int64).\n    X(1.0) // Ok, X(1.0) is to call the operator () overloading function.\n    let e1 = X\n    e1(1) // Ok, e1(1) is to call the operator () overloading function.\n    Y(1) // oK, Y(1) is to call the operator () overloading function.\n}"}
{"text": "'Cangjie programming language_operator_overload_overloadable_operators': 'In Cangjie code language, Cangjie allows overloading of the following operators, listed in order of precedence from highest to lowest:\nOperator\tDescription\n()\tFunction call\n[]\tIndexing\n!\tLogical NOT\n-\tUnary minus (negation)\n**\tExponentiation (power)\n*\tMultiplication\n/\tDivision\n%\tModulus (remainder)\n+\tAddition\n-\tSubtraction\n<<\tBitwise left shift\n>>\tBitwise right shift\n<\tLess than\n<=\tLess than or equal to\n>\tGreater than\n>=\tGreater than or equal to\n==\tEquality\n!=\tInequality\n&\tBitwise AND\n^\tBitwise XOR\n|\tBitwise OR\nThese operators can be overloaded by defining corresponding operator functions within classes, interfaces, structs, enums, or extensions.'"}
{"text": "'Cangjie programming language_operator_overload_operator_overloading_restrictions': 'In Cangjie code language, You cannot overload operators that are not listed in the table above.\nYou cannot define custom operators beyond those listed.\nIf a type already supports an operator, you cannot overload it again through extension.\nOverloading an operator does not change its inherent precedence and associativity.'"}
