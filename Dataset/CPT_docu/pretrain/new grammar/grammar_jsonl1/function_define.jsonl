{"text": "'Cangjie programming language_function_define_function_definition': 'In Cangjie code language, Functions in Cangjie are defined using the func keyword, followed by the function name, a parameter list enclosed in parentheses, an optional return type, the parameter list and the function return value type (if present) are separated by colons, and the function body enclosed in curly braces. The function name must be a valid identifier.'\n\nCode_Example:\nfunc add(a: Int64, b: Int64): Int64 {\n    return a + b\n}"}
{"text": "'Cangjie programming language_function_define_function_parameters': 'In Cangjie code language, Function parameters in Cangjie can be categorized into two types:unnamed parameters and named parameters.\nPositional parameters: Defined as p: T, where p is the parameter name and T is the parameter type.\nUnnamed parameters are defined as p:T, where p is the parameter name, T is the type of the parameter p, and the parameter name is concatenated with a colon between its type. For example, the two arguments a and b of the add function in the example above are unnamed.\nNamed parameters are defined as p!: T, and are distinguished from unnamed parameters by adding a !, after the parameter name p.\nYou can also set a default value for a named parameter, which is set to the value of the expression e by using p!: T = e. \nYou can define both unnamed and named parameters in the parameter list, but it should be noted that unnamed parameters can only be defined before named parameters, which means that no unnamed parameters can appear after named parameters.\nThe function parameter scope starts at the point of definition and ends at the end of the function body.'\n\nCode_Example:\n// Unnamed parameters\nfunc add(a: Int64, b: Int64): Int64 {\n    return a + b\n}\n//Named parameters \nfunc add(a!: Int64, b!: Int64): Int64 {\n    return a + b\n}\n//set a default value for a named parameter\nfunc add(a!: Int64 = 1, b!: Int64 = 1): Int64 {\n    return a + b\n}"}
{"text": "'Cangjie programming language_function_define_function_return_type': 'In Cangjie code language, The return type of a function in Cangjie is optional. It can be explicitly specified after the parameter list or inferred by the compiler. If specified, the return type must match the type of the expression in the return statement.\nWhen the function return value type is explicitly defined, the type of the function body is required (see the next section on how to determine the type of the function body), and the type of e in all return e expressions in the function body is a subtype of the return value type.'\n\nCode_Example:\n// Explicit return type\nfunc add(a: Int64, b: Int64): Int64 {\n    return a + b\n}\n\n// Inferred return type\nfunc add(a: Int64, b: Int64) {\n    return a + b\n}\n\nError_case_code:\nfunc add(a: Int64, b: Int64): Int64 {\n    return (a, b)  // Error, the type of the expression after return does not match the return type of the function\n}"}
{"text": "'Cangjie programming language_function_define_function_body': 'In Cangjie code language, The function body in Cangjie is enclosed in curly braces {} and contains the implementation logic of the function. The body can include variable definitions, expressions, and nested function definitions. The type of the function body is determined by the last expression or statement.'\n\nCode_Example:\nfunc add(a: Int64, b: Int64) {\n    var r = 0\n    r = a + b\n    return r\n}"}
{"text": "'Cangjie programming language_function_define_function_return_expression': 'In Cangjie code language, The return expression in Cangjie is used to terminate the function execution and return a value. The return expression can be in two forms:\nreturn expr: Returns the value of the expression expr.\nreturn: Equivalent to return (), used when the function returns Unit.\nThe type of the return expression must match the function's return type.'\n\nCode_Example:\nfunc add(a: Int64, b: Int64) {\n    var r = 0\n    r = a + b\n    return r\n}\nfunc foo(): Unit {\n    add(1, 2)\n    return\n}\n\nError_case_code:\nfunc foo(): String {\n    return 100  // Error, cannot convert an integer literal to type 'Struct-String'\n}"}
{"text": "'Cangjie programming language_function_define_function_local_variables': 'In Cangjie code language, Local variables in Cangjie are defined within the function body and have a scope that extends from their definition to the end of the function body. Local variables can \"shadow\" variables from outer scopes with the same name.'\n\nCode_Example:\nlet r = 0\nfunc add(a: Int64, b: Int64) {\n    var r = 0  //the local variable r (in the function body) \"masks\" the global variable r\n    r = a + b\n    return r\n}"}
{"text": "'Cangjie programming language_function_define_function_type_inference': 'In Cangjie code language, The return type of a function in Cangjie can be inferred by the compiler based on the last expression in the function body or the type of the return expression. If the return type cannot be inferred, it must be explicitly specified.'\n\nCode_Example:\nfunc add(a: Int64, b: Int64) {\n    return a + b // Inferred return type: Int64\n}\nfunc add(a: Int64, b: Int64): Int64 {\n    a + b\n}\nfunc greet(name: String) {\n    println(\"Hello, ${name}!\") // Inferred return type: Unit\n}\nfunc foo(): Unit {\n    let s = \"Hello\"\n    print(s)\n}"}
{"text": "'Cangjie programming language_function_define_function_unit_return': 'In Cangjie code language, When a function returns Unit, the compiler automatically inserts return () at all possible return points. This ensures that the function always returns Unit.'\n\nCode_Example:\nfunc example(): Unit {\n    println(\"This function returns Unit\")\n}"}
{"text": "'Cangjie programming language_function_define_function_shadowing': 'In Cangjie code language, In Cangjie, a local variable can shadow a variable from an outer scope if they have the same name. The local variable takes precedence within its scope.'\n\nCode_Example:\nlet r = 0\nfunc add(a: Int64, b: Int64) {\n    var r = 0  //the local variable r (in the function body) \"masks\" the global variable r.\n    r = a + b\n    return r\n}"}
