{"text": "'Cangjie programming language_extend_rules_extension_modifiers': 'In Cangjie code language, Extensions themselves cannot be modified by modifiers. However, extension members can use the following modifiers:\nstatic: Members can only be accessed via the type name, not via an instance.\npublic, protected, internal, private: Control the visibility of members.\nprivate: Members are only accessible within the extension.\ninternal: Members are accessible within the current package and its subpackages (default behavior).\nprotected: Members are accessible within the module (subject to export rules). If the extended type is a class, its subclasses can also access them.\nmut: Can be used for functions in extensions of struct types.\nExtension members do not support the use of open, override, or redef.'\n\nCode_Example:\npackage p1\npublic open class A {}\nextend A {\n    public func f1() {}\n    protected func f2() {}\n    private func f3() {}\n    static func f4() {}\n}\nmain() {\n    A.f4()\n    var a = A()\n    a.f1()\n    a.f2()\n}\n\nError_case_code:\nclass Foo {\n    public open func f() {}\n    static func h() {}\n}\nextend Foo {\n    public override func f() {} // Error\n    public open func g() {} // Error\n    redef static func h() {} // Error\n}"}
{"text": "'Cangjie programming language_extend_rules_orphan_extension_rule': 'In Cangjie code language, Cangjie does not allow orphan extensions, which are extensions that are neither in the same package as the extended type nor in the same package as the interface being implemented. For example, you cannot implement an interface Bar from package b for a type Foo from package a in package c. It must be done in either package a or package b.'\n\nCode_Example:\n// package a\npublic class Foo {}\n\n// package b\npublic interface Bar {}\n\n// package c\nimport a.Foo\nimport b.Bar\n\nextend Foo <: Bar {} // Error"}
{"text": "'Cangjie programming language_extend_rules_extension_access_and_shadowing': 'In Cangjie code language, Extension instance members can use this (consistent with the type definition) and can omit this to access members. They cannot use super.\nExtensions cannot access private members of the extended type.\nExtensions cannot shadow any members of the extended type.\nExtensions cannot shadow members added by other extensions.\nWithin the same package, a type can be extended multiple times, and extensions can call non-private functions from other extensions of the same type.\nWhen extending generic types, additional generic constraints can be used. The visibility rules between two extensions of a generic type E<X> are as follows:\nIf the constraints are the same, both extensions are mutually visible.\nIf the constraints are different but have an inclusion relationship, the more permissive constraint extension is visible to the more restrictive one, but not vice versa.\nIf the constraints are different and have no inclusion relationship, both extensions are mutually invisible.'\n\nCode_Example:\nopen class A {}\nclass B <: A {}\nclass E<X> {}\n\ninterface I1 {\n    func f1(): Unit\n}\ninterface I2 {\n    func f2(): Unit\n}\n\nextend<X> E<X> <: I1 where X <: B {  // extension 1\n    public func f1(): Unit {\n        f2() // OK\n    }\n}\n\nextend<X> E<X> <: I2 where X <: A   { // extension 2\n    public func f2(): Unit {\n        f1() // Error\n    }\n}"}
{"text": "'Cangjie programming language_extend_rules_extension_import_export': 'In Cangjie code language, Extensions cannot be modified by public, but they follow special export rules.\nFor direct extensions:\nIf the extension and the extended type are in the same package, and both the type and the added members are public or protected, the extension is exported.\nOtherwise, the extension is not exported and is only usable within the current package.\nFor interface extensions:\nIf the interface extension and the extended type are in the same package, but the interface is imported, the extension is exported only if the extended type is public.\nIf the interface extension is in the same package as the interface, the extension is exported only if the interface is public.\nImporting extensions does not require an explicit import statement. Importing the extended type and interface will automatically import all accessible extensions.'\n\nCode_Example:\n// package a\npackage a\npublic class Foo {}\nextend Foo {\n    public func f() {}\n}\n\n// package b\npackage b\nimport a.Foo\npublic interface I {\n    func g(): Unit\n}\nextend Foo <: I {\n    public func g() {\n        this.f() // OK\n    }\n}\n\n// package c\npackage c\nimport a.Foo\nimport b.I\nfunc test() {\n    let a = Foo()\n    a.f() // OK\n    a.g() // OK\n}"}
