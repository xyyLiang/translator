{"text": "'Cangjie programming language_class_interface_interface_definition': 'In Cangjie code language, Interfaces in Cangjie are defined using the interface keyword, followed by the interface name and a body enclosed in curly braces. The body can contain member functions, operator overloading functions, and member properties. These members are abstract and must be implemented by the types that implement the interface.'\n\nCode_Example:\ninterface I { // 'open' modifier is optional.\n    func f(): Unit\n}"}
{"text": "'Cangjie programming language_class_interface_interface_members': 'In Cangjie code language, An interface in Cangjie can contain the following members:\nMember functions: Abstract functions that must be implemented by the implementing type.\nOperator overloading functions: Abstract functions for operator overloading.\nMember properties: Abstract properties that must be implemented by the implementing type.\nThe interface is declared using the keyword interface, followed by the identifier I of the interface and the members of the interface. Interface members can be decorated with the open modifier, and the open modifier is optional.\nWhen interface I declares a member function f, to implement I for a type, a corresponding f function must be implemented in that type.Because interface has open semantics by default, the open modifier for interface definition is optional.'\n\nCode_Example:\nclass Foo <: I {\n    public func f(): Unit {\n        println(\"Foo\")\n    }\n}\nmain() {\n    let a = Foo()\n    let b: I = a\n    b.f() // \"Foo\"\n}"}
{"text": "'Cangjie programming language_class_interface_interface_sealed_modifier': 'In Cangjie code language, An interface can also use the sealed modifier to indicate that the interface can only be inherited, implemented, or extended within the package in which the interface definition is located. Sealed already has public/open semantics, so if the public/open modifier is provided when defining a sealed interface, the compiler will alert. Subinterfaces that inherit the sealed interface or abstract classes that implement the sealed interface can still be decorated with sealed or without sealed. If a sub-interface of a sealed interface is decorated by public and is not decorated by sealed, its sub-interface can be inherited, implemented, or extended outside the package. The type of the inherited and sealed interface can be undecorated by public.\nThrough this constraint of the interface, a series of types can be agreed on a common function, so as to achieve the purpose of abstracting the function.'\n\nCode_Example:\npackage A\npublic interface I1 {}\nsealed interface I2 {}         // OK\npublic sealed interface I3 {}  // Warning, redundant modifier, 'sealed' implies 'public'\nsealed open interface I4 {}    // Warning, redundant modifier, 'sealed' implies 'open'\nclass C1 <: I1 {}\npublic open class C2 <: I1 {}\nsealed abstract class C3 <: I2 {}\nextend Int64 <: I2 {}\n\npackage B\nimport A.*\nclass S1 <: I1 {}  // OK\nclass S2 <: I2 {}  // Error, I2 is sealed interface, cannot be inherited here."}
{"text": "'Cangjie programming language_class_interface_interface_sealed': 'In Cangjie code language, Interfaces can be marked with the sealed modifier, indicating that they can only be implemented or extended within the same package. sealed implies public or open, and the compiler will warn if public or open is explicitly used.\nInheritance: Subinterfaces or implementing classes can be sealed or not.\nVisibility: If a subinterface is public and not sealed, it can be inherited, implemented, or extended outside the package.'"}
{"text": "'Cangjie programming language_class_interface_interface_static_members': 'In Cangjie code language, Interfaces can contain static member functions and properties. These members must be implemented by the implementing type and can be accessed through the interface name.\nStatic member functions: Must be implemented by the implementing type.\nStatic properties: Must be implemented by the implementing type.'\n\nCode_Example:\ninterface NamedType {\n    static func typename(): String\n}\nclass A <: NamedType {\n    public static func typename(): String {\n        \"A\"\n    }\n}\nclass B <: NamedType {\n    public static func typename(): String {\n        \"B\"\n    }\n}\nmain() {\n    println(\"the type is ${ A.typename() }\") // Output: the type is A\n    println(\"the type is ${ B.typename() }\") // Output: the type is B\n}"}
{"text": "'Cangjie programming language_class_interface_interface_default_implementations': 'In Cangjie code language, Interface members can have default implementations. When a type implements an interface with default implementations, it can inherit these implementations or provide its own.\nDefault static members: Can be accessed through the interface name.\nOverriding: Implementing types can override default implementations.'\n\nCode_Example:\ninterface NamedType {\n    static func typename(): String {\n        \"interface NamedType\"\n    }\n}\nclass A <: NamedType {}\nmain() {\n    println(NamedType.typename()) // Output:interface NamedType\n    println(A.typename()) // Output:interface NamedType\n    0\n}"}
{"text": "'Cangjie programming language_class_interface_interface_inheritance': 'In Cangjie code language, Interfaces can inherit from one or more interfaces but cannot inherit from classes. An interface can add new members when inheriting.\nMultiple inheritance: An interface can inherit from multiple interfaces.\nNew members: An interface can add new members when inheriting.\nAn interface can inherit one or more interfaces, but not a class.'\n\nCode_Example:\ninterface Addable {\n    func add(other: Int64): Int64\n}\n\ninterface Subtractable {\n    func sub(other: Int64): Int64\n}\n\nclass MyInt <: Addable & Subtractable {\n    var value = 0\n    public func add(other: Int64): Int64 {\n        value + other\n    }\n    public func sub(other: Int64): Int64 {\n        value - other\n    }\n}"}
{"text": "'Cangjie programming language_class_interface_interface_conflicts': 'In Cangjie code language, When an interface inherits from multiple interfaces that have the same member with a default implementation, the implementing type must provide its own implementation to resolve the conflict.'"}
{"text": "'Cangjie programming language_class_interface_interface_any_type': 'In Cangjie code language, The Any type is a built-in interface that all interfaces inherit from and all non-interface types implement. It serves as a universal base type，which is defined as follows：\ninterface Any {}'\n\nCode_Example:\nmain() {\n    var any: Any = 1\n    any = 2.0\n    any = \"hello, world!\"\n}"}
{"text": "'Cangjie programming language_class_interface_interface_implementation': 'In Cangjie code language, In Cangjie, a type can implement an interface by declaring it using the <: keyword and providing implementations for all the members declared in the interface. The implementing type becomes a subtype of the interface.\nDeclaration: The implementing type must declare that it implements the interface using the <: keyword.\nMember Implementation: The implementing type must provide implementations for all abstract members (functions, operator overloads, and properties) declared in the interface.'"}
{"text": "'Cangjie programming language_class_interface_interface_implementation_rules': 'In Cangjie code language, When implementing an interface in Cangjie, the following rules must be followed:\nFunction and Operator Overload Functions: The implementing type must provide functions with the same name, parameter list, and return type as those declared in the interface.\nProperties: The implementing type must provide properties with the same type and mutability (i.e., whether they are mut or not) as those declared in the interface.\nSubtype Return Types: If the interface member function or operator overload function returns a class type, the implementing function can return a subtype of that class.\nDefault Implementations: Interface members can have default implementations. The implementing type can inherit these implementations or provide its own.'\n\nCode_Example:\nopen class Base {}\nclass Sub <: Base {}\n\ninterface I {\n    func f(): Base\n}\n\nclass C <: I {\n    public func f(): Sub {\n        Sub()\n    }\n}"}
{"text": "'Cangjie programming language_class_interface_interface_implementation_multiple': 'In Cangjie code language, A type can implement multiple interfaces by declaring them using the <: keyword and separating them with &. The order of the interfaces does not matter.'\n\nCode_Example:\ninterface SayHi {\n    func say() {\n        \"hi\"\n    }\n}\ninterface SayHello {\n    func say() {\n        \"hello\"\n    }\n}\nclass Foo <: SayHi & SayHello {\n    public func say() {\n        \"Foo\"\n    }\n}"}
{"text": "'Cangjie programming language_class_interface_interface_implementation_inheritance': 'In Cangjie code language, When a type implements an interface that inherits from other interfaces, the implementing type must provide implementations for all members declared in the inherited interfaces as well.\nInherited Members: The implementing type must implement all members from the inherited interfaces.\nSubtype Relationship: The implementing type becomes a subtype of all inherited interfaces.'"}
{"text": "'Cangjie programming language_class_interface_interface_implementation_conflicts': 'In Cangjie code language, If a type implements multiple interfaces that have the same member with a default implementation, the implementing type must provide its own implementation to resolve the conflict.'\n\nCode_Example:\ninterface SayHi {\n    func say() {\n        \"hi\"\n    }\n}\ninterface SayHello {\n    func say() {\n        \"hello\"\n    }\n}\nclass Foo <: SayHi & SayHello {\n    public func say() {\n        \"Foo\"\n    }\n}"}
{"text": "'Cangjie programming language_class_interface_interface_implementation_default': 'In Cangjie code language, Interface members can have default implementations. When a type implements an interface with default implementations, it can inherit these implementations or provide its own.\nInheriting Default Implementations: The implementing type can inherit the default implementations provided by the interface.\nOverriding Default Implementations: The implementing type can override the default implementations with its own.'"}
