{"text": "'Cangjie programming language_macros_compilation flags_builtin_compilation_flags': 'In Cangjie code language, Cangjie provides several predefined compilation flags that can be used to control the behavior of the Cangjie compiler. These flags include source code location flags and conditional compilation flags.'"}
{"text": "'Cangjie programming language_macros_compilation flags_source_code_location_flags': 'In Cangjie code language, Cangjie provides built-in flags to get the source code location:\n@sourcePackage(): Expands to a String literal containing the package name of the source code.\n@sourceFile(): Expands to a String literal containing the file name of the source code.\n@sourceLine(): Expands to an Int64 literal containing the line number of the source code.\nThese flags can be used within any expression as long as they pass type checking.'\n\nCode_Example:\nfunc test1() {\n    let s: String = @sourceFile()  // The value of `s` is the current source file name\n}\nfunc test2(n!: Int64 = @sourceLine()) { /* at line 5 */\n    // The default value of `n` is the source file line number of the definition of `test2`\n    println(n) // print 5\n}"}
{"text": "'Cangjie programming language_macros_compilation flags_conditional_compilation': 'In Cangjie code language, Conditional compilation in Cangjie is done using the @When flag. It allows selective compilation of code segments based on specific conditions. This is useful for platform adaptation, feature selection, debugging support, and performance optimization.\n The main functions of conditional compilation are primarily reflected in the following aspects:\nPlatform adaptation: Supports selectively compiling code based on the current compilation environment, used to achieve cross-platform compatibility.\nFeature selection: Supports selectively compiling code based on different requirements, used to implement flexible feature configuration.\nDebugging support: Supports compiling related code in debug mode, used to improve program performance and security. For example, compiling debug information or log-related code in debug mode, while excluding them in the release version.\nPerformance Optimization: Supports selectively compiling code based on predefined conditions to improve program performance.'"}
{"text": "'Cangjie programming language_macros_compilation flags_fastnative_flag': 'In Cangjie code language, The @FastNative flag is used to optimize calls to C functions. It can only be used with foreign function declarations. The C function must meet the following requirements:\nThe function should not have a long execution time or blocking behavior.\nThe function should not call any Cangjie methods.'\n\nCode_Example:\n@FastNative\nforeign func strlen(str: CPointer<UInt8>): UIntNative"}
{"text": "'Cangjie programming language_macros_compilation flags_attribute_flag': 'In Cangjie code language, The @Attribute flag is used to set attribute values for declarations. Attribute values can be identifiers or strings. The std.ast package provides methods like getAttrs() and hasAttr() to work with attributes.'\n\nCode_Example:\n@Attribute[State] var cnt = 0       // identifier\n@Attribute[\"Binding\"] var bcnt = 0  // string\n\n#Macro definition as follows:\npublic macro Component(input: Tokens): Tokens {\nvar varDecl = parseDecl(input)\nif (varDecl.hasAttr(\"State\")) {// returns true if the node is marked with an attribute and the value is \"State\", otherwise returns false\nvar attrs = varDecl.getAttrs() // returns a set of Tokens\nprintln(attrs[0].value)\n}\nreturn input\n}\n#Macro invocation is as follows:\n@Component(\n@Attribute[State] var cnt = 0\n)"}
