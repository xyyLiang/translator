{"text": "'Cangjie programming language_class_conversion_type_conversion': 'In Cangjie code language, Cangjie does not support implicit type conversions between different types. Type conversions must be performed explicitly. This section covers type conversions between numeric types, conversions between Rune and UInt32, and the use of the is and as operators.'"}
{"text": "'Cangjie programming language_class_conversion_numeric_type_conversion': 'In Cangjie code language, For numeric types (including Int8, Int16, Int32, Int64, IntNative, UInt8, UInt16, UInt32, UInt64, UIntNative, Float16, Float32, Float64), Cangjie supports explicit conversion using the syntax T(e), where T is the target type and e is the expression to be converted.'\n\nCode_Example:\nmain() {\n    let a: Int8 = 10\n    let b: Int16 = 20\n    let r1 = Int16(a)\n    println(\"The type of r1 is 'Int16', and r1 = ${r1}\")\n    let r2 = Int8(b)\n    println(\"The type of r2 is 'Int8', and r2 = ${r2}\")\n\n    let c: Float32 = 1.0\n    let d: Float64 = 1.123456789\n    let r3 = Float64(c)\n    println(\"The type of r3 is 'Float64', and r3 = ${r3}\")\n    let r4 = Float32(d)\n    println(\"The type of r4 is 'Float32', and r4 = ${r4}\")\n\n    let e: Int64 = 1024\n    let f: Float64 = 1024.1024\n    let r5 = Float64(e)\n    println(\"The type of r5 is 'Float64', and r5 = ${r5}\")\n    let r6 = Int64(f)\n    println(\"The type of r6 is 'Int64', and r6 = ${r6}\")\n}"}
{"text": "'Cangjie programming language_class_conversion_rune_uint32_conversion': 'In Cangjie code language, A Rune can be converted to a UInt32 using the syntax UInt32(e), where e is a Rune expression. The result is the Unicode scalar value of the Rune as a UInt32.'\n\nCode_Example:\nmain() {\n    let x: Rune = 'a'\n    let y: UInt32 = 65\n    let r1 = UInt32(x)\n    let r2 = Rune(y)\n    println(\"The type of r1 is 'UInt32', and r1 = ${r1}\")\n    println(\"The type of r2 is 'Rune', and r2 = ${r2}\")\n}"}
{"text": "'Cangjie programming language_class_conversion_int_rune_conversion': 'In Cangjie code language, An integer can be converted to a Rune using the syntax Rune(num), where num is an integer expression. The conversion succeeds if num is within the Unicode scalar value range [0x0000, 0xD7FF] or [0xE000, 0x10FFFF]. Otherwise, it results in a compile-time error or runtime exception.'"}
{"text": "'Cangjie programming language_class_conversion_type_conversion_is_operator': 'In Cangjie code language, The is operator is used to check if an expression's type is a subtype of a specified type. The expression e is T evaluates to true if the runtime type of e is a subtype of T, otherwise it evaluates to false.'\n\nCode_Example:\nopen class Base {\n    var name: String = \"Alice\"\n}\nclass Derived <: Base {\n    var age: UInt8 = 18\n}\nmain() {\n    let a = 1 is Int64\n    println(\"Is the type of 1 'Int64'? ${a}\")\n    let b = 1 is String\n    println(\"Is the type of 1 'String'? ${b}\")\n    let b1: Base = Base()\n    let b2: Base = Derived()\n    var x = b1 is Base\n    println(\"Is the type of b1 'Base'? ${x}\")\n    x = b1 is Derived\n    println(\"Is the type of b1 'Derived'? ${x}\")\n    x = b2 is Base\n    println(\"Is the type of b2 'Base'? ${x}\")\n    x = b2 is Derived\n    println(\"Is the type of b2 'Derived'? ${x}\")\n}"}
{"text": "'Cangjie programming language_class_conversion_type_conversion_as_operator': 'In Cangjie code language, The as operator is used to perform type conversions that may fail. The expression e as T returns an Option<T> where the result is Some(e) if the runtime type of e is a subtype of T, otherwise it returns None.'\n\nCode_Example:\nopen class Base {\n    var name: String = \"Alice\"\n}\nclass Derived <: Base {\n    var age: UInt8 = 18\n}\n\nlet a = 1 as Int64     // a = Option<Int64>.Some(1)\nlet b = 1 as String    // b = Option<String>.None\nlet b1: Base = Base()\nlet b2: Base = Derived()\nlet d: Derived = Derived()\nlet r1 = b1 as Base    // r1 = Option<Base>.Some(b1)\nlet r2 = b1 as Derived // r2 = Option<Derived>.None\nlet r3 = b2 as Base    // r3 = Option<Base>.Some(b2)\nlet r4 = b2 as Derived // r4 = Option<Derived>.Some(b2)\nlet r5 = d as Base     // r5 = Option<Base>.Some(d)\nlet r6 = d as Derived  // r6 = Option<Derived>.Some(d)"}
