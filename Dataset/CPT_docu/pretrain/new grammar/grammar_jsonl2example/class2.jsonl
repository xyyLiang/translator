{"text": "Cangjie programming language syntax:\nThe class type is a classic concept in object-oriented programming, and Cangjie also supports using class to implement object-oriented programming. The main difference between class and struct is that class is a reference type, while struct is a value type, and their behavior is different when assigned or passed as parameters; classes can inherit from each other, but structs cannot.\n A class can only be defined in the top-level scope of a source file."}
{"text": "Cangjie programming language syntax:\nThe definition of a class starts with the keyword class, followed by the class name, and then the class definition body enclosed in a pair of curly braces. The class definition body can define a series of member variables, member properties (see Properties), static initializers, constructors, member functions, and operator functions.\n A class can only be defined in the top-level scope of a source file.\nThe example defines a class type named Rectangle, which has two member variables of type Int64: width and height, a constructor with two Int64 type parameters, and a member function area (which returns the product of width and height).class Rectangle {\n    let width: Int64\n    let height: Int64\n\n\n    public init(width: Int64, height: Int64) {\n        this.width = width\n        this.height = height\n    }\n\n\n    public func area() {\n        width * height\n    }\n}"}
{"text": "Cangjie programming language syntax:\nA class modified with the abstract modifier is an abstract class. Unlike regular classes, abstract classes can not only define regular functions but also declare abstract functions (which have no function body). The open modifier is optional when defining an abstract class, and an abstract class can also be modified with the sealed modifier, indicating that the abstract class can only be inherited within this package. \nAbstract classes cannot define private abstract functions;\nAbstract classes cannot be instantiated;\nNon-abstract subclasses of an abstract class must implement all abstract functions from the parent class.The following example defines an abstract function foo in the abstract class AbRectangle.abstract class AbRectangle {\n    public func foo(): Unit\n}"}
{"text": "Cangjie programming language syntax:\nMember variables of a class are divided into instance member variables and static member variables. Static member variables are modified using the static modifier. When there is no static initializer, they must have an initial value and can only be accessed through the type name. Refer to the following example:class Rectangle {\n    let width = 10\n    static let height = 20\n}\n\nlet l = Rectangle.height // l = 20"}
{"text": "Cangjie programming language syntax:\nInstance member variables can be defined without setting an initial value (but must be marked with a type), or an initial value can be set. They can only be accessed through an object (i.e., an instance of the class). Refer to the following example:class Rectangle {\n    let width = 10\n    let height: Int64\n    init(h: Int64){\n        height = h\n    }\n}\nlet rec = Rectangle(20)\nlet l = rec.height // l = 20"}
{"text": "Cangjie programming language syntax:\nA class supports defining a static initializer, and can initialize static member variables through assignment expressions within the static initializer.\nStatic initializers start with the keyword combination static init, followed by an empty parameter list and a function body, and cannot be modified by access modifiers. The function body must complete the initialization of all uninitialized static member variables, otherwise the compilation will report an error.class Rectangle {\n    static let degree: Int64\n    static init() {\n        degree = 180\n    }\n}"}
{"text": "Cangjie programming language syntax:\nA class can have at most one static initializer defined, otherwise a redefinition error will occur.\n\nError_case:\nclass Rectangle {\n    static let degree: Int64\n    static init() {\n        degree = 180\n    }\n    static init() { // Error, redefinition with the previous static init function\n        degree = 180\n    }\n}"}
{"text": "Cangjie programming language syntax:\nLike struct, class also supports defining regular constructors and primary constructors.\nRegular constructors start with the keyword init, followed by a parameter list and a function body. The function body must complete the initialization of all uninitialized instance member variables, otherwise a compilation error will occur.class Rectangle {\n    let width: Int64\n    let height: Int64\n\n\n    public init(width: Int64, height: Int64) { // Error, 'height' is not initialized in the constructor\n        this.width = width\n    }\n}"}
{"text": "Cangjie programming language syntax:\nA class can define multiple regular constructors, but they must constitute overloading (see Function Overloading), otherwise a redefinition error will be reported.class Rectangle {\n    let width: Int64\n    let height: Int64\n\n\n    public init(width: Int64) {\n        this.width = width\n        this.height = width\n    }\n\n\n    public init(width: Int64, height: Int64) { // Ok: overloading with the first init function\n        this.width = width\n        this.height = height\n    }\n\n\n    public init(height: Int64) { // Error, redefinition with the first init function\n        this.width = height\n        this.height = height\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn addition to being able to define several ordinary constructors named with init, a class can also define (at most) one primary constructor. The primary constructor's name is the same as the class type name, and its parameter list can have two forms of formal parameters: ordinary parameters and member variable parameters (which need to be prefixed with let or var). Member variable parameters serve the dual purpose of defining member variables and constructor parameters.\nUsing the primary constructor can often simplify class definitions. For example, the Rectangle above, which includes an init constructor, can be simplified to the following definition:class Rectangle {\n    public Rectangle(let width: Int64, let height: Int64) {}\n}"}
{"text": "Cangjie programming language syntax:\nIn addition to being able to define several ordinary constructors named with init, a class can also define (at most) one primary constructor. The primary constructor's name is the same as the class type name, and its parameter list can have two forms of formal parameters: ordinary parameters and member variable parameters (which need to be prefixed with let or var). Member variable parameters serve the dual purpose of defining member variables and constructor parameters.\nThe parameter list of the main constructor can also define ordinary formal parameters, for example:class Rectangle {\n    public Rectangle(name: String, let width: Int64, let height: Int64) {}\n}"}
{"text": "Cangjie programming language syntax:\nThe constructor called when creating an instance of a class will execute the expressions in the class in the following order:\nInitialize variables with default values defined outside the main constructor;\nIf the constructor body does not explicitly call the parent class constructor or other constructors of this class, the parent class's no-argument constructor super() is called. If the parent class does not have a no-argument constructor, an error is reported;\nExecute the code in the constructor body.when the constructor of B is called, the variable x with the default value is first initialized, at which point foo(0) is called; subsequently, the parent class's parameterless constructor is called, at which point the constructor of A is called; next, the code within the constructor body is executed, at which point foo(1) is called and a string is printed.func foo(x: Int64): Int64 {\n    println(\"I'm foo, got ${x}\")\n    x\n}\n\nopen class A {\n    init() {\n        println(\"I'm A\")\n    }\n}\n\nclass B <: A {\n    var x = foo(0)\n    init() {\n        x = foo(1)\n        println(\"init B finished\")\n    }\n}\n\nmain() {\n    B()\n    0\n}"}
{"text": "Cangjie programming language syntax:\nIf there is no custom constructor in the class definition (including the primary constructor), and all instance member variables have initial values, it will automatically generate a parameterless constructor for it (invoking this parameterless constructor will create an object where all instance member variables are initialized to their initial values); otherwise, it will not automatically generate this parameterless constructor. For example, for the following class definition, the compiler will automatically generate a parameterless constructor for it:If there is no custom constructor in the class definition (including the primary constructor), and all instance member variables have initial values, it will automatically generate a parameterless constructor for it (invoking this parameterless constructor will create an object where all instance member variables are initialized to their initial values); otherwise, it will not automatically generate this parameterless constructor. For example, for the following class definition, the compiler will automatically generate a parameterless constructor for it:"}
{"text": "Cangjie programming language syntax:\nclass Supports defining a terminator, which is a function called when an instance of the class is garbage collected. The terminator's function name is fixed as ~init. Terminators are generally used to release system resources:class C {\n    var p: CString\n\n\n    init(s: String) {\n        p = unsafe { LibC.mallocCString(s) }\n        println(s)\n    }\n    ~init() {\n        unsafe { LibC.free(p) }\n    }\n}"}
{"text": "Cangjie programming language syntax:\nMember functions of a class are also divided into instance member functions and static member functions (modified using the static modifier). Instance member functions can only be accessed through objects, while static member functions can only be accessed through the class type name. Static member functions cannot access instance member variables or call instance member functions, but instance member functions can access static member variables and static member functions.\nIn the example below, area is an instance member function, and typeName is a static member function.class Rectangle {\n    let width: Int64 = 10\n    let height: Int64 = 20\n\n\n    public func area() {\n        this.width * this.height\n    }\n\n\n    public static func typeName(): String {\n        \"Rectangle\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nInstance member functions can be further divided into abstract member functions and non-abstract member functions based on whether they have a function body. Abstract member functions do not have a function body and can only be defined in abstract classes or interfaces (see the Interface chapter for details). It is important to note that abstract instance member functions have the default semantic meaning of open. The open modifier is optional and must be modified using public or protected.\nNon-abstract functions must have a function body, where you can access instance member variables through `this`, for example:class Rectangle {\n    let width: Int64 = 10\n    let height: Int64 = 20\n\n\n    public func area() {\n        this.width * this.height\n    }\n}"}
{"text": "Cangjie programming language syntax:\nFor class members (including member variables, member properties, constructors, and member functions), there are 4 access modifiers that can be used to decorate them: private, internal, protected, and public. The default meaning is internal.\nprivate indicates visibility within the class definition.\ninternal indicates visibility within the current package and sub-packages (including sub-packages of sub-packages, see the Package chapter for details).\nprotected indicates visibility in the current module (see the Package chapter for details) and in subclasses of the current class.\npublic indicates visibility both inside and outside the module.//a.cj file\npackage a\npublic open class Rectangle {\n    public var width: Int64\n    protected var height: Int64\n    private var area: Int64\n    public init(width: Int64, height: Int64) {\n        this.width = width\n        this.height = height\n        this.area = this.width * this.height\n    }\n    init(width: Int64, height: Int64, multiple: Int64) {\n        this.width = width\n        this.height = height\n        this.area = width * height * multiple\n    }\n}\n\n\nfunc samePkgFunc() {\n    var r = Rectangle(10, 20) // Ok: constructor 'Rectangle' can be accessed here\n    r.width = 8               // Ok: public 'width' can be accessed here\n    r.height = 24             // Ok: protected 'height' can be accessed here\n    r.area = 30               // Error, private 'area' cannot be accessed here\n}\n\n//b.cj file\npackage b\nimport a.*\npublic class Cuboid <: Rectangle {\n    private var length: Int64\n    public init(width: Int64, height: Int64, length: Int64) {\n        super(width, height)\n        this.length = length\n    }\n    public func volume() {\n        this.width * this.height * this.length // Ok: protected 'height' can be accessed here\n    }\n}\n\n\nmain() {\n    var r = Rectangle(10, 20, 2) // Error, Rectangle has no `public` constructor with three parameters\n    var c = Cuboid(20, 20, 20)\n    c.width = 8               // Ok: public 'width' can be accessed here\n    c.height = 24             // Error, protected 'height' cannot be accessed here\n    c.area = 30               // Error, private 'area' cannot be accessed here\n}"}
{"text": "Cangjie programming language syntax:\nInside classes, the `This` type placeholder is supported, representing the type of the current class. It can only be used as the return type of instance member functions. When a subclass object calls a function defined in the superclass that returns `This` type, the type of the function call is recognized as the subclass type, not the type of the superclass where it is defined.\nIf an instance member function does not declare a return type and only contains expressions returning `This` type, the return type of the current function will be inferred as `This`. For example:open class C1 {\n    func f(): This {  // its type is `() -> C1`\n        return this\n    }\n\n\n    func f2() { // its type is `() -> C1`\n        return this\n    }\n\n\n    public open func f3(): C1 {\n        return this\n    }\n}\nclass C2 <: C1 {\n    // member function f is inherited from C1, and its type is `() -> C2` now\n    public override func f3(): This { // Ok\n        return this\n    }\n}\n\n\nvar obj1: C2 = C2()\nvar obj2: C1 = C2()\n\n\nvar x = obj1.f()    // During compilation, the type of x is C2\nvar y = obj2.f()    // During compilation, the type of y is C1"}
{"text": "Cangjie programming language syntax:\nAfter defining the class type, objects can be created by calling its constructor (by calling the constructor with the class type name). For example, in the following example, a Rectangle object of type Rectangle is created by Rectangle(10, 20) and assigned to the variable r.let r = Rectangle(10, 20)"}
{"text": "Cangjie programming language syntax:\nAfter defining the class type, objects can be created by calling its constructor (by calling the constructor with the class type name). \nAfter creating an object, instance member variables and instance member functions (publicly accessible) can be accessed through the object. For example, in the following example, r.width and r.height can be used to access the values of width and height in r, respectively, and r.area() can be used to call the member function area.let r = Rectangle(10, 20) // r.width = 10, r.height = 20\nlet width = r.width       // width = 10\nlet height = r.height     // height = 20\nlet a = r.area()          // a = 200"}
{"text": "Cangjie programming language syntax:\nAfter defining the class type, objects can be created by calling its constructor (by calling the constructor with the class type name). \nAfter creating an object, instance member variables and instance member functions (publicly accessible) can be accessed through the object. \nIf you want to modify the values of member variables through the object (this method is not encouraged; it is better to modify them through member functions), the member variables in the class type need to be defined as mutable member variables (i.e., using var). Here is an example:class Rectangle {\n    public var width: Int64\n    public var height: Int64\n\n\n    ...\n}\n\n\nmain() {\n    let r = Rectangle(10, 20) // r.width = 10, r.height = 20\n    r.width = 8               // r.width = 8\n    r.height = 24             // r.height = 24\n    let a = r.area()          // a = 192\n}"}
{"text": "Cangjie programming language syntax:\nUnlike structs, class objects do not get copied when assigned or passed as parameters; multiple variables point to the same object. Modifying a member's value through one variable will also modify the corresponding member variable in other variables. Taking assignment as an example, in the following example, after assigning r1 to r2, changing the width and height of r1 will also change the width and height of r2.main() {\n    var r1 = Rectangle(10, 20) // r1.width = 10, r1.height = 20\n    var r2 = r1                // r2.width = 10, r2.height = 20\n    r1.width = 8               // r1.width = 8\n    r1.height = 24             // r1.height = 24\n    let a1 = r1.area()         // a1 = 192\n    let a2 = r2.area()         // a2 = 192\n}"}
{"text": "Cangjie programming language syntax:\nLike most programming languages that support classes, the class in Cangjie also supports inheritance. If class B inherits from class A, then A is called the parent class, and B is the child class. The child class will inherit all members of the parent class except private members and constructors.\nAbstract classes are always inheritable, so the open modifier when defining an abstract class is optional. You can also use the sealed modifier to decorate an abstract class, indicating that the abstract class can only be inherited within this package. However, non-abstract classes can be inherited under certain conditions: the open modifier must be used when defining them. When an instance member with the open modifier is inherited by a class, the open modifier is also inherited. When a non-open class contains open members, the compiler will issue a warning.\nIt is possible to specify the parent class it inherits from at the subclass definition using <: , but it requires the parent class to be inheritable. For example, in the following example, class A uses the open modifier and can be inherited by class B, but since class B is not inheritable, there will be an error when C inherits B.open class A {\n    let a: Int64 = 10\n}\n\n\nclass B <: A { // Ok: 'B' Inheritance 'A'\n    let b: Int64 = 20\n}\n\n\nclass C <: B { // Error, 'B' is not inheritable\n    let c: Int64 = 30\n}"}
{"text": "Cangjie programming language syntax:\nThe class only supports single inheritance, so the following code where a class inherits from two classes is not valid.(& is the syntax for a class implementing multiple interfaces)open class A {\n    let a: Int64 = 10\n}\n\n\nopen class B {\n    let b: Int64 = 20\n}\n\n\nclass C <: A & B { // Error, 'C' can only inherit one class\n    let c: Int64 = 30\n}"}
{"text": "Cangjie programming language syntax:\nBecause classes support single inheritance, any class can have at most one direct parent class. For a class that specifies a parent class at definition time, its direct parent class is the class specified at definition time. For a class that does not specify a parent class at definition time, its direct parent class is the Object type. Object is the parent class of all classes (note that Object has no direct parent class and does not contain any members).\nSince subclasses inherit from parent classes, objects of a subclass can naturally be used as objects of the parent class, but the reverse is not true. For example, in the following case, B is a subclass of A, so objects of type B can be assigned to variables of type A, but objects of type A cannot be assigned to variables of type B.\n Types defined by class do not allow inheritance of the type itself.open class A {\n    let a: Int64 = 10\n}\n\n\nclass B <: A {\n    let b: Int64 = 20\n}\n\n\nlet a: A = B() // Ok: subclass objects can be assigned to superclass variables\nclass A <: A {}  // Error, 'A' inherits itself."}
{"text": "Cangjie programming language syntax:\nAbstract classes can use the sealed modifier, indicating that the class being modified can only be inherited by other classes within the package where the definition resides. sealed already implies the public/open semantics, so if you provide the public/open modifier when defining a sealed abstract class, the compiler will issue a warning. A subclass of a sealed class does not have to be a sealed class itself and can still be open/sealed or have no inheritance modifiers. If the subclass of a sealed class is open, its subclasses can be inherited outside the package. A subclass of a sealed class does not have to be public.package A\npublic sealed abstract class C1 {}   // Warning, redundant modifier, 'sealed' implies 'public'\nsealed open abstract class C2 {}     // Warning, redundant modifier, 'sealed' implies 'open'\nsealed abstract class C3 {}          // OK, 'public' is optional when 'sealed' is used\nclass S1 <: C1 {}  // OK\npublic open class S2 <: C1 {}   // OK\npublic sealed abstract class S3 <: C1 {}  // OK\nopen class S4 <: C1 {}   // OK\n\npackage B\nimport A.*\nclass SS1 <: S2 {}  // OK\nclass SS2 <: S3 {}  // Error, S3 is sealed class, cannot be inherited here.\nsealed class SS3 {} // Error, 'sealed' cannot be used on non-abstract class."}
{"text": "Cangjie programming language syntax:\nA subclass's init constructor can call the parent class constructor using super(args) or call other constructors of the current class using this(args), but only one of the two can be called. If called, it must be at the first expression in the constructor body, and there can be no expressions or declarations before it.open class A {\n    A(let a: Int64) {}\n}\n\n\nclass B <: A {\n    let b: Int64\n    init(b: Int64) {\n        super(30)\n        this.b = b\n    }\n\n\n    init() {\n        this(20)\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn the subclass's primary constructor, you can use super(args) to call the parent class constructor, but you cannot use this(args) to call other constructors in the current class.\nIf the subclass constructor does not explicitly call the parent class constructor or any other constructor, the compiler will insert a call to the direct parent class's parameterless constructor at the beginning of the constructor body. If the parent class does not have a parameterless constructor at this point, a compilation error will occur.open class A {\n    let a: Int64\n    init() {\n        a = 100\n    }\n}\n\n\nopen class B <: A {\n    let b: Int64\n    init(b: Int64) {\n        // OK, `super()` added by compiler\n        this.b = b\n    }\n}\n\n\nopen class C <: B {\n    let c: Int64\n    init(c: Int64) {  // Error, there is no non-parameter constructor in super class\n        this.c = c\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn subclasses, you can override (override) the same non-abstract instance member functions of the parent class, which means defining a new implementation of a certain instance member function of the parent class in the subclass. When overriding, the member function in the parent class must use the open modifier, and the same-named function in the subclass must use override, where override is optional. For example, in the following example, the function f in subclass B overrides the function f in parent class A.For overridden functions, the version to be called is determined based on the runtime type of the variable (determined by the actual object assigned to the variable) (i.e., what is known as dynamic dispatch). For example, in the previous example, the runtime type of a is A, so a.f() calls the function f in the parent class A; the runtime type of b is B (the compile-time type is A), so b.f() calls the function f in the child class B.open class A {\n    public open func f(): Unit {\n        println(\"I am superclass\")\n    }\n}\n\n\nclass B <: A {\n    public override func f(): Unit {\n        println(\"I am subclass\")\n    }\n}\n\n\nmain() {\n    let a: A = A()\n    let b: A = B()\n    a.f()\n    b.f()\n}"}
{"text": "Cangjie programming language syntax:\nFor static functions, subclasses can redefine non-abstract static functions with the same name in the parent class, which means defining a new implementation for a static function in the parent class within the subclass. When redefining, the static function in the subclass must use the redef modifier, where redef is optional. For example, in the following example, the function foo in subclass D redefines the function foo in the parent class C.For overridden functions, the version called is determined by the class type at the time of invocation. For example, in the example, C.foo() calls the foo function from the parent class C, and D.foo() calls the foo function from the child class D.open class C {\n    public static func foo(): Unit {\n        println(\"I am class C\")\n    }\n}\n\n\nclass D <: C {\n    public redef static func foo(): Unit {\n        println(\"I am class D\")\n    }\n}\n\n\nmain() {\n    C.foo()\n    D.foo()\n}"}
{"text": "Cangjie programming language syntax:\nIf an abstract function or an open-modified function has named formal parameters, then the implementing function or the override-modified function must also maintain the same named formal parameters.open class A {\n    public open func f(a!: Int32): Int32 {\n        a + 1\n    }\n}\n\n\nclass B <: A {\n    public override func f(a!: Int32): Int32 { // Ok\n        a + 2\n    }\n}\n\n\nclass C <: A {\n    public override func f(b!: Int32): Int32 { // Error\n        b + 3\n    }\n}\n\n\nmain() {\n    B().f(a: 0)\n    C().f(b: 0)\n}"}
{"text": "Cangjie programming language syntax:\nIt should also be noted that when implementing or redefining a function as a static generic function, the type parameter constraints of the subtype function need to be looser or the same as those of the corresponding function in the parent type.open class A {}\nopen class B <: A {}\nopen class C <: B {}\n\n\nopen class Base {\n    static func f<T>(a: T): Unit where T <: B {}\n    static func g<T>(): Unit where T <: B {}\n}\n\n\nclass D <: Base {\n    redef static func f<T>(a: T): Unit where T <: C {} // Error, stricter constraint\n    redef static func g<T>(): Unit where T <: C {} // Error, stricter constraint\n}\n\n\nclass E <: Base {\n    redef static func f<T>(a: T): Unit where T <: A {} // OK: looser constraint\n    redef static func g<T>(): Unit where T <: A {} // OK: looser constraint\n}\n\n\nclass F <: Base {\n    redef static func f<T>(a: T): Unit where T <: B {} // OK: same constraint\n    redef static func g<T>(): Unit where T <: B {} // OK: same constraint\n}"}
{"text": "Cangjie programming language syntax:\nAn interface is used to define an abstract type, which does not contain data but can define the behavior of a type. A type that declares it implements an interface and implements all its members is said to have implemented that interface.\nThe members of an interface can include: Member functions、Operator Overload Function、Member Attributes\nThese members are abstract, requiring the implementing type to have corresponding member implementations."}
{"text": "Cangjie programming language syntax:\nAn interface is declared using the keyword interface, followed by the interface identifier I and the interface members. Interface members can be modified by the open modifier, and the open modifier is optional.\nA simple interface definition is as follows:interface I { // 'open' modifier is optional.\n    func f(): Unit\n}"}
{"text": "Cangjie programming language syntax:\nAn interface is declared using the keyword interface, followed by the interface identifier I and the interface members. Interface members can be modified by the open modifier, and the open modifier is optional.\nAfter interface I declares a member function f, when implementing I for a type, a corresponding f function must be implemented in that type.\nSince interface has open semantics by default, the open modifier in interface definition is optional.\nAs shown in the following code, a class Foo is defined, and Foo is declared to implement the I interface using the form Foo <: I.\nIn Foo, all members declared in I must be implemented, meaning a field of the same type f needs to be defined, otherwise, a compilation error will occur due to the lack of interface implementation.When a type implements an interface, that type becomes a subtype of that interface.For the example, Foo is a subtype of I, so any instance of type Foo can be used as an instance of type I.class Foo <: I {\n    public func f(): Unit {\n        println(\"Foo\")\n    }\n}\n\n\nmain() {\n    let a = Foo()\n    let b: I = a\n    b.f() // \"Foo\"\n}"}
{"text": "Cangjie programming language syntax:\nAn `interface` can also use the `sealed` modifier to indicate that the interface can only be inherited, implemented, or extended within the package where the interface is defined. `sealed` already implies the semantics of `public/open`, so if you provide the `public/open` modifier when defining a `sealed` interface, the compiler will issue a warning. Subinterfaces that inherit a `sealed` interface or abstract classes that implement a `sealed` interface can still be `sealed` or not use the `sealed` modifier. If a subinterface of a `sealed` interface is `public` and not `sealed`, then it can be inherited, implemented, or extended outside the package. Types that inherit or implement a `sealed` interface do not need to be `public`.package A\npublic interface I1 {}\nsealed interface I2 {}         // OK\npublic sealed interface I3 {}  // Warning, redundant modifier, 'sealed' implies 'public'\nsealed open interface I4 {}    // Warning, redundant modifier, 'sealed' implies 'open'\n\n\nclass C1 <: I1 {}\npublic open class C2 <: I1 {}\nsealed abstract class C3 <: I2 {}\nextend Int64 <: I2 {}\n\npackage B\nimport A.*\n\n\nclass S1 <: I1 {}  // OK\nclass S2 <: I2 {}  // Error, I2 is sealed interface, cannot be inherited here."}
{"text": "Cangjie programming language syntax:\nThrough this constraint of interfaces, you can agree on common functionalities for a series of types, achieving the purpose of abstracting functionality.\nFor example, the following code can define a `Flyable` interface and allow other classes with the `Flyable` attribute to implement it.interface Flyable {\n    func fly(): Unit\n}\n\n\nclass Bird <: Flyable {\n    public func fly(): Unit {\n        println(\"Bird flying\")\n    }\n}\n\n\nclass Bat <: Flyable {\n    public func fly(): Unit {\n        println(\"Bat flying\")\n    }\n}\n\n\nclass Airplane <: Flyable {\n    public func fly(): Unit {\n        println(\"Airplane flying\")\n    }\n}\n\n\nfunc fly(item: Flyable): Unit {\n    item.fly()\n}\n\n\nmain() {\n    let bird = Bird()\n    let bat = Bat()\n    let airplane = Airplane()\n    fly(bird)\n    fly(bat)\n    fly(airplane)\n}"}
{"text": "Cangjie programming language syntax:\nMembers of an interface can be instance or static, the role of instance member functions has been demonstrated in the examples above, let's take a look at the role of static member functions next.\n\nStatic member functions are similar to instance member functions, both requiring the implementing type to provide the implementation.\n\nFor example, the following example defines a NamedType interface, which contains a static member function typename to obtain the string name of each type.\n\nIn this way, other types must implement the typename function when implementing the NamedType interface, after which they can safely obtain the type name on subtypes of NamedType.interface NamedType {\n    static func typename(): String\n}\n\n\nclass A <: NamedType {\n    public static func typename(): String {\n        \"A\"\n    }\n}\n\n\nclass B <: NamedType {\n    public static func typename(): String {\n        \"B\"\n    }\n}\n\n\nmain() {\n    println(\"the type is ${ A.typename() }\")\n    println(\"the type is ${ B.typename() }\")\n}"}
{"text": "Cangjie programming language syntax:\nStatic member functions (or properties) in an interface can either have no default implementation or have a default implementation.\n\nWhen it does not have a default implementation, it cannot be accessed through the interface type name. For example, in the following code, directly accessing the typename function of NamedType will result in a compilation error because NamedType does not have an implementation of the typename function.main() {\n    NamedType.typename() // Error\n}"}
{"text": "Cangjie programming language syntax:\nStatic member functions (or properties) in an interface can either have no default implementation or have a default implementation.\nStatic member functions (or properties) in an interface can also have default implementations. When another type inherits from an interface that has default static functions (or properties) implementations, that type does not need to implement this static member function (or property) anymore. The function (or property) can be accessed directly through the interface name and the type name. For example, the member function `typename` in `NamedType` has a default implementation, and it does not need to be re-implemented in `A` either. Additionally, it can be accessed directly through the interface name and the type name.interface NamedType {\n    static func typename(): String {\n        \"interface NamedType\"\n    }\n}\n\nclass A <: NamedType {}\n\nmain() {\n    println(NamedType.typename())\n    println(A.typename())\n    0\n}"}
{"text": "Cangjie programming language syntax:\nStatic member functions (or properties) in an interface can also have default implementations. When another type inherits from an interface that has default static functions (or properties) implementations, that type does not need to implement this static member function (or property) anymore. The function (or property) can be accessed directly through the interface name and the type name. For example, the member function `typename` in `NamedType` has a default implementation, and it does not need to be re-implemented in `A` either. Additionally, it can be accessed directly through the interface name and the type name.\nTypically, such static members are used in generic functions through generic constraints.For example, in the printTypeName function below, when the generic parameter T is constrained to be a subclass of NamedType, it must ensure that all static member functions (or properties) in the instantiated type of T have implementations, so that T.typename can be used to access the implementation of the generic parameter, achieving the purpose of abstracting static members. See the Generic section for details.interface NamedType {\n    static func typename(): String\n}\n\n\ninterface I <: NamedType {\n    static func typename(): String {\n        f()\n    }\n    static func f(): String\n}\n\n\nclass A <: NamedType {\n    public static func typename(): String {\n        \"A\"\n    }\n}\n\n\nclass B <: NamedType {\n    public static func typename(): String {\n        \"B\"\n    }\n}\n\n\nfunc printTypeName<T>() where T <: NamedType {\n    println(\"the type is ${ T.typename() }\")\n}\n\n\nmain() {\n    printTypeName<A>() // Ok\n    printTypeName<B>() // Ok\n    printTypeName<I>() // Error, 'I' must implement all static function. Otherwise, an unimplemented 'f' is called, causing problems.\n}"}
{"text": "Cangjie programming language syntax:\nIt should be noted that members of an interface are default public and cannot declare additional access control modifiers, and it is also required that the implementing type must be implemented as public.\n\nError_case:\ninterface I {\n    func f(): Unit\n}\n\n\nopen class C <: I {\n    protected func f() {} // Compiler Error, f needs to be public semantics\n}"}
{"text": "Cangjie programming language syntax:\nWhen you want to implement multiple interfaces for a type, you can use the & symbol to separate multiple interfaces at the declaration point. There is no order requirement between the interfaces being implemented.\nFor example, in the following example, you can make MyInt implement both Addable and Subtractable interfaces.interface Addable {\n    func add(other: Int64): Int64\n}\n\n\ninterface Subtractable {\n    func sub(other: Int64): Int64\n}\n\n\nclass MyInt <: Addable & Subtractable {\n    var value = 0\n    public func add(other: Int64): Int64 {\n        value + other\n    }\n    public func sub(other: Int64): Int64 {\n        value - other\n    }\n}"}
{"text": "Cangjie programming language syntax:\nAn interface can inherit one or more interfaces but cannot inherit a class. At the same time, when inheriting an interface, new interface members can be added.\nFor example, in the following example, the Calculable interface inherits two interfaces, Addable and Subtractable, and adds two operator overloads for multiplication and division.interface Addable {\n    func add(other: Int64): Int64\n}\n\n\ninterface Subtractable {\n    func sub(other: Int64): Int64\n}\n\n\ninterface Calculable <: Addable & Subtractable {\n    func mul(other: Int64): Int64\n    func div(other: Int64): Int64\n}"}
{"text": "Cangjie programming language syntax:\nAn interface can inherit one or more interfaces but cannot inherit a class. At the same time, when inheriting an interface, new interface members can be added.\nWhen implementing the Calculable interface, you must implement all four arithmetic operator overloads—addition, subtraction, multiplication, and division—at the same time; none of the members can be missing.class MyInt <: Calculable {\n    var value = 0\n    public func add(other: Int64): Int64 {\n        value + other\n    }\n    public func sub(other: Int64): Int64 {\n        value - other\n    }\n    public func mul(other: Int64): Int64 {\n        value * other\n    }\n    public func div(other: Int64): Int64 {\n        value / other\n    }\n}"}
{"text": "Cangjie programming language syntax:\nFor interface inheritance, if a child interface inherits a function or property with a default implementation from a parent interface, it is not allowed to only declare this function or property in the child interface (i.e., without a default implementation). Instead, a new default implementation must be provided, and the override modifier (or redef modifier) before the function definition is optional. If a child interface inherits a function or property without a default implementation from a parent interface, it is allowed to only declare this function or property in the child interface (of course, it is also allowed to define a default implementation), and the override modifier (or redef modifier) before the function declaration or definition is optional.interface I1 {\n   func f(a: Int64) {\n        a\n   }\n   static func g(a: Int64) {\n        a\n   }\n   func f1(a: Int64): Unit\n   static func g1(a: Int64): Unit\n}\n\n\ninterface I2 <: I1 {\n    /*'override' is optional*/ func f(a: Int64) {\n       a + 1\n    }\n    override func f(a: Int32) {} // Error, override function 'f' does not have an overridden function from its supertypes\n    static /*'redef' is optional*/ func g(a: Int64) {\n       a + 1\n    }\n    /*'override' is optional*/ func f1(a: Int64): Unit {}\n    static /*'redef' is optional*/ func g1(a: Int64): Unit {}\n}"}
{"text": "Cangjie programming language syntax:\nThe Xiange language allows all types except Tuples, VArrays, and functions to implement interfaces.\n\nThere are three ways for a type to implement an interface:\n1.Declare the implementation of the interface when defining the type, as seen in the examples above.\n2.Implement interfaces through extension, which is detailed in the Extension chapter.\n3.Implemented by the language internally; see the relevant documentation in the \"Cangjie Programming Language Library API\".\nWhen implementing an interface for a type declaration, all members required by the interface must be implemented, which requires adhering to the following rules.\n\nFor member functions and operator overload functions, the implementation provided by the type must have the same function name, parameter list, and return type as the corresponding functions in the interface.\nFor member attributes, the mut modifier must be consistent, and the attribute types must be the same.\nSo in most cases, as in the examples above, it is necessary to implement members in the implementing type that match the members required by the interface.\n\nHowever, there is an exception: if the return type of a member function or operator overload function in the interface is a class type, then it is allowed for the implementing function to have a return type that is a subclass of it.\n\nFor example, in the example below, the return type of f in I is a class type Base, so the return type of f implemented in C can be a subclass of Base, Sub.open class Base {}\nclass Sub <: Base {}\n\n\ninterface I {\n    func f(): Base\n}\n\n\nclass C <: I {\n    public func f(): Sub {\n        Sub()\n    }\n}"}
{"text": "Cangjie programming language syntax:\nInterface members can also provide default implementations. For example, in the following code, the `say` method in `SayHi` has a default implementation, so when `A` implements `SayHi`, it can inherit the `say` implementation, and `B` can also choose to provide its own `say` implementation.interface SayHi {\n    func say() {\n        \"hi\"\n    }\n}\n\n\nclass A <: SayHi {}\n\n\nclass B <: SayHi {\n    public func say() {\n        \"hi, B\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nSpecifically, when a type implements multiple interfaces and multiple interfaces contain default implementations of the same member, a conflict in multiple inheritance occurs. The language cannot select the most suitable implementation, so in this case, the default implementation in the interface also becomes ineffective, requiring the implementing type to provide its own implementation.\n\nFor example, in the following example, both SayHi and SayHello contain the implementation of say. When Foo implements these two interfaces, it must provide its own implementation, otherwise a compilation error will occur.interface SayHi {\n    func say() {\n        \"hi\"\n    }\n}\n\n\ninterface SayHello {\n    func say() {\n        \"hello\"\n    }\n}\n\n\nclass Foo <: SayHi & SayHello {\n    public func say() {\n        \"Foo\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn implementing interfaces, the override modifier (or redef modifier) before function or property definitions is optional, regardless of whether the interface functions or properties have default implementations.interface I {\n    func foo(): Int64 {\n        return 0\n    }\n}\nenum E <: I{\n    elem\n    public override func foo(): Int64 {\n        return 1\n    }\n}\nstruct S <: I {\n    public override func foo(): Int64 {\n        return 1\n    }\n}"}
{"text": "Cangjie programming language syntax:\nAny type is a built-in interface, defined as follows.interface Any {}"}
{"text": "Cangjie programming language syntax:\nAll interfaces in Falcon inherit it by default, and all non-interface types implement it by default, so all types can be used as subtypes of Any type.\nAs shown in the following code, a series of variables of different types can be assigned to variables of Any type.main() {\n    var any: Any = 1\n    any = 2.0\n    any = \"hello, world!\"\n}"}
{"text": "Cangjie programming language syntax:\nProperties provide a getter and an optional setter to indirectly get and set values.\n\nWhen using properties, it is no different from using regular variables; you only need to operate on the data, without being aware of the internal implementation, which can more conveniently implement access control, data monitoring, tracking debugging, data binding, and other mechanisms.\n\nProperties can be used as expressions or assigned values when in use. Here, an example is given for classes and interfaces, but properties are not limited to classes and interfaces.\n\nHere is a simple example, where b is a typical property that encapsulates external access to a. Here Foo provides an attribute named b, for the getter/setter functionality, Jaeger provides get and set syntaxes to define. When a variable x of type Foo accesses b, it calls the get operation of b to return a value of type Int64, so it can be used to add 1 to it; and when x assigns to b, it calls the set operation of b, passing the value of y to the set's value, ultimately assigning the value of value to a.class Foo {\n    private var a = 0\n\n\n    public mut prop b: Int64 {\n        get() {\n            println(\"get\")\n            a\n        }\n        set(value) {\n            println(\"set\")\n            a = value\n        }\n    }\n}\n\n\nmain() {\n    var x = Foo()\n    let y = x.b + 1 // get\n    x.b = y // set\n}"}
{"text": "Cangjie programming language syntax:\nAttributes can be defined in interface, class, struct, enum, extend.\nFor numeric, tuple, function, Bool, Unit, Nothing, String, Range, and enum types, mut-modified properties cannot be declared in their extensions or declarations, nor can interfaces with mut properties be implemented.\nA typical property syntax structure is as follows,where a and b declared using prop are both properties, and the types of a and b are both Int64. a is an attribute without the mut modifier, such attributes have and only have a defined getter (corresponding to value retrieval). b is an attribute with the mut modifier, such attributes must define both a getter (corresponding to value retrieval) and a setter (corresponding to value assignment).class Foo {\n    public prop a: Int64 {\n        get() { 0 }\n    }\n    public mut prop b: Int64 {\n        get() { 0 }\n        set(v) {}\n    }\n}"}
{"text": "Cangjie programming language syntax:\nThe getter and setter of a property correspond to two different functions.\n1.The getter function type is () -> T, where T is the type of the property. When the property is used as an expression, the getter function is executed.\n2.The setter function type is (T) -> Unit, where T is the type of the property. The parameter name must be explicitly specified. When assigning a value to the property, the setter function is executed.\nThe implementation of getters and setters can include declarations and expressions, just like the function body. The rules are the same as those for function bodies, see the Function Body chapter for details.It should be noted that accessing an attribute within its own getter and setter constitutes recursive invocation, and like function calls, it may lead to dead loops.\nThe parameter in the setter corresponds to the value passed when assigning.class Foo {\n    private var j = 0\n    public mut prop i: Int64 {\n        get() {\n            j\n        }\n        set(v) {\n            j = v\n        }\n    }\n}"}
{"text": "Cangjie programming language syntax:\nModifiers can be declared before prop.class Foo {\n    public prop a: Int64 {\n        get() {\n            0\n        }\n    }\n    private prop b: Int64 {\n        get() {\n            0\n        }\n    }\n}"}
{"text": "Cangjie programming language syntax:\nLike member functions, member properties also support open, override, and redef modifiers, so they can also be overridden or redefined in subclasses to implement the properties of parent types.\n\nWhen a subtype overrides a parent type's attribute, if the parent type attribute has a mut modifier, the subtype attribute must also have a mut modifier and must maintain the same type.\n\nAs shown in the following code, x and y are defined as two attributes in A, and B can override/redefine x and y respectivelyopen class A {\n    private var valueX = 0\n    private static var valueY = 0\n\n\n    public open prop x: Int64 {\n        get() { valueX }\n    }\n\n\n    public static mut prop y: Int64 {\n        get() { valueY }\n        set(v) {\n            valueY = v\n        }\n    }\n}\nclass B <: A {\n    private var valueX2 = 0\n    private static var valueY2 = 0\n\n\n    public override prop x: Int64 {\n        get() { valueX2 }\n    }\n\n\n    public redef static mut prop y: Int64 {\n        get() { valueY2 }\n        set(v) {\n            valueY2 = v\n        }\n    }\n}"}
{"text": "Cangjie programming language syntax:\nSimilar to abstract functions, abstract attributes can also be declared in interface and abstract class, and these abstract attributes do not have implementations.interface I {\n    prop a: Int64\n}\n\n\nabstract class C {\n    public prop a: Int64\n}"}
{"text": "Cangjie programming language syntax:\nWhen a type implements an interface or a non-abstract subclass inherits an abstract class, it must implement these abstract attributes.\n\nJust like the rules for overriding, when implementing these attributes, if the parent type attribute has a mut modifier, the subclass attribute must also have a mut modifier, and must also maintain the same type.interface I {\n    prop a: Int64\n    mut prop b: Int64\n}\nclass C <: I {\n    private var value = 0\n\n\n    public prop a: Int64 {\n        get() { value }\n    }\n\n\n    public mut prop b: Int64 {\n        get() { value }\n        set(v) {\n            value = v\n        }\n    }\n}"}
{"text": "Cangjie programming language syntax:\nBy using abstract properties, interfaces and abstract classes can define some data operations in a more intuitive and user-friendly way, compared to using functions.\n\nAs shown in the following code, if you want to establish a convention for getting and setting a size value, using properties (I1) results in less code and is more in line with the intention of data operations compared to using functions (I2).interface I1 {\n    mut prop size: Int64\n}\n\n\ninterface I2 {\n    func getSize(): Int64\n    func setSize(value: Int64): Unit\n}\n\n\nclass C <: I1 & I2 {\n    private var mySize = 0\n\n\n    public mut prop size: Int64 {\n        get() {\n            mySize\n        }\n        set(value) {\n            mySize = value\n        }\n    }\n\n\n    public func getSize() {\n        mySize\n    }\n\n\n    public func setSize(value: Int64) {\n        mySize = value\n    }\n}\n\n\nmain() {\n    let a: I1 = C()\n    a.size = 5\n    println(a.size)\n\n\n    let b: I2 = C()\n    b.setSize(5)\n    println(b.getSize())\n}"}
{"text": "Cangjie programming language syntax:\nProperties are divided into instance member properties and static member properties. The usage of member properties is the same as that of member variables; see the Member Variables chapter for details.class A {\n    public prop x: Int64 {\n        get() {\n            123\n        }\n    }\n    public static prop y: Int64 {\n        get() {\n            321\n        }\n    }\n}\n\n\nmain() {\n    var a = A()\n    println(a.x) // 123\n    println(A.y) // 321\n}"}
{"text": "Cangjie programming language syntax:\nProperties without the `mut` modifier are similar to variables declared with `let` and cannot be reassigned.class A {\n    private let value = 0\n    public prop i: Int64 {\n        get() {\n            value\n        }\n    }\n}\n\n\nmain() {\n    var x = A()\n    println(x.i) // OK\n    x.i = 1 // Error\n}"}
{"text": "Cangjie programming language syntax:\nProperties with the mut modifier are similar to variables declared with var, as they can be both read and written.class A {\n    private var value: Int64 = 0\n    public mut prop i: Int64 {\n        get() {\n            value\n        }\n        set(v) {\n            value = v\n        }\n    }\n}\n\n\nmain() {\n    var x = A()\n    println(x.i) // OK\n    x.i = 1 // OK\n}"}
{"text": "Cangjie programming language syntax:\nLike other object-oriented languages, the Changjie language provides subtype relationships and subtype polymorphism. For example (not limited to the following use cases):\nIf the formal parameter of a function is of type T, then the actual type of the argument passed during the function call can be either T or a subtype of T (strictly speaking, subtypes of T already include T itself, the same applies here).\nIf the type of the variable on the left side of an assignment expression = is T, then the actual type of the expression on the right side of = can be either T or a subtype of T.\nIf the return type annotated by the user in the function definition is T, then the type of the function body (as well as the types of all return expressions within the function body) can be either T or a subtype of T."}
{"text": "Cangjie programming language syntax:\nAfter inheriting class, the subclass is a subtype of the superclass. In the code below, Sub is a subtype of Super.open class Super { }\nclass Sub <: Super { }"}
{"text": "Cangjie programming language syntax:\nAfter implementing an interface (including extended implementations), the type that implements the interface becomes a subtype of the interface. In the following code, I3 is a subtype of I1 and I2, C is a subtype of I1, and Int64 is a subtype of I2:interface I1 { }\ninterface I2 { }\n\ninterface I3 <: I1 & I2 { }\n\nclass C <: I1 { }\n\nextend Int64 <: I2 { }"}
{"text": "Cangjie programming language syntax:\nIt should be noted that some cross-extended type assignment scenarios after type downcasting (is or as) are not currently supported, and judgment failures may occur, as shown in the following example:// file1.cj\npackage p1\n\n\npublic class A{}\n\n\npublic func get(): Any {\n    return A()\n}\n\n\n//"}
{"text": "Cangjie programming language syntax:\n"}
{"text": "Cangjie programming language syntax:\nTuple types in the Changjie language also have subtype relationships. Intuitively, if every element type of a tuple t1 is a subtype of the corresponding position element type of another tuple t2, then the type of tuple t1 is also a subtype of the type of tuple t2. For example, in the following code, since C2 <: C1 and C4 <: C3, it also follows that (C2, C4) <: (C1, C3) and (C4, C2) <: (C3, C1).open class C1 { }\nclass C2 <: C1 { }\n\n\nopen class C3 { }\nclass C4 <: C3 { }\n\n\nlet t1: (C1, C3) = (C2(), C4()) // OK\nlet t2: (C3, C1) = (C4(), C2()) // OK"}
{"text": "Cangjie programming language syntax:\nIn the Cangjie language, functions are first-class citizens, and function types also have subtype relationships: Given two function types (U1) -> S2 and (U2) -> S1, if there exists a (U1) -> S2 that is a subtype of (U2) -> S1, then and only then U2 is a subtype of U1, and S2 is a subtype of S1 (note the order). For example, the following code defines two functions f : (U1) -> S2 and g : (U2) -> S1, and f's type is a subtype of g's type. Since f's type is a subtype of g, any place in the code where g is used can be replaced with f.For the above rules, the part S2 <: S1 is well understood: the result data generated by function calls will be used by subsequent programs. Function g can generate result data of type S1, function f can generate result data of type S2, and the result data generated by g should be able to replace the result data generated by f, therefore requiring S2 <: S1.\n\nFor the part of U2 <: U1, it can be understood as follows: Before a function call produces a result, it should be callable itself. The actual parameter type of a function call remains fixed, and even when the formal parameter type is more lenient, it can still be called. However, when the formal parameter type is more strict, it may not be callable—for example, in the code above, g(U2()) can be replaced with f(U2()), precisely because the actual parameter type U2 is stricter than the formal parameter type U1.open class U1 { }\nclass U2 <: U1 { }\n\n\nopen class S1 { }\nclass S2 <: S1 { }\n\n\n\n\nfunc f(a: U1): S2 { S2() }\nfunc g(a: U2): S1 { S1() }\n\n\nfunc call1() {\n    g(U2()) // Ok.\n    f(U2()) // Ok.\n}\n\n\nfunc h(lam: (U2) -> S1): S1 {\n    lam(U2())\n}\n\n\nfunc call2() {\n    h(g) // Ok.\n    h(f) // Ok.\n}"}
{"text": "Cangjie programming language syntax:\nIn the Cangjie language, some predefined subtype relationships always hold:\nA type T is always a subtype of itself, i.e., T <: T.\nNothing type is always a subtype of any type T, i.e., Nothing <: T.\nAny type T is a subtype of the Any type, i.e., T <: Any.\nAny type defined by class is a subtype of Object, i.e., if there is a class C {}, then C <: Object."}
{"text": "Cangjie programming language syntax:\nSubtype relationships are transitive. In the following code, although only I2 <: I1, C <: I2, and Bool <: I2 are described, based on the transitivity of subtypes, the subtype relationships C <: I1 and Bool <: I1 also implicitly exist.interface I1 { }\ninterface I2 <: I1 { }\n\nclass C <: I2 { }\n\nextend Bool <: I2 { }"}
{"text": "Cangjie programming language syntax:\nChenxie does not support implicit conversion between different types (subtypes are naturally parent types, so the conversion from a subtype to a parent type is not an implicit type conversion), type conversion must be done explicitly. The following will introduce the conversion between numeric types, Rune to UInt32 and integer types to Rune, as well as the is and as operators.\nFor numeric types (including: Int8, Int16, Int32, Int64, IntNative, UInt8, UInt16, UInt32, UInt64, UIntNative, Float16, Float32, Float64), Cangjie supports obtaining a value equal to e with type T using T(e). Here, the type of expression e and T can be any of the above numeric types.\nThe following examples show type conversions between numeric types:main() {\n    let a: Int8 = 10\n    let b: Int16 = 20\n    let r1 = Int16(a)\n    println(\"The type of r1 is 'Int16', and r1 = ${r1}\")\n    let r2 = Int8(b)\n    println(\"The type of r2 is 'Int8', and r2 = ${r2}\")\n\n\n    let c: Float32 = 1.0\n    let d: Float64 = 1.123456789\n    let r3 = Float64(c)\n    println(\"The type of r3 is 'Float64', and r3 = ${r3}\")\n    let r4 = Float32(d)\n    println(\"The type of r4 is 'Float32', and r4 = ${r4}\")\n\n\n    let e: Int64 = 1024\n    let f: Float64 = 1024.1024\n    let r5 = Float64(e)\n    println(\"The type of r5 is 'Float64', and r5 = ${r5}\")\n    let r6 = Int64(f)\n    println(\"The type of r6 is 'Int64', and r6 = ${r6}\")\n}"}
{"text": "Cangjie programming language syntax:\nThe conversion from Rune to UInt32 is done using the form UInt32(e), where e is an expression of type Rune. The result of UInt32(e) is the UInt32 type integer value corresponding to the Unicode scalar value of e.\n\nThe conversion from integer types to Rune is done using the form Rune(num), where num can be of any integer type. It returns the corresponding Unicode scalar value character only if the value of num falls within [0x0000, 0xD7FF] or [0xE000, 0x10FFFF] (i.e., Unicode scalar value). Otherwise, it results in a compilation error (the value of num can be determined at compile time) or a runtime exception.\n\nThe following examples demonstrate type conversions between Rune and UInt32:main() {\n    let x: Rune = 'a'\n    let y: UInt32 = 65\n    let r1 = UInt32(x)\n    let r2 = Rune(y)\n    println(\"The type of r1 is 'UInt32', and r1 = ${r1}\")\n    println(\"The type of r2 is 'Rune', and r2 = ${r2}\")\n}"}
{"text": "Cangjie programming language syntax:\nCangjie supports using the is operator to determine whether an expression is of a specified type (or its subtype). Specifically, for an expression e is T (where e can be any expression and T can be any type), if the runtime type of e is a subtype of T, then e is T evaluates to true; otherwise, it evaluates to false.\nThe following examples demonstrate the use of the is operator:open class Base {\n    var name: String = \"Alice\"\n}\nclass Derived <: Base {\n    var age: UInt8 = 18\n}\n\n\nmain() {\n    let a = 1 is Int64\n    println(\"Is the type of 1 'Int64'? ${a}\")\n    let b = 1 is String\n    println(\"Is the type of 1 'String'? ${b}\")\n\n\n    let b1: Base = Base()\n    let b2: Base = Derived()\n    var x = b1 is Base\n    println(\"Is the type of b1 'Base'? ${x}\")\n    x = b1 is Derived\n    println(\"Is the type of b1 'Derived'? ${x}\")\n    x = b2 is Base\n    println(\"Is the type of b2 'Base'? ${x}\")\n    x = b2 is Derived\n    println(\"Is the type of b2 'Derived'? ${x}\")\n}"}
{"text": "Cangjie programming language syntax:\nThe as operator can be used to convert the type of an expression to a specified type. Because type conversion may fail, the as operator returns an Option type. Specifically, for an expression e as T (where e can be any expression and T can be any type), when the runtime type of e is a subtype of T, the value of e as T is Option<T>.Some(e), otherwise the value of e as T is Option<T>.None.\nThe following example demonstrates the use of the as operator (the result of the as operation is indicated in the comments):open class Base {\n    var name: String = \"Alice\"\n}\nclass Derived <: Base {\n    var age: UInt8 = 18\n}\n\n\nlet a = 1 as Int64     // a = Option<Int64>.Some(1)\nlet b = 1 as String    // b = Option<String>.None\n\n\nlet b1: Base = Base()\nlet b2: Base = Derived()\nlet d: Derived = Derived()\nlet r1 = b1 as Base    // r1 = Option<Base>.Some(b1)\nlet r2 = b1 as Derived // r2 = Option<Derived>.None\nlet r3 = b2 as Base    // r3 = Option<Base>.Some(b2)\nlet r4 = b2 as Derived // r4 = Option<Derived>.Some(b2)\nlet r5 = d as Base     // r5 = Option<Base>.Some(d)\nlet r6 = d as Derived  // r6 = Option<Derived>.Some(d)"}
