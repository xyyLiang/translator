{"text": "Cangjie programming language syntax:\nThis chapter introduces several commonly used basic Collection types in the Changjie language, including Array, ArrayList, HashSet, and HashMap.\n\n  You can choose the type suitable for your business in different scenarios:\n\n  Array: No need to add or delete elements, but need to modify elements\n  ArrayList: Need to frequently add, delete, query, and modify elements\n  HashSet: Hope each element is unique\n  HashMap: Wants to store a series of mapping relationships\n  The following table shows the basic characteristics of these types:\n\n  Type name\t  Elements are mutable\t  Add or remove elements\t  Element uniqueness\t  Ordered sequence\nArray<T>\tY\tN\tN\tY\nArrayList<T>\tY\tY\tN\tY\nHashSet<T>\tN\tY\tY\tN\nHashMap<K, V>\tK: N, V: Y\tY\tK: Y, V: N\tN"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\nCangjie uses ArrayList<T> to represent the ArrayList type, T to represent the element type of ArrayList, and T can be any type.\n\nArrayList has very good scaling capabilities, which is suitable for scenarios where elements need to be added and removed frequently.\n\nIn contrast to Array, ArrayList can modify elements in place, as well as add and remove elements in place.\n\nThe variability of ArrayList is a very useful feature that allows all references to the same ArrayList instance to share the same element and modify them uniformly.\n\nArrayLists with different element types are not the same types, so they can't assign values to each other.\n\nTherefore, the following example is not legitimate.var a: ArrayList<Int64> = ... // ArrayList whose element type is Int64\nvar b: ArrayList<String> = ... // ArrayList whose element type is String\n\nb = a // Type mismatch"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\n\nIn Cangjie, you can use a constructor to construct a specified ArrayList.let a = ArrayList<String>() // Created an empty ArrayList whose element type is String\nlet b = ArrayList<String>(100) // Created an ArrayList whose element type is String, and allocate a space of 100\nlet c = ArrayList<Int64>([0, 1, 2]) // Created an ArrayList whose element type is Int64, containing elements 0, 1, 2\nlet d = ArrayList<Int64>(c) // Use another Collection to initialize an ArrayList\nlet e = ArrayList<String>(2, {x: Int64 => x.toString()}) // Created an ArrayList whose element type is String and size is 2. All elements are initialized by specified rule function"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\nWhen you need access to all the elements of an ArrayList, you can use a for-in loop to iterate through all the elements of the ArrayList.import std.collection.*\n\n\nmain() {\n    let list = ArrayList<Int64>([0, 1, 2])\n    for (i in list) {\n        println(\"The element is ${i}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\nWhen you need to know the number of elements in an ArrayList, you can use the size attribute to get the corresponding information.import std.collection.*\n\n\nmain() {\n    let list = ArrayList<Int64>([0, 1, 2])\n    if (list.size == 0) {\n        println(\"This is an empty arraylist\")\n    } else {\n        println(\"The size of arraylist is ${list.size}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\nWhen you want to access an element in a single specified location, you can use the subscript syntax to access it (the subscript type must be Int64). The first element of a non-empty ArrayList always starts at position 0. You can access any element of the ArrayList from 0 up to the last position (size - 1 of the ArrayList). Using a negative number or an index greater than or equal to size triggers a runtime exception.let a = list[0] // a == 0\nlet b = list[1] // b == 1\nlet c = list[-1] // Runtime exceptions"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\n  You can use the subscript syntax to make changes to an element in a position.let list = ArrayList<Int64>([0, 1, 2])\nlist[0] = 3"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\nArrayList is a reference type, and when used as an expression, ArrayList does not copy copies, and all references to the same ArrayList instance share the same data.\n\nTherefore, modifications to the ArrayList element affect all references to that instance.let list1 = ArrayList<Int64>([0, 1, 2])\nlet list2 = list1\nlist2[0] = 3\n// list1 contains elements 3, 1, 2\n// list2 contains elements 3, 1, 2"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\nIf you need to add a single element to the end of the ArrayList, use the append function. If you want to add more than one element to the end at the same time, you can use the appendAll function, which accepts a Collection type (e.g. Array) of the same element type.import std.collection.*\n\n\nmain() {\n    let list = ArrayList<Int64>()\n    list.append(0) // list contains element 0\n    list.append(1) // list contains elements 0, 1\n    let li = [2, 3]\n    list.appendAll(li) // list contains elements 0, 1, 2, 3\n}"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\nYou can use the insert and insertAll functions to insert a specified single element or a Collection value of the same element type into the location of the specified index. The elements at the index and the elements behind them are moved back to make space.let list = ArrayList<Int64>([0, 1, 2]) // list contains elements 0, 1, 2\nlist.insert(1, 4) // list contains elements 0, 4, 1, 2"}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\nTo remove an element from an ArrayList, you can use the remove function, which requires you to specify the index to be removed. The elements behind the index are moved forward to fill the space.let list = ArrayList<String>([\"a\", \"b\", \"c\", \"d\"]) // list contains the elements \"a\", \"b\", \"c\", \"d\"\nlist.remove(1) // Delete the element at subscript 1, now the list contains elements \"a\", \"c\", \"d\""}
{"text": "Cangjie programming language syntax:\nTo use the ArrayList type, you need to import the collection package:import std.collection.*\nEach ArrayList requires a specific amount of memory to hold its contents. When an element is added to an ArrayList and that ArrayList starts to exceed its reserved capacity, the ArrayList allocates a larger memory area and copies all of its elements to the new memory. This growth strategy means that adding operations that trigger a reallocation of memory has a performance cost, but they occur less frequently as the reserved memory of the ArrayList grows.\n\nIf you know how many elements you need to add, you can improve performance by preparing enough memory before adding to avoid re-allocation.import std.collection.*\n\n\nmain() {\n    let list = ArrayList<Int64>(100) // Allocate space at once\n    for (i in 0..100) {\n        list.append(i) // Does not trigger reallocation of space\n    }\n    list.reserve(100) // Prepare more space\n    for (i in 0..100) {\n        list.append(i) // Does not trigger reallocation of space\n    }\n}"}
{"text": "Cangjie programming language syntax:\nUsing the HashSet type requires importing a collection package:\nimport std.collection.*\n\nYou can use the HashSet type to construct a Collection with only distinct elements.\nCangjie uses HashSet<T> to represent the HashSet type, T to represent the element type of the HashSet, and T must be a type that implements the Hashable and Equatable<T> interfaces, such as Numeric or String.\nHashSets with different element types are not the same types, so they can't be assigned to each other.import std.collection.*\nmain(){\n    var a: HashSet<Int64> = ... // HashSet whose element type is Int64\n    var b: HashSet<String> = ... // HashSet whose element type is String\n    b = a // Type mismatch\n}"}
{"text": "Cangjie programming language syntax:\nIn Cangjie, you can use a constructor to construct a specified HashSet.\nUsing the HashSet type requires importing a collection package:\nimport std.collection.*let a = HashSet<String>() // Created an empty HashSet whose element type is String\nlet b = HashSet<String>(100) // Created a HashSet whose capacity is 100\nlet c = HashSet<Int64>([0, 1, 2]) // Created a HashSet whose element type is Int64, containing elements 0, 1, 2\nlet d = HashSet<Int64>(c) // Use another Collection to initialize a HashSet\nlet e = HashSet<Int64>(10, {x: Int64 => (x * x)}) // Created a HashSet whose element type is Int64 and size is 10. All elements are initialized by specified rule function"}
{"text": "Cangjie programming language syntax:\nWhen you need to access all the elements of a HashSet, you can use a for-in loop to iterate through all the elements of the HashSet.\nIt is important to note that HashSets are not guaranteed to be in the order in which they are inserted, so the order of traversal and the order of insertion may be different.\nUsing the HashSet type requires importing a collection package:\nimport std.collection.*import std.collection.*\n\n\nmain() {\n    let mySet = HashSet<Int64>([0, 1, 2])\n    for (i in mySet) {\n        println(\"The element is ${i}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nWhen you need to know the number of elements in a hashset, you can use the size attribute to get the corresponding information.\nUsing the HashSet type requires importing a collection package:\nimport std.collection.*import std.collection.*\n\n\nmain() {\n    let mySet = HashSet<Int64>([0, 1, 2])\n    if (mySet.size == 0) {\n        println(\"This is an empty hashset\")\n    } else {\n        println(\"The size of hashset is ${mySet.size}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIf you want to determine if an element is included in a HashSet, you can use the contains function. Returns true if the element exists, false otherwise.\nUsing the HashSet type requires importing a collection package:\nimport std.collection.*let mySet = HashSet<Int64>([0, 1, 2])\nlet a = mySet.contains(0) // a == true\nlet b = mySet.contains(-1) // b == false"}
{"text": "Cangjie programming language syntax:\nA HashSet is a mutable reference type that provides the ability to add elements and remove them.\nThe mutability of a HashSet is a very useful feature that allows all references to the same HashSet instance to share the same element and modify them uniformly.\nIf you need to add a single element to a HashSet, use the put function. If you want to add multiple elements at the same time, you can use the putAll function, which accepts another Collection type of the same element type (e.g. Array). When an element does not exist, the put function performs the added operation, and when the same element is present in the HashSet, the put function has no effect.\nUsing the HashSet type requires importing a collection package:\nimport std.collection.*let mySet = HashSet<Int64>()\nmySet.put(0) // mySet contains elements 0\nmySet.put(0) // mySet contains elements 0\nmySet.put(1) // mySet contains elements 0, 1\nlet li = [2, 3]\nmySet.putAll(li) // mySet contains elements 0, 1, 2, 3"}
{"text": "Cangjie programming language syntax:\nHashSet is a reference type, HashSet does not copy copies when used as an expression, and all references to the same HashSet instance share the same data.Therefore, modifications to the HashSet element affect all references to that instance.let set1 = HashSet<Int64>([0, 1, 2])\nlet set2 = set1\nset2.put(3)\n// set1 contains elements 0, 1, 2, 3\n// set2 contains elements 0, 1, 2, 3"}
{"text": "Cangjie programming language syntax:\nTo remove an element from a HashSet, you can use the remove function, which requires you to specify the element to be deleted.let mySet = HashSet<Int64>([0, 1, 2, 3])\nmySet.remove(1) // mySet contains elements 0, 2, 3"}
{"text": "Cangjie programming language syntax:\nUsing the HashMap type requires importing the collection package:import std.collection.*\nYou can use the HashMap type to construct a Collection with elements that are key-value pairs.\n\nA HashMap is a type of hash table that provides quick access to the elements it contains. Each element in the table is identified with its key, which can be used to access the corresponding value.\n\nCangjie uses HashMap<K, V> for the HashMap type, K for the key type of the HashMap, and K must be a type that implements the Hashable and Equatable<K> interfaces, such as Numeric or String. V represents the value type of the HashMap, and V can be of any type.\nHashMaps with different element types are not of the same type, so they can't assign values to each other.Therefore, the following example is not legitimate.var a: HashMap<Int64, Int64> = ... // HashMap whose key type is Int64 and value type is Int64\nvar b: HashMap<String, Int64> = ... // HashMap whose key type is String and value type is Int64\nb = a // Type mismatch"}
{"text": "Cangjie programming language syntax:\nCangjie can use constructors to construct a specified HashMap.\nUsing the HashMap type requires importing the collection package:import std.collection.*let a = HashMap<String, Int64>() // Created an empty HashMap whose key type is String and value type is Int64\nlet b = HashMap<String, Int64>([(\"a\", 0), (\"b\", 1), (\"c\", 2)]) // whose key type is String and value type is Int64, containing elements (\"a\", 0), (\"b\", 1), (\"c\", 2)\nlet c = HashMap<String, Int64>(b) // Use another Collection to initialize a HashMap\nlet d = HashMap<String, Int64>(10) // Created a HashMap whose key type is String and value type is Int64 and capacity is 10\nlet e = HashMap<Int64, Int64>(10, {x: Int64 => (x, x * x)}) // Created a HashMap whose key and value type is Int64 and size is 10. All elements are initialized by specified rule function"}
{"text": "Cangjie programming language syntax:\nWhen you need to access all the elements of the HashMap, you can use a for-in loop to iterate through all the elements of the HashMap.\nIt is important to note that HashMaps are not guaranteed to be arranged in the order in which the elements are inserted, so the order of traversal and the order of insertion may be different.\nUsing the HashMap type requires importing the collection package:import std.collection.*import std.collection.*\n\n\nmain() {\n    let map = HashMap<String, Int64>([(\"a\", 0), (\"b\", 1), (\"c\", 2)])\n    for ((k, v) in map) {\n        println(\"The key is ${k}, the value is ${v}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nWhen you need to know the number of elements contained in a hashmap, you can use the size attribute to get the corresponding information.\nUsing the HashMap type requires importing the collection package:import std.collection.*import std.collection.*\n\n\nmain() {\n    let map = HashMap<String, Int64>([(\"a\", 0), (\"b\", 1), (\"c\", 2)])\n    if (map.size == 0) {\n        println(\"This is an empty hashmap\")\n    } else {\n        println(\"The size of hashmap is ${map.size}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIf you want to determine whether a key is included in the HashMap, you can use the contains function. Returns true if the key exists, false otherwise.\nUsing the HashMap type requires importing the collection package:import std.collection.*let map = HashMap<String, Int64>([(\"a\", 0), (\"b\", 1), (\"c\", 2)])\nlet a = map.contains(\"a\") // a == true\nlet b = map.contains(\"d\") // b == false"}
{"text": "Cangjie programming language syntax:\nWhen you want to access the element corresponding to a specified key, you can use the subscript syntax to access it (the type of subscript must be a key type). Using a non-existent key as an index triggers a runtime exception.\nUsing the HashMap type requires importing the collection package:import std.collection.*let map = HashMap<String, Int64>([(\"a\", 0), (\"b\", 1), (\"c\", 2)])\nlet a = map[\"a\"] // a == 0\nlet b = map[\"b\"] // b == 1\nlet c = map[\"d\"] // Runtime exceptions"}
{"text": "Cangjie programming language syntax:\nHashMap is a mutable reference type that provides the ability to modify elements, add elements, and delete elements.\n\nHashMap variability is a very useful feature that allows all references to the same HashMap instance to share the same element and modify them uniformly.\n\nYou can use the subscript syntax to modify the value of a key.\nUsing the HashMap type requires importing the collection package:import std.collection.*let map = HashMap<String, Int64>([(\"a\", 0), (\"b\", 1), (\"c\", 2)])\nmap[\"a\"] = 3"}
{"text": "Cangjie programming language syntax:\nUsing the HashMap type requires importing the collection package:import std.collection.*\nHashMap is a reference type, and when used as an expression, HashMap does not copy copies, and all references to the same HashMap instance share the same data.\nAs a result, modifications to the HashMap element affect all references to that instance.let map1 = HashMap<String, Int64>([(\"a\", 0), (\"b\", 1), (\"c\", 2)])\nlet map2 = map1\nmap2[\"a\"] = 3\n// map1 contains the elements (\"a\", 3), (\"b\", 1), (\"c\", 2)\n// map2 contains the elements (\"a\", 3), (\"b\", 1), (\"c\", 2)"}
{"text": "Cangjie programming language syntax:\nIf you need to add a single key-value pair to the HashMap, use the put function. If you want to add multiple key-value pairs at the same time, you can use the putAll function. When the key does not exist, the put function performs the added operation, and when the key exists, the put function overwrites the old value with the new value.\nUsing the HashMap type requires importing the collection package:import std.collection.*let map = HashMap<String, Int64>()\nmap.put(\"a\", 0) // map contains the element (\"a\", 0)\nmap.put(\"b\", 1) // map contains the elements (\"a\", 0), (\"b\", 1)\nlet map2 = HashMap<String, Int64>([(\"c\", 2), (\"d\", 3)])\nmap.putAll(map2) // map contains the elements (\"a\", 0), (\"b\", 1), (\"c\", 2), (\"d\", 3)"}
{"text": "Cangjie programming language syntax:\nIn addition to using the put function, you can also use assignment to add new key-value pairs directly to the HashMap.\nUsing the HashMap type requires importing the collection package:import std.collection.*let map = HashMap<String, Int64>([(\"a\", 0), (\"b\", 1), (\"c\", 2)])\nmap[\"d\"] = 3 // map contains the elements (\"a\", 0), (\"b\", 1), (\"c\", 2), (\"d\", 3)"}
{"text": "Cangjie programming language syntax:\nTo delete an element from the HashMap, you can use the remove function, which requires you to specify the key to be deleted.\nUsing the HashMap type requires importing the collection package:import std.collection.*let map = HashMap<String, Int64>([(\"a\", 0), (\"b\", 1), (\"c\", 2), (\"d\", 3)])\nmap.remove(\"d\") // map contains the elements (\"a\", 0), (\"b\", 1), (\"c\", 2)"}
{"text": "Cangjie programming language syntax:\nWe've already looked at Range, Array, and ArrayList, all of which can be traversed using for-in. A similar traversal can be achieved for developer-defined types.\n\nRange, Array, and ArrayList all support for-in syntax via Iterable.\n\nIterable is a built-in interface in the form of just the core code.interface Iterable<T> {\n    func iterator(): Iterator<T>\n    ...\n}"}
{"text": "Cangjie programming language syntax:\nThe Iterator type that the iterator function requires to return is another built-in interface in the form of something like this (which only shows the core code).interface Iterator<T> <: Iterable<T> {\n    mut func next(): Option<T>\n    ...\n}"}
{"text": "Cangjie programming language syntax:\nYou can use the for-in syntax to iterate over any instance that implements the Iterable interface type.\nLet's say you have a for-in code like this.let list = [1, 2, 3]\nfor (i in list) {\n    println(i)\n}\n// It's equivalent to while code in the form of.\nlet list = [1, 2, 3]\nvar it = list.iterator()\nwhile (true) {\n    match (it.next()) {\n        case Some(i) => println(i)\n        case None => break\n    }\n}"}
{"text": "Cangjie programming language syntax:\nAnother common way to traverse an Iterable type is to use while-let, such as the equivalent of the while code above:let list = [1, 2, 3]\nvar it = list.iterator()\nwhile (let Some(i) <- it.next()) {\n    println(i)\n}"}
{"text": "Cangjie programming language syntax:\nThe Array, ArrayList, HashSet, and HashMap types all implement Iterable, so they can all be used in for-in or while-lets.\nUsing the types requires importing the collection package:import std.collection.*"}
