{"text": "Cangjie programming language syntax:\nAn exception is a special type of error that can be caught and handled by a programmer, and is a general term for a series of abnormal behaviors that occur when a program is executed. For example, arrays are out of bounds, divide-zero errors, calculation overflows, illegal inputs, etc. In order to ensure the correctness and robustness of the system, many software systems contain a large amount of code for error detection and error handling.\n\nExceptions do not belong to the normal functions of the program, and once an exception occurs, the program must be dealt with immediately, that is, the control of the program is transferred from the execution of the normal function to the part that handles the exception. The Cangjie programming language provides an exception handling mechanism to handle various exceptions that may occur when the program is running.\n\nIn the Cangjie language, exception classes include Error and Exception:\n\nThe Error class describes internal system errors and resource exhaustion errors when the Cangjie language is running. The application should not throw this type of error, and if there is an internal error, it can only be notified to the user, and the program should be terminated as safely as possible.\nThe Exception class describes exceptions caused by logic errors or IO errors when the program is running, such as an array going out of bounds or trying to open a non-existent file, etc., which need to be captured and handled in the program.\nDevelopers cannot customize exceptions by inheriting the built-in Error or its subclasses in the Cangjie language, but they can inherit the built-in Exception or its subclasses to customize exceptions, such as:open class FatherException <: Exception {\n    public init() {\n        super(\"This is FatherException.\")\n    }\n    public init(message: String) {\n        super(message)\n    }\n    public open override func getClassName(): String {\n        \"FatherException\"\n    }\n}\n\n\nclass ChildException <: FatherException {\n    public init() {\n        super(\"This is ChildException.\")\n    }\n    public open override func getClassName(): String {\n        \"ChildException\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nThe following table shows the main functions of Exception and their descriptions:\n\nThe type of function\tFunctions and descriptions\nConstructor\tinit() is the default constructor.\nConstructor\tinit(message: String) can set the constructor for the exception message.\nMember attributes\topen prop message: String returns the details of the exception. The message is initialized in the exception class constructor and defaults to an empty string.\nMember functions\topen func toString(): String returns the name of the exception type and the details of the exception, where message is called by default for the details of the exception.\nMember functions\tfunc getClassName(): String returns the user-defined class name, and the subclass needs to override the method to return the name of the subclass.\nMember functions\tfunc printStackTrace(): Unit prints stack information to the standard error stream."}
{"text": "Cangjie programming language syntax:\nThe following table shows the main functions of Error and their descriptions:\n\nThe type of function\tFunctions and descriptions\nMember attributes\topen prop message: String returns the details of the error that occurred. The message is initialized internally when an error occurs, defaulting to an empty string.\nMember functions\topen func toString(): String returns the name of the error type and the details of the error, where message is called by default for the error details.\nMember functions\tfunc printStackTrace(): Unit prints stack information to the standard error stream."}
{"text": "Cangjie programming language syntax:\nNow that we've covered how to customize exceptions, let's learn how to throw and handle exceptions.\n\nSince exceptions are of class type, you only need to create exceptions in the way the class object is built. For example, the expression FatherException() creates an exception of type FatherException.\nThe Cangjie language provides the throw keyword, which is used to throw exceptions. When throwing an exception with throw, the expression after the throw must be a subtype of Exception (Error cannot be thrown manually), e.g. throw ArithmeticException(\"I am an Exception!\") (when executed) will throw an arithmetic exception.\nExceptions thrown by the throw keyword need to be caught. If the exception is not caught, the system calls the default exception handling function.\nException handling is done by try expressions and can be divided into:\n\nA normal try expression that doesn't involve automatic resource management.\nThe resource management try-with-resources expression is automatically performed."}
{"text": "Cangjie programming language syntax:\nOrdinary try expressions\nA normal try expression consists of three parts: the try block, the catch block, and the finally block.\n\ntry block, which starts with the keyword try, is followed by a block of expressions and declarations (enclosed in a pair of curly braces, defining a new local scope, which can contain arbitrary expressions and declarations, hereinafter referred to as \"blocks\"), and the block after the try can throw an exception, which is captured and handled by the immediately following catch block (if there is no catch block or is not caught, the exception continues to be thrown after the finally block is executed).\n\ncatch block, a normal try expression can contain zero or more catch blocks (there must be finally blocks when there are no catch blocks). Each catch block starts with the keyword catch and is followed by a catchPattern and a block that matches the exception to be caught by pattern matching. Once the match is successful, it is processed by the block that follows it, ignoring the other catch blocks that follow it. When all the types of exceptions that can be caught by a catch block can be caught by a catch block defined in front of it, a warning of \"catch block unreachable\" will be reported at the catch block.\n\nfinally block, starting with the keyword finally followed by a block. In principle, the \"aftermath\" work is mainly implemented in the finally block, such as releasing resources, etc., and it is necessary to avoid throwing exceptions in the finally block as much as possible. And regardless of whether the exception occurs (i.e., whether an exception is thrown in the try block), the contents of the finally block will be executed (if the exception is not handled, the exception will continue to be thrown outward after the finally block is executed). A try expression can contain a catch block without a finally block, otherwise it must contain a finally block.\n\nThe blocks immediately following the try and the scope of each catch block are independent of each other.\n\nHere's a simple example with only a try block and a catch block:main() {\n    try {\n        throw NegativeArraySizeException(\"I am an Exception!\")\n    } catch (e: NegativeArraySizeException) {\n        println(e)\n        println(\"NegativeArraySizeException is caught!\")\n    }\n    println(\"This will also be printed!\")\n}"}
{"text": "Cangjie programming language syntax:\nThe scope level of the variable introduced in the catchPattern is the same as the scope level of the variable in the block after the catch, and reintroducing the same name in the catch block will trigger a redefinition error. For example:main() {\n    try {\n        throw NegativeArraySizeException(\"I am an Exception!\")\n    } catch (e: NegativeArraySizeException) {\n        println(e)\n        let e = 0 // Error, redefinition\n        println(e)\n        println(\"NegativeArraySizeException is caught!\")\n    }\n    println(\"This will also be printed!\")\n}"}
{"text": "Cangjie programming language syntax:\nHere's a simple example of a try expression with the finally block:main() {\n    try {\n        throw NegativeArraySizeException(\"NegativeArraySizeException\")\n    } catch (e: NegativeArraySizeException) {\n        println(\"Exception info: ${e}.\")\n    } finally {\n        println(\"The finally block is executed.\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nTry expressions can appear anywhere expressions are allowed. The type of a try expression is determined in a similar way to the type of multi-branch syntax structures such as if and match expressions, and is the smallest common parent type of all branches except the finally branch. For example, the try expression and variable x in the following code are of type D, the smallest common parent of E and D; C() in the finally branch does not participate in the computation of the public parent type (if it does, the smallest public parent type becomes C).\n\nIn addition, when the value of the try expression is not used, its type is Unit, and the type of each branch is not required to have a minimum common parent type.open class C { }\nopen class D <: C { }\nclass E <: D { }\nmain () {\n    let x = try {\n        E()\n    } catch (e: Exception) {\n        D()\n    } finally {\n        C()\n    }\n    0\n}"}
{"text": "Cangjie programming language syntax:\nThe try-with-resources expression is primarily used to automatically release non-memory resources. Unlike normal try expressions, the catch block and finally block in the try-with-resources expression are optional, and one or more ResourceSpecifications can be inserted between the blocks after the try keyword to apply for a series of resources (ResourceSpecification does not affect the type of the entire try expression). The resource in this case corresponds to an object at the linguistic level, so a ResourceSpecification is really a series of objects that are instantiated (used between multiple instantiations, \"separated\"). An example of using the try-with-resources expression is as follows:class Worker <: Resource {\n    var hasTools: Bool = false\n    let name: String\n\n\n    public init(name: String) {\n        this.name = name\n    }\n    public func getTools() {\n        println(\"${name} picks up tools from the warehouse.\")\n        hasTools = true\n    }\n\n\n    public func work() {\n        if (hasTools) {\n            println(\"${name} does some work with tools.\")\n        } else {\n            println(\"${name} doesn't have tools, does nothing.\")\n        }\n    }\n\n\n    public func isClosed(): Bool {\n        if (hasTools) {\n            println(\"${name} hasn't returned the tool.\")\n            false\n        } else {\n            println(\"${name} has no tools\")\n            true\n        }\n    }\n    public func close(): Unit {\n        println(\"${name} returns the tools to the warehouse.\")\n        hasTools = false\n    }\n}\n\n\nmain() {\n    try (r = Worker(\"Tom\")) {\n        r.getTools()\n        r.work()\n    }\n    try (r = Worker(\"Bob\")) {\n        r.work()\n    }\n    try (r = Worker(\"Jack\")) {\n        r.getTools()\n        throw Exception(\"Jack left, because of an emergency.\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nA name introduced between the try keyword and {} with the same scope as the variable introduced in {} will trigger a redefinition error if the same name is introduced again in {}.class R <: Resource {\n    public func isClosed(): Bool {\n        true\n    }\n    public func close(): Unit {\n        print(\"R is closed\")\n    }\n}\n\n\nmain() {\n    try (r = R()) {\n        println(\"Get the resource\")\n        let r = 0 // Error, redefinition\n        println(r)\n    }\n}"}
{"text": "Cangjie programming language syntax:\nThe type of ResourceSpecification in the try-with-resources expression must implement the Resource interface:interface Resource {\n    func isClosed(): Bool // When leaving the try with resources scope, determine whether to call the close function to release resources\n    func close(): Unit  // Release resources in the scenario where isClosed returns false.\n}"}
{"text": "Cangjie programming language syntax:\nIt should be noted that it is generally not necessary to include catch blocks and finally blocks in the try-with-resources expression, and it is not recommended that developers manually release resources (logical redundancy). However, if you need to explicitly catch and handle a try block or exception that might be thrown during resource application and release, you can still include a catch block and a finally block in the try-with-resources expression:class R <: Resource {\n    public func isClosed(): Bool {\n        true\n    }\n    public func close(): Unit {\n        print(\"R is closed\")\n    }\n}\n\n\nmain() {\n    try (r = R()) {\n        println(\"Get the resource\")\n    } catch (e: Exception) {\n        println(\"Exception happened when executing the try-with-resources expression\")\n    } finally {\n        println(\"End of the try-with-resources expression\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nAdvanced introduction to CatchPattern\nMost of the time, you only want to catch exceptions of a certain type and its subtypes, and then use the type pattern of CatchPattern to handle it; However, sometimes it is necessary to handle all exceptions uniformly (such as the exception should not occur here, and the error will be reported uniformly), in which case you can use the wildcard pattern of CatchPattern to handle it.\n\nThe type pattern is syntactically formatted in two formats:\nIdentifier: ExceptionClass。 This format captures exceptions of type ExceptionClass and its subclasses, converts the captured exception instances into ExceptionClass, binds them to the variables defined by the Identifier, and then accesses the captured exception instances through the variables defined by the Identifier in the catch block.\nIdentifier: ExceptionClass_1 | ExceptionClass_2 | ... | ExceptionClass_n。 This format can be obtained by the connector | Splice multiple exception classes with connectors | Relationships that represent \"or\": You can catch an exception of type ExceptionClass_1 and its subclass, or an exception of type ExceptionClass_2 and its subclass, and so on, or an exception of type ExceptionClass_n and its subclass (assuming n is greater than 1). The exception to be caught is caught when the type of the exception belongs to either of the OR relationships above or its subtypes. However, since it is not possible to statically determine the type of the caught exception, the type of the caught exception is converted to a defined by | Connect the smallest common parent class of all types, and bind the exception instance to the variable defined by the Identifier. As a result, in this type of mode, the member variables and member functions in the smallest common parent class of ExceptionClass_i(1 <= i <= n) can only be accessed through variables defined by the Identifier within the catch block. Of course, you can also use wildcards instead of Identifiers in type patterns, except that wildcards don't bind them.\nThe following is an example:main(): Int64 {\n    try {\n        throw IllegalArgumentException(\"This is an Exception!\")\n    } catch (e: OverflowException) {\n        println(e.message)\n        println(\"OverflowException is caught!\")\n    } catch (e: IllegalArgumentException | NegativeArraySizeException) {\n        println(e.message)\n        println(\"IllegalArgumentException or NegativeArraySizeException is caught!\")\n    } finally {\n        println(\"finally is executed!\")\n    }\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nThe type of caught exception is defined by | Smallest common parent class of all types of connections\":open class Father <: Exception {\n    var father: Int32 = 0\n}\n\n\nclass ChildOne <: Father {\n    var childOne: Int32 = 1\n}\n\n\nclass ChildTwo <: Father {\n    var childTwo: Int32 = 2\n}\n\n\nmain() {\n    try {\n        throw ChildOne()\n    } catch (e: ChildTwo | ChildOne) {\n        println(\"${e is Father}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nThe syntax of the wildcard pattern is _, which catches any type of exception thrown within the sibling try block, which is equivalent to e:Exception in the type pattern, which catches the exception defined by the Exception subclass. The following is an example:// Catch with wildcardPattern.\ntry {\n    throw OverflowException()\n} catch (_) {\n    println(\"catch an exception!\")\n}"}
{"text": "Cangjie programming language syntax:\nhe most common exception classes are built into the Cangjie language, which developers can use directly.\n\nabnormal\tdescription\nConcurrentModificationException\tExceptions caused by concurrent modifications\nIllegalArgumentException\tAn exception thrown when an invalid or incorrect parameter is passed\nNegativeArraySizeException\tAn exception thrown when creating an array of negative sizes\nNoneValueException\tAn exception that occurs when the value does not exist, such as the key to be found does not exist in the map\nOverflowException\tArithmetic operation overflow exception"}
{"text": "Cangjie programming language syntax:\nThe definition of the Option type is described in Option Types, because the Option type can represent both a valued and unvalued state, and an unvalued type can also be understood as an error in some cases, so the Option type can also be used as an error handler.\n\nFor example, in the example below, the function getOrThrow returns the value of v if the parameter value is equal to Some(v), and throws an exception if the parameter value is equal to None.func getOrThrow(a: ?Int64) {\n    match (a) {\n        case Some(v) => v\n        case None => throw NoneValueException()\n    }\n}"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Cangjie provides a variety of destructuring methods to facilitate the use of Option types, including: pattern matching, getOrThrow function, coalescing operator (?? ), and the question mark operator (?). Each of these approaches is described below.\n\nPattern matching: Because the Option type is an enum type, you can use the pattern matching of the enum mentioned above to deconstruct the Option value. For example, in the example below, the function getString accepts a ? Int64 returns a string representation of the value when the parameter is a Some value, and a string \"none\" when the parameter is a None value.func getString(p: ?Int64): String{\n    match (p) {\n        case Some(x) => \"${x}\"\n        case None => \"none\"\n    }\n}\nmain() {\n    let a = Some(1)\n    let b: ?Int64 = None\n    let r1 = getString(a)\n    let r2 = getString(b)\n    println(r1)\n    println(r2)\n}"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Cangjie provides a variety of destructuring methods to facilitate the use of Option types, including: pattern matching, getOrThrow function, coalescing operator (?? ), and the question mark operator (?). Each of these approaches is described below.\ncoalescing operator (?? ): For ? T type expression e1, if you want the value of e1 to be equal to None and also return a value of type T e2, you can use ?? Operator. For the expression e1 ?? e2, returns the value of v when the value of e1 is equal to some(v), otherwise returns the value of e2. Here are some examples:main() {\n    let a = Some(1)\n    let b: ?Int64 = None\n    let r1: Int64 = a ?? 0\n    let r2: Int64 = b ?? 0\n    println(r1)\n    println(r2)\n}"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Cangjie provides a variety of destructuring methods to facilitate the use of Option types, including: pattern matching, getOrThrow function, coalescing operator (?? ), and the question mark operator (?). Each of these approaches is described below.\nQuestion mark operator (?): ? Need and . or () or [] or {} (specifically for scenarios that trail lambda calls) to implement Option type support for ., (), [], and {}. In order to. For example(), [] and {} are the same), for ? T1 type expression e, when the value of e is equal to Some(v), e?. The value of b is equal to Option<T2>. Some(v.b), otherwise e?. The value of b is equal to Option<T2>. None, where T2 is the type of v.b. Here are some examples:struct R {\n    public var a: Int64\n    public init(a: Int64) {\n        this.a = a\n    }\n}\n\n\nlet r = R(100)\nlet x = Some(r)\nlet y = Option<R>.None\nlet r1 = x?.a   // r1 = Option<Int64>.Some(100)\nlet r2 = y?.a   // r2 = Option<Int64>.None"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Cangjie provides a variety of destructuring methods to facilitate the use of Option types, including: pattern matching, getOrThrow function, coalescing operator (?? ), and the question mark operator (?). Each of these approaches is described below.\nThe question mark operator (?) supports multiple layers of access to the role of a?. b.c?. d as an example ((), [] and {} are the same). The type of expression a needs to be an Option<T1>, T1 contains instance member b, b contains instance member variable c and c is of type an option<T2>, and T2 contains instance member d. Expression a?. b.c?. d is of type Option<T3>, where T3 is the type of instance member d of T2; When the value of a is equal to Some(va) and the value of va.b.c is equal to Some(vc), a?. b.c?. The value of d is equal to Option<T3>. Some(vc.d)； When the value of a is equal to Some(va) and the value of va.b.c is equal to None, a?. b.c?. The value of d is equal to Option<T3>. None(d will not be evaluated); When the value of a is equal to None, a?. b.c?. The value of d is equal to Option<T3>. None(b, c, and d are not evaluated).struct A {\n    let b: B = B()\n}\n\n\nstruct B {\n    let c: Option<C> = C()\n    let c1: Option<C> = Option<C>.None\n}\n\n\nstruct C {\n    let d: Int64 = 100\n}\n\n\nlet a = Some(A())\nlet a1 = a?.b.c?.d // a1 = Option<Int64>.Some(100)\nlet a2 = a?.b.c1?.d // a2 = Option<Int64>.None"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Cangjie provides a variety of destructuring methods to facilitate the use of Option types, including: pattern matching, getOrThrow function, coalescing operator (?? ), and the question mark operator (?). Each of these approaches is described below.\ngetOrThrow function: For ? T-type expression e, which can be deconstructed by calling the getOrThrow function. When the value of e is equal to Some(v), getOrThrow() returns the value of v, otherwise an exception is thrown. Here are some examples:main() {\n    let a = Some(1)\n    let b: ?Int64 = None\n    let r1 = a.getOrThrow()\n    println(r1)\n    try {\n        let r2 = b.getOrThrow()\n    } catch (e: NoneValueException) {\n        println(\"b is None\")\n    }\n}"}
