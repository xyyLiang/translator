{"text": "Cangjie programming language syntax:\nThe enum type provides a way to define a type by listing all possible values of that type.Enum types (or enumerations) exist in many languages, but their usage and expressiveness vary across languages. In Cangjie, the enum type can be understood as algebraic data types (Algebraic Data Types) in functional programming languages.\nWhen defining an enum, you need to list all its possible values one by one, which are referred to as the constructors (or constructors) of the enum.enum RGBColor {\n    | Red | Green | Blue\n}"}
{"text": "Cangjie programming language syntax:\nThe definition of an enum type starts with the keyword enum, followed by the name of the enum, and then the enum body defined within a pair of curly braces. The enum body defines several constructors, with multiple constructors separated by | (the | before the first constructor is optional). In the example above, an enum type named RGBColor is defined, which has 3 constructors: Red, Green, and Blue, respectively representing red, green, and blue in the RGB color mode.\nThe constructors in the above enum can also carry several (at least one) parameters, known as parameterized constructors. For example, a UInt8 type parameter can be set for Red, Green, and Blue to represent the brightness level of each color:enum RGBColor {\n    | Red(UInt8) | Green(UInt8) | Blue(UInt8)\n}"}
{"text": "Cangjie programming language syntax:\nCangjie supports defining multiple 同名 constructors within the same enum, but requires that these constructors have a different number of parameters (the constructor with no parameters is considered to have 0 parameters), for example:enum RGBColor {\n    | Red | Green | Blue\n    | Red(UInt8) | Green(UInt8) | Blue(UInt8)\n}"}
{"text": "Cangjie programming language syntax:\nenum supports recursive definition, for example, the following example uses enum to define an expression (i.e., Expr), which can only have 3 forms: a single number Num (carrying an Int64 type parameter), an addition expression Add (carrying two Expr type parameters), and a subtraction expression Sub (carrying two Expr type parameters). For the Add and Sub constructors, their parameters recursively use Expr itself.enum Expr {\n    | Num(Int64)\n    | Add(Expr, Expr)\n    | Sub(Expr, Expr)\n}"}
{"text": "Cangjie programming language syntax:\nAdditionally, a series of member functions, operator functions (see Operator Overloading chapter for details), and member properties can be defined within the enum body, but the constructor, member function, and member property cannot have the same name. For example, the following example defines a function named printType in RGBColor, which outputs the string RGBColor:enum RGBColor {\n    | Red | Green | Blue\n\n    public static func printType() {\n        print(\"RGBColor\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nAfter defining an enum type, you can create instances of this type (i.e., enum values). Enum values can only take one of the constructors defined in the enum type. Enums do not have constructors; you can construct an enum value using the constructor with the type name (e.g., TypeConstructor) or directly using the constructor (for parameterized constructors, you need to pass actual parameters).\nIn the example below, RGBColor defines three constructors, two of which are parameterless constructors (Red and Green), and one is a parameterized constructor (Blue(UInt8)). In the main function, three RGBColor variables r, g, and b are defined, where r's value is initialized using RGBColor.Red, g's value is directly initialized using Green, and b's value is initialized using Blue(100):enum RGBColor {\n    | Red | Green | Blue(UInt8)\n}\n\n\nmain() {\n    let r = RGBColor.Red\n    let g = Green\n    let b = Blue(100)\n}"}
{"text": "Cangjie programming language syntax:\nWhen the type name is omitted, the name of the enum constructor may conflict with the type name, variable name, or function name. In this case, you must add the enum type name to use the enum constructor; otherwise, only the type, variable, or function definition with the same name will be selected.\nIn the following example, only the constructor Blue(UInt8) can be used without a type name. Red and Green(UInt8) will both conflict and cannot be used directly; you must add the type name RGBColor.let Red = 1\n\n\nfunc Green(g: UInt8) {\n    return g\n}\n\n\nenum RGBColor {\n    | Red | Green(UInt8) | Blue(UInt8)\n}\n\n\nlet r1 = Red                 // Will choose 'let Red'\nlet r2 = RGBColor.Red        // Ok: constructed by enum type name\n\n\nlet g1 = Green(100)          // Will choose 'func Green'\nlet g2 = RGBColor.Green(100) // Ok: constructed by enum type name\n\n\nlet b = Blue(100)            // Ok: can be uniquely identified as an enum constructor"}
{"text": "Cangjie programming language syntax:\nIn the following examples, only the constructor Blue will fail to be used directly due to name conflicts and must be prefixed with the type name RGBColor.class Blue {}\n\nenum RGBColor {\n    | Red | Green(UInt8) | Blue(UInt8)\n}\n\nlet r = Red                 // Ok: constructed by enum type name\n\nlet g = Green(100)          // Ok: constructed by enum type name\n\nlet b = Blue(100)           // Will choose constructor of 'class Blue' and report an error"}
{"text": "Cangjie programming language syntax:\nThe Option type is defined using enum, which contains two constructors: Some and None. Some carries a parameter to indicate a value is present, while None does not carry a parameter to indicate no value. When you need to represent that a type may or may not have a value, you can choose to use the Option type.The Option type is defined as a generic enum type, defined as follows (here it is only necessary to know that T in angle brackets is a type parameter, and different Option types are obtained when T is instantiated with different types. The Some constructor's parameter type is the type parameter T. When T is instantiated with different types, different Option types are obtained, such as Option<Int64>, Option<String>, etc. The Option type also has a simple syntax: add ? before the type name. That is, for any type Ty, ?Ty is equivalent to Option<Ty>. For example, ?Int64 is equivalent to Option<Int64>, ?String is equivalent to Option<String>, and so on. For detailed information on generics, see Generics):enum Option<T> {\n    | Some(T)\n    | None\n}"}
{"text": "Cangjie programming language syntax:\nThe Option type is defined as a generic enum type, defined as follows (here it is only necessary to know that T in angle brackets is a type parameter, and different Option types are obtained when T is instantiated with different types. \nThe Option type also has a simple syntax: add ? before the type name. That is, for any type Ty, ?Ty is equivalent to Option<Ty>. For example, ?Int64 is equivalent to Option<Int64>, ?String is equivalent to Option<String>, and so on.let a: Option<Int64> = Some(100)\nlet b: ?Int64 = Some(100)\nlet c: Option<String> = Some(\"Hello\")\nlet d: ?String = None"}
{"text": "Cangjie programming language syntax:\nAdditionally, although T and Option<T> are different types, when it is explicitly known that a value of type Option<T> is required at a certain position, a value of type T can be passed directly. The compiler will use the Some constructor of type Option<T> to encapsulate the value of type T into a value of type Option<T> (note: this is not type conversion). For example, the following definition is valid (equivalent to the definitions of variables a, b, and c in the previous example):let a: Option<Int64> = 100\nlet b: ?Int64 = 100\nlet c: Option<String> = \"100\""}
{"text": "Cangjie programming language syntax:\nWhen there is no explicit type requirement in the context, None cannot be used to directly construct the desired type. In this case, the syntax None<T> should be used to construct data of type Option<T>, for examplelet a = None<Int64> // a: Option<Int64>\nlet b = None<Bool> // b: Option<Bool>"}
{"text": "Cangjie programming language syntax:\nIn the Option type, the definition of the Option type is introduced because the Option type can represent both a value and a none-value state, and a none-value can also be understood as an error in some cases, so the Option type can also be used for error handling.\nFor example, in the following example, if the parameter value of the function getOrThrow is Some(v), it returns the value of v; if the parameter value is None, it throws an exception.func getOrThrow(a: ?Int64) {\n    match (a) {\n        case Some(v) => v\n        case None => throw NoneValueException()\n    }\n}"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Changjie provides multiple deconstruction methods to facilitate the use of the Option type, specifically including: pattern matching, the getOrThrow function, the coalescing operator (??), and the question mark operator (?).\nPattern matching: Because the Option type is an enum type, pattern matching of enums mentioned earlier can be used to deconstruct Option values. For example, in the following example, the function getString accepts a ?Int64 type parameter. When the parameter is a Some value, it returns the string representation of the numerical value; when the parameter is a None value, it returns the string \"none\".func getString(p: ?Int64): String{\n    match (p) {\n        case Some(x) => \"${x}\"\n        case None => \"none\"\n    }\n}\nmain() {\n    let a = Some(1)\n    let b: ?Int64 = None\n    let r1 = getString(a)\n    let r2 = getString(b)\n    println(r1)\n    println(r2)\n}"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Changjie provides multiple deconstruction methods to facilitate the use of the Option type, specifically including: pattern matching, the getOrThrow function, the coalescing operator (??), and the question mark operator (?). \nThe coalescing operator (??): For an expression e1 of type ?T, if you want to return a value of type T when e1's value is None, you can use the ?? operator. For the expression e1 ?? e2, it returns the value v when e1's value is Some(v), otherwise it returns e2's value. For example:main() {\n    let a = Some(1)\n    let b: ?Int64 = None\n    let r1: Int64 = a ?? 0\n    let r2: Int64 = b ?? 0\n    println(r1)\n    println(r2)\n}"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Changjie provides multiple deconstruction methods to facilitate the use of the Option type, specifically including: pattern matching, the getOrThrow function, the coalescing operator (??), and the question mark operator (?). \nThe question mark operator (?): ? needs to be used together with . or () or [] or {} (specifically for trailing lambda calls) to support ., (), [], and {} for the Option type. Taking . as an example ((), [], and {} are similar), for an expression e of type ?T1, when e's value is Some(v), the value of e?.b is Option<T2>.Some(v.b), otherwise the value of e?.b is Option<T2>.None, where T2 is the type of v.b. For example:struct R {\n    public var a: Int64\n    public init(a: Int64) {\n        this.a = a\n    }\n}\n\n\nlet r = R(100)\nlet x = Some(r)\nlet y = Option<R>.None\nlet r1 = x?.a   // r1 = Option<Int64>.Some(100)\nlet r2 = y?.a   // r2 = Option<Int64>.None"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Changjie provides multiple deconstruction methods to facilitate the use of the Option type, specifically including: pattern matching, the getOrThrow function, the coalescing operator (??), and the question mark operator (?). \nThe question mark operator (?.) supports multi-level access, for example, a?.b.c?.d (similarly for (), [] and {}). For the expression a?.b.c?.d, the type of a needs to be Option<T1> and T1 includes the instance member b, b's type includes the instance member variable c and c's type is Option<T2>, where T2 includes the instance member d; the type of the expression a?.b.c?.d is Option<T3>, where T3 is the type of the instance member d of T2. When the value of a is Some(va) and the value of va.b.c is Some(vc), the value of a?.b.c?.d is Option<T3>.Some(vc.d). When the value of a is Some(va) and the value of va.b.c is None, the value of a?.b.c?.d is Option<T3>.None (d will not be evaluated). When the value of a is None, the value of a?.b.c?.d is Option<T3>.None (b, c, and d will not be evaluated).struct A {\n    let b: B = B()\n}\n\n\nstruct B {\n    let c: Option<C> = C()\n    let c1: Option<C> = Option<C>.None\n}\n\n\nstruct C {\n    let d: Int64 = 100\n}\n\n\nlet a = Some(A())\nlet a1 = a?.b.c?.d // a1 = Option<Int64>.Some(100)\nlet a2 = a?.b.c1?.d // a2 = Option<Int64>.None"}
{"text": "Cangjie programming language syntax:\nBecause Option is a very commonly used type, Changjie provides multiple deconstruction methods to facilitate the use of the Option type, specifically including: pattern matching, the getOrThrow function, the coalescing operator (??), and the question mark operator (?). \ngetOrThrow function: For an expression e of type ?T, it can be destructured by calling the getOrThrow function. When the value of e is Some(v), getOrThrow() returns the value of v, otherwise it throws an exception. For example:main() {\n    let a = Some(1)\n    let b: ?Int64 = None\n    let r1 = a.getOrThrow()\n    println(r1)\n    try {\n        let r2 = b.getOrThrow()\n    } catch (e: NoneValueException) {\n        println(\"b is None\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nConstant patterns can be integer literals, floating-point literals, character literals, boolean literals, string literals (string interpolation is not supported), and Unit literals.\nWhen using constant patterns in a match expression that includes matching values (refer to the match expression chapter), it is required that the type of the value represented by the constant pattern is the same as the type of the value to be matched. The condition for a successful match is that the value to be matched is equal to the value represented by the constant pattern.\nIn the example below, the grade of the exam result is output based on the value of score (assuming score can only take values between 0 and 100 that are divisible by 10):main() {\n    let score = 90\n    let level = match (score) {\n        case 0 | 10 | 20 | 30 | 40 | 50 => \"D\"\n        case 60 => \"C\"\n        case 70 | 80 => \"B\"\n        case 90 | 100 => \"A\" // Matched.\n        case _ => \"Not a valid score\"\n    }\n    println(level)\n}"}
{"text": "Cangjie programming language syntax:\nWhen using constant patterns in a match expression that includes matching values (refer to the match expression chapter), it is required that the type of the value represented by the constant pattern is the same as the type of the value to be matched. The condition for a successful match is that the value to be matched is equal to the value represented by the constant pattern.\nWhen the target of pattern matching is a value with a static type of Rune, both Rune literals and single-character string literals can be used to represent constant patterns for Rune type literals.func translate(n: Rune) {\n    match (n) {\n        case \"A\" => 1\n        case \"B\" => 2\n        case \"C\" => 3\n        case _ => -1\n    }\n}\n\n\nmain() {\n    println(translate(r\"C\"))\n}"}
{"text": "Cangjie programming language syntax:\nWhen using constant patterns in a match expression that includes matching values (refer to the match expression chapter), it is required that the type of the value represented by the constant pattern is the same as the type of the value to be matched. The condition for a successful match is that the value to be matched is equal to the value represented by the constant pattern.\nWhen the target of pattern matching is a value with static type Byte, a string literal representing an ASCII character can be used to represent a constant pattern for the Byte type literal.func translate(n: Byte) {\n    match (n) {\n        case \"1\" => 1\n        case \"2\" => 2\n        case \"3\" => 3\n        case _ => -1\n    }\n}\n\n\nmain() {\n    println(translate(51)) // UInt32(r'3') == 51\n}"}
{"text": "Cangjie programming language syntax:\nWildcard patterns use the underscore _ to represent, and can match any value. Wildcard patterns are typically used as the last pattern in a case, to match situations not covered by other cases. For example, in the constant pattern where the score value is matched, the last case uses _ to match invalid score values."}
{"text": "Cangjie programming language syntax:\nBinding patterns use an id to represent, where the id is a valid identifier. Compared to wildcard patterns, binding patterns can also match any value, but binding patterns will bind the matched value to the id, and the bound value can be accessed via the id after =>.\nIn the example below, the binding pattern is used in the last case to bind non-zero values:main() {\n    let x = -10\n    let y = match (x) {\n        case 0 => \"zero\"\n        case n => \"x is not zero and x = ${n}\" // Matched.\n    }\n    println(y)\n}"}
{"text": "Cangjie programming language syntax:\nWhen using | to connect multiple patterns, binding patterns cannot be used, nor can they be nested within other patterns, otherwise an error will occur:\n\nError_case:\nmain() {\n    let opt = Some(0)\n    match (opt) {\n        case x | x => {} // Error, variable cannot be introduced in patterns connected by '|'\n        case Some(x) | Some(x) => {} // Error, variable cannot be introduced in patterns connected by '|'\n        case x: Int64 | x: String => {} // Error, variable cannot be introduced in patterns connected by '|'\n    }\n}"}
{"text": "Cangjie programming language syntax:\nBinding a pattern id is equivalent to defining an immutable variable named id (whose scope extends from the point of introduction to the end of the case), so it cannot be modified after =>. For example, in the following case, modifying n in the last case is not allowed.main() {\n    let x = -10\n    let y = match (x) {\n        case 0 => \"zero\"\n        case n => n = n + 0 // Error, 'n' cannot be modified.\n                  \"x is not zero\"\n    }\n    println(y)\n}"}
{"text": "Cangjie programming language syntax:\nFor each case branch, the variable scope level after => is the same as the variable scope level introduced before => after the case. Reintroducing the same name again after => will trigger a redefinition error. For example:main() {\n    let x = -10\n    let y = match (x) {\n        case 0 => \"zero\"\n        case n => let n = 0 // Error, redefinition\n                  println(n)\n                  \"x is not zero\"\n    }\n    println(y)\n}"}
{"text": "Cangjie programming language syntax:\nPatterns can be divided into two categories: refutable patterns and irrefutable patterns. Under the premise of type matching, a pattern is referred to as a refutable pattern when there is a possibility that it does not match the value to be matched; conversely, a pattern is referred to as an irrefutable pattern when it can always match the value to be matched.\nFor the various patterns mentioned above, the following rules apply:\nThe constant pattern is a refutable pattern. For example, in the first case below, 1 and 2 in the second case may not be equal to the value of x.func constPat(x: Int64) {\n    match (x) {\n        case 1 => \"one\"\n        case 2 => \"two\"\n        case _ => \"_\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nPatterns can be divided into two categories: refutable patterns and irrefutable patterns. Under the premise of type matching, a pattern is referred to as a refutable pattern when there is a possibility that it does not match the value to be matched; conversely, a pattern is referred to as an irrefutable pattern when it can always match the value to be matched.\nFor the various patterns mentioned above, the following rules apply:\nThe wildcard pattern is an irrefutable pattern. For example, in the example below, _ can always match regardless of the value of x.func wildcardPat(x: Int64) {\n    match (x) {\n        case _ => \"_\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nPatterns can be divided into two categories: refutable patterns and irrefutable patterns. Under the premise of type matching, a pattern is referred to as a refutable pattern when there is a possibility that it does not match the value to be matched; conversely, a pattern is referred to as an irrefutable pattern when it can always match the value to be matched.\nFor the various patterns mentioned above, the following rules apply:\nThe binding pattern is an irrefutable pattern. For example, in the example below, the binding pattern a can always match regardless of the value of x.func varPat(x: Int64) {\n    match (x) {\n        case a => \"x = ${a}\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nPatterns can be divided into two categories: refutable patterns and irrefutable patterns. Under the premise of type matching, a pattern is referred to as a refutable pattern when there is a possibility that it does not match the value to be matched; conversely, a pattern is referred to as an irrefutable pattern when it can always match the value to be matched.\nFor the various patterns mentioned above, the following rules apply:\nThe binding pattern is an irrefutable pattern. For example, in the example below, the binding pattern a can always match regardless of the value of x.func varPat(x: Int64) {\n    match (x) {\n        case a => \"x = ${a}\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nPatterns can be divided into two categories: refutable patterns and irrefutable patterns. Under the premise of type matching, a pattern is referred to as a refutable pattern when there is a possibility that it does not match the value to be matched; conversely, a pattern is referred to as an irrefutable pattern when it can always match the value to be matched.\nFor the various patterns mentioned above, the following rules apply:\nTuple patterns are irrefutable patterns if and only if each pattern within them is an irrefutable pattern. For example, in the following example, (1, 2) and (a, 2) may not match the value of x, so they are refutable patterns, while (a, b) can match any value of x, so it is an irrefutable pattern.func tuplePat(x: (Int64, Int64)) {\n    match (x) {\n        case (1, 2) => \"(1, 2)\"\n        case (a, 2) => \"(${a}, 2)\"\n        case (a, b) => \"(${a}, ${b})\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nPatterns can be divided into two categories: refutable patterns and irrefutable patterns. Under the premise of type matching, a pattern is referred to as a refutable pattern when there is a possibility that it does not match the value to be matched; conversely, a pattern is referred to as an irrefutable pattern when it can always match the value to be matched.\nFor the various patterns mentioned above, the following rules apply:\nType patterns are refutable patterns. For example, in the following example (assuming Base is a parent class of Derived, and Base implements the interface I), the runtime type of x may not be either Base or Derived, so both a: Derived and b: Base are refutable patterns.interface I {}\nopen class Base <: I {}\nclass Derived <: Base {}\n\n\nfunc typePat(x: I) {\n    match (x) {\n        case a: Derived => \"Derived\"\n        case b: Base => \"Base\"\n        case _ => \"Other\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nPatterns can be divided into two categories: refutable patterns and irrefutable patterns. Under the premise of type matching, a pattern is referred to as a refutable pattern when there is a possibility that it does not match the value to be matched; conversely, a pattern is referred to as an irrefutable pattern when it can always match the value to be matched.\nFor the various patterns mentioned above, the following rules apply:\nEnum patterns are irrefutable patterns if and only if the corresponding enum type has only one constructor with parameters, and the other patterns in the enum pattern are also irrefutable patterns. For example, for the definitions of E1 and E2 in the following example, A(1) in the function enumPat1 is a refutable pattern, while A(a) is an irrefutable pattern; whereas B(b) and C(c) in the function enumPat2 are both refutable patterns.enum E1 {\n    A(Int64)\n}\n\n\nenum E2 {\n    B(Int64) | C(Int64)\n}\n\n\nfunc enumPat1(x: E1) {\n    match (x) {\n        case A(1) => \"A(1)\"\n        case A(a) => \"A(${a})\"\n    }\n}\n\n\nfunc enumPat2(x: E2) {\n    match (x) {\n        case B(b) => \"B(${b})\"\n        case C(c) => \"C(${c})\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nChangjie supports two types of match expressions: one that includes the value to be matched, and the other that does not include the value to be matched.\nA match expression starts with the keyword match, followed by the value to be matched (e.g., x in the previous example, where x can be any expression), and then several case branches defined within a pair of curly braces.\nEach case branch starts with the keyword case, followed by a pattern or multiple patterns of the same type connected by | (e.g., 1, 0, _ in the previous example are all patterns, see the Pattern Overview section for details); after the pattern, an optional pattern guard can be added, indicating additional conditions that need to be met for this case to match successfully; next is =>, and after => is the action to be executed if this case branch matches successfully. This can be a series of expressions, variable and function definitions (newly defined variables or functions have a scope from their point of definition to the next case), such as the variable definition and print function call in the previous example.\nWhen executing a match expression, it sequentially matches each expression following match with the patterns in each case. Once a match is successful (if there is a pattern guard, the expression after where must evaluate to true; if there are multiple patterns connected by | in a case, matching with any one of them is considered successful), the code after => is executed and then the match expression execution is exited (meaning it will not attempt to match subsequent cases). If the match is not successful, it continues to match with the patterns in the subsequent cases until a match is successful (the match expression guarantees that there will always be a matching case branch).\nIn the example, since x's value is equal to 0, it matches the second case branch (this uses a constant pattern, which matches based on value equality, see Constant Pattern section for details), and finally outputs x = 0.\nMatch expressions with matching values:main() {\n    let x = 0\n    match (x) {\n        case 1 => let r1 = \"x = 1\"\n                  print(r1)\n        case 0 => let r2 = \"x = 0\" // Matched.\n                  print(r2)\n        case _ => let r3 = \"x != 1 and x != 0\"\n                  print(r3)\n    }\n}"}
{"text": "Cangjie programming language syntax:\nThe match expression requires all matches to be exhaustive, meaning all possible values of the expression to be matched should be considered. When the match expression is not exhaustive, or the compiler cannot determine if it is exhaustive, a compilation error will occur. In other words, the union of the value ranges covered by all case branches (including pattern guards) should include all possible values of the expression to be matched. A common way to ensure the match expression is exhaustive is to use the wildcard pattern _ in the last case branch, as _ can match any value.\nThe exhaustiveness of the match expression guarantees that there is always a case branch matching the value to be matched. The following example will result in a compilation error because not all possible values of x are covered by the cases:\n\nError_case:\nfunc nonExhaustive(x: Int64) { //error\n    match (x) {\n        case 0 => print(\"x = 0\")\n        case 1 => print(\"x = 1\")\n        case 2 => print(\"x = 2\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nAfter the pattern in a case branch, you can use pattern guards to further evaluate the matched results. Pattern guards use `where cond` to express, requiring the type of expression `cond` to be `Bool`.\nIn the example below (which uses enum patterns, see the enum patterns section), when the parameter values of the RGBColor constructor are greater than or equal to 0, their values are outputted; when the parameter values are less than 0, their values are considered to be 0:enum RGBColor {\n    | Red(Int16) | Green(Int16) | Blue(Int16)\n}\nmain() {\n    let c = RGBColor.Green(-100)\n    let cs = match (c) {\n        case Red(r) where r < 0 => \"Red = 0\"\n        case Red(r) => \"Red = ${r}\"\n        case Green(g) where g < 0 => \"Green = 0\" // Matched.\n        case Green(g) => \"Green = ${g}\"\n        case Blue(b) where b < 0 => \"Blue = 0\"\n        case Blue(b) => \"Blue = ${b}\"\n    }\n    print(cs)\n}"}
{"text": "Cangjie programming language syntax:\nCompared to a match expression that contains the value to be matched, there is no expression following the keyword `match`, and after the `case` is no longer a pattern but a `Bool`-typed expression (such as `x > 0` and `x < 0` in the code above) or `_` (representing `true`), of course, there are no pattern guards in the `case` either.\nWhen a match expression without a matching value executes, it sequentially evaluates the expressions following each case until it encounters a case branch with a value of true. Once the value of an expression following a case equals true, the code following the => in that case is executed, and then the match expression execution is exited (meaning it will no longer evaluate the remaining cases after this one).\nIn the example, since the value of x is -1, the value of the expression in the second case branch (i.e., x < 0) equals true, so print(\"x < 0\") is executed.\nA match expression with no matching values:main() {\n    let x = -1\n    match {\n        case x > 0 => print(\"x > 0\")\n        case x < 0 => print(\"x < 0\") // Matched.\n        case _ => print(\"x = 0\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nFor match expressions (whether or not there is a matching value),\nWhen there is a clear type requirement in the context, the type of the code block after => in each case branch must be a subtype of the type required by the context;\nWhen there is no clear type requirement in the context, the type of the match expression is the least common parent type of the types of the code blocks after => in each case branch;\nWhen the value of the match expression is not used, its type is Unit, and there is no requirement for the types of the branches to have a least common parent type.\nIn the example，when defining the variable s, its type was explicitly marked as String, which belongs to the case where the context type information is clear. Therefore, it is required that the code blocks after each => in the case statements are subtypes of String. Clearly, the string literals after => in the above example all meet this requirement.let x = 2\nlet s: String = match (x) {\n    case 0 => \"x = 0\"\n    case 1 => \"x = 1\"\n    case _ => \"x != 0 and x != 1\" // Matched.\n}"}
{"text": "Cangjie programming language syntax:\nFor match expressions (whether or not there is a matching value),\nWhen there is a clear type requirement in the context, the type of the code block after => in each case branch must be a subtype of the type required by the context;\nWhen there is no clear type requirement in the context, the type of the match expression is the least common parent type of the types of the code blocks after => in each case branch;\nWhen the value of the match expression is not used, its type is Unit, and there is no requirement for the types of the branches to have a least common parent type.\nIn the example, when defining the variable s, its type was not explicitly specified because the type of the code block after each => in the case statements is String. Therefore, the type of the match expression is String, which in turn determines that the type of s is also String.let x = 2\nlet s = match (x) {\n    case 0 => \"x = 0\"\n    case 1 => \"x = 1\"\n    case _ => \"x != 0 and x != 1\" // Matched.\n}"}
{"text": "Cangjie programming language syntax:\nThe if-let expression first evaluates the expression on the right side of <- in the condition. If this value matches the pattern on the left side of <-, the if branch is executed; otherwise, the else branch is executed (the else branch can be omitted). For example:main() {\n    let result = Option<Int64>.Some(2023)\n\n\n    if (let Some(value) <- result) {\n        println(\"操作成功，返回值为：${value}\")\n    } else {\n        println(\"操作失败\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nif the initial value of result is modified to Option<Int64>.None, the pattern matching of if-let will fail, and the else branch will be executed:main() {\n    let result = Option<Int64>.None\n\n\n    if (let Some(value) <- result) {\n        println(\"操作成功，返回值为：${value}\")\n    } else {\n        println(\"操作失败\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nThe while-let expression first evaluates the expression on the right side of <- in the condition. If this value matches the pattern on the left side of <-, the loop body is executed, and this process is repeated. If the pattern match fails, the loop ends, and execution continues with the code following the while-let expression. For example:import std.random.*\n\n//This function simulates receiving data in communication, and obtaining data may fail\nfunc recv(): Option<UInt8> {\n    let number = Random().nextUInt8()\n    if (number < 128) {\n        return Some(number)\n    }\n    return None\n}\n\n\nmain() {\n    //Simulate a loop to receive communication data, and if it fails, end the loop\n    while (let Some(data) <- recv()) {\n        println(data)\n    }\n    println(\"receive failed\")\n}"}
{"text": "Cangjie programming language syntax:\nPatterns can be used not only in match expressions but also in variable definitions (the pattern is on the left side of the equals sign) and for in expressions (the pattern is between the for keyword and the in keyword).\nHowever, not all patterns can be used in variable definitions and for in expressions; only irrefutable patterns can be used in these two places, so only wildcard patterns, binding patterns, irrefutable tuple patterns, and irrefutable enum patterns are allowed.\nIn the example, wildcard patterns are used in variable definition, indicating that an unnamed variable is defined (of course, it can no longer be accessed afterward), and in the `for in` expression, the wildcard pattern is used, indicating that elements from 1..5 will not be bound to any variable (thus, the values of elements in 1..5 cannot be accessed within the loop body).main() {\n    let _ = 100\n    for (_ in 1..5) {\n        println(\"0\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn the example, `x` in the variable definition and `i` in the `for in` expression are both binding patterns. Examples of variable definition and using binding patterns in `for in` expressions are as follows:main() {\n    let x = 100\n    println(\"x = ${x}\")\n    for (i in 1..5) {\n        println(i)\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn the example, the tuple pattern is used in variable definition, which destructures (100, 200) and binds them respectively to x and y, effectively equivalent to defining two variables x and y. The for-in expression uses the tuple pattern, which sequentially extracts tuple-type elements from [(1, 2), (3, 4), (5, 6)], then destructures and binds them respectively to i and j. The value of i + j is output in the loop body.Examples of variable definition and using irrefutable tuple pattern in for-in expressions are as follows:main() {\n    let (x, y) = (100, 200)\n    println(\"x = ${x}\")\n    println(\"y = ${y}\")\n    for ((i, j) in [(1, 2), (3, 4), (5, 6)]) {\n        println(\"Sum = ${i + j}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn the example, the enum pattern is used in variable definition, which destructures Red(0) and binds the constructor's parameter value (i.e., 0) to red. The for-in expression uses the enum pattern, which sequentially extracts elements from [Red(10), Red(20), Red(30)], then destructures and binds the constructor's parameter value to r. The value of r is output in the loop body. Examples of variable definition and using irrefutable enum pattern in for-in expressions are as follows:enum RedColor {\n    Red(Int64)\n}\nmain() {\n    let Red(red) = Red(0)\n    println(\"red = ${red}\")\n    for (Red(r) in [Red(10), Red(20), Red(30)]) {\n        println(\"r = ${r}\")\n    }\n}"}
