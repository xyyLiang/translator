{"text": "Cangjie programming language syntax:\nThe definition of a struct type begins with the keyword struct, followed by the name of the struct, and then the struct definition body enclosed in a pair of curly braces. The struct definition body can define a series of member variables, member properties (see Properties), static initializers, constructors, and member functions.\nStruct can only be defined in the top-level scope of a source file.\nIn the example, a struct type named Rectangle is defined, which has two member variables of type Int64: width and height, a constructor with two Int64 type parameters (defined using the keyword init, with the function body typically initializing the member variables), and a member function area (which returns the product of width and height).struct Rectangle {\n    let width: Int64\n    let height: Int64\n\n\n    public init(width: Int64, height: Int64) {\n        this.width = width\n        this.height = height\n    }\n\n\n    public func area() {\n        width * height\n    }\n}"}
{"text": "Cangjie programming language syntax:\nstruct member variables are divided into instance member variables and static member variables (modified with the static modifier). The difference in access between the two lies in that instance member variables can only be accessed through struct instances (a is an instance of type T means a is a value of type T), while static member variables can only be accessed through the struct type name.\nInstance member variables can be defined without initializing them (but must specify the type, such as width and height in the example above), or they can be initialized, for example:struct Rectangle {\n    let width = 10\n    let height = 20\n}"}
{"text": "Cangjie programming language syntax:\nstruct supports defining static initializers, and can initialize static member variables through assignment expressions within the static initializer.\nStatic initializers start with the keyword combination static init, followed by an empty parameter list and a function body, and cannot be modified by access modifiers. The function body must complete the initialization of all uninitialized static member variables, otherwise the compilation will report an error.struct Rectangle {\n    static let degree: Int64\n    static init() {\n        degree = 180\n    }\n}"}
{"text": "Cangjie programming language syntax:\nA struct is allowed to define at most one static initializer, otherwise a redefinition error will occur.struct Rectangle {\n    static let degree: Int64\n    static init() {\n        degree = 180\n    }\n    static init() { // Error, redefinition with the previous static init function\n        degree = 180\n    }\n}"}
{"text": "Cangjie programming language syntax:\nstruct supports two types of constructors: regular constructors and primary constructors.\nA regular constructor starts with the keyword init, followed by a parameter list and a function body. The function body must complete the initialization of all uninitialized instance member variables (if the parameter names and member variable names cannot be distinguished, you can use this before the member variable to distinguish them, this represents the current instance of the struct), otherwise the compilation will report an error.struct Rectangle {\n    let width: Int64\n    let height: Int64\n\n\n    public init(width: Int64, height: Int64) { // Error, 'height' is not initialized in the constructor\n        this.width = width\n    }\n}"}
{"text": "Cangjie programming language syntax:\nstruct supports two types of constructors: regular constructors and primary constructors.\nMultiple regular constructors can be defined in a struct, but they must constitute overloading (see Function Overloading), otherwise a redefinition error will be reported.struct Rectangle {\n    let width: Int64\n    let height: Int64\n\n\n    public init(width: Int64) {\n        this.width = width\n        this.height = width\n    }\n\n\n    public init(width: Int64, height: Int64) { // Ok: overloading with the first init function\n        this.width = width\n        this.height = height\n    }\n\n\n    public init(height: Int64) { // Error, redefinition with the first init function\n        this.width = height\n        this.height = height\n    }\n}"}
{"text": "Cangjie programming language syntax:\nstruct supports two types of constructors: regular constructors and primary constructors.\nIn addition to defining multiple ordinary constructors named with init, a struct can also define (at most) one primary constructor. The primary constructor's name is the same as the struct type name, and its parameter list can have two forms of formal parameters: ordinary parameters and member variable parameters (which need to be prefixed with let or var). Member variable parameters serve the dual function of defining member variables and constructor parameters.\nUsing the primary constructor can often simplify the definition of a struct. For example, the Rectangle above, which includes an init constructor, can be simplified to the following definition:struct Rectangle {\n    public Rectangle(let width: Int64, let height: Int64) {}\n}"}
{"text": "Cangjie programming language syntax:\nstruct supports two types of constructors: regular constructors and primary constructors.\nIn addition to defining multiple ordinary constructors named with init, a struct can also define (at most) one primary constructor. The primary constructor's name is the same as the struct type name, and its parameter list can have two forms of formal parameters: ordinary parameters and member variable parameters (which need to be prefixed with let or var). Member variable parameters serve the dual function of defining member variables and constructor parameters.\nThe parameter list of the main constructor can also define ordinary formal parameters, for example:struct Rectangle {\n    public Rectangle(name: String, let width: Int64, let height: Int64) {}\n}"}
{"text": "Cangjie programming language syntax:\nIf there is no custom constructor defined in the struct (including the primary constructor), and all instance member variables have initial values, it will automatically generate a parameterless constructor (invoking this parameterless constructor will create an object where all instance member variables are initialized to their initial values); otherwise, this parameterless constructor will not be automatically generated. For example, for the following struct definition, the automatically generated parameterless constructor is given in the comments:struct Rectangle {\n    let width: Int64 = 10\n    let height: Int64 = 10\n    /* Auto-generated memberwise constructor:\n    public init() {\n    }\n    */\n}"}
{"text": "Cangjie programming language syntax:\nMember functions of a struct are divided into instance member functions and static member functions (modified using the static modifier). The difference between the two lies in: instance member functions can only be accessed through struct instances, while static member functions can only be accessed through the struct type name; static member functions cannot access instance member variables or call instance member functions, but instance member functions can access static member variables and static member functions.\nIn the example below, area is an instance member function, and typeName is a static member function.struct Rectangle {\n    let width: Int64 = 10\n    let height: Int64 = 20\n\n\n    public func area() {\n        this.width * this.height\n    }\n\n    public static func typeName(): String {\n        \"Rectangle\"\n    }\n}"}
{"text": "Cangjie programming language syntax:\nMember functions of a struct are divided into instance member functions and static member functions (modified using the static modifier). \nInstance member functions can access instance member variables through this, for example:struct Rectangle {\n    let width: Int64 = 1\n    let height: Int64 = 1\n\n\n    public func area() {\n        this.width * this.height\n    }\n}"}
{"text": "Cangjie programming language syntax:\nThe members of a struct (including member variables, member attributes, constructors, member functions, and operator functions (see the Operator Overloading chapter for details)) are modified by four access modifiers: private, internal, protected, and public. The default modifier is internal.\nIn the example below, width is a member modified by public, accessible outside the class, while height is a member with the default access modifier, visible only in the current package and its sub-packages, and cannot be accessed by other packages.package a\npublic struct Rectangle {\n    public var width: Int64\n    var height: Int64\n    private var area: Int64\n    ...\n}\nfunc samePkgFunc() {\n    var r = Rectangle(10, 20)\n    r.width = 8               // Ok: public 'width' can be accessed here\n    r.height = 24             // Ok: 'height' has no modifier and can be accessed here\n    r.area = 30               // Error, private 'area' can't be accessed here\n}\n\npackage b\nimport a.*\nmain() {\n    var r = Rectangle(10, 20)\n    r.width = 8               // Ok: public 'width' can be accessed here\n    r.height = 24             // Error, no modifier 'height' can't be accessed here\n    r.area = 30               // Error, private 'area' can't be accessed here\n}"}
{"text": "Cangjie programming language syntax:\nStructs defined recursively and mutually recursively are illegal. For example:\n\nError_case:\nstruct R1 { // Error, 'R1' recursively references itself\n    let other: R1\n}\nstruct R2 { // Error, 'R2' and 'R3' are mutually recursive\n    let other: R3\n}\nstruct R3 { // Error, 'R2' and 'R3' are mutually recursive\n    let other: R2\n}"}
{"text": "Cangjie programming language syntax:\nAfter defining the struct type, you can create struct instances by calling the struct's constructor. Outside the struct definition, invoke the constructor using the struct type name. For example, in the following example, a variable r of type Rectangle is defined.\nAfter creating a struct instance, you can access instance member variables and instance member functions that satisfy visibility modifiers (such as public) through the instance. For example, in the following example, you can access the values of width and height in r through r.width and r.height, and you can call the member function area of r through r.area().let r = Rectangle(10, 20)\nlet r = Rectangle(10, 20)\nlet width = r.width   // width = 10\nlet height = r.height // height = 20\nlet a = r.area()      // a = 200"}
{"text": "Cangjie programming language syntax:\nIf you want to modify the values of member variables through a struct instance, you need to define the struct type variable as a mutable variable, and the member variable being modified must also be a mutable member variable (defined using var). Here is an example:struct Rectangle {\n    public var width: Int64\n    public var height: Int64\n\n\n    public init(width: Int64, height: Int64) {\n        this.width = width\n        this.height = height\n    }\n\n\n    public func area() {\n        width * height\n    }\n}\n\n\nmain() {\n    var r = Rectangle(10, 20) // r.width = 10, r.height = 20\n    r.width = 8               // r.width = 8\n    r.height = 24             // r.height = 24\n    let a = r.area()          // a = 192\n}"}
{"text": "Cangjie programming language syntax:\nWhen assigning or passing parameters, struct instances are copied (when member variables are reference types, only the reference is copied, not the referenced object), generating a new instance. Modifications to one instance will not affect the other. Taking assignment as an example, in the following example, after assigning r1 to r2, modifying the width and height of r1 will not affect the width and height of r2.struct Rectangle {\n    public var width: Int64\n    public var height: Int64\n\n\n    public init(width: Int64, height: Int64) {\n        this.width = width\n        this.height = height\n    }\n\n\n    public func area() {\n        width * height\n    }\n}\n\n\nmain() {\n    var r1 = Rectangle(10, 20) // r1.width = 10, r1.height = 20\n    var r2 = r1                // r2.width = 10, r2.height = 20\n    r1.width = 8               // r1.width = 8\n    r1.height = 24             // r1.height = 24\n    let a1 = r1.area()         // a1 = 192\n    let a2 = r2.area()         // a2 = 200\n}"}
{"text": "Cangjie programming language syntax:\nThe struct type is a value type, and its instance member functions cannot modify the instance itself. \nThe mut function is a special instance member function that can modify the struct instance itself. Inside the mut function, the semantics of this are special, and this has the ability to modify fields in place.\nOnly mut functions can be defined within interfaces, structs, and struct extensions (classes are reference types, instance member functions can modify instance member variables without needing mut, so mut functions are prohibited from being defined in classes).\nFor example, in the following example, the member function g cannot modify the value of the member variable i.struct Foo {\n    var i = 0\n\n\n    public func g() {\n        i += 1  // Error, the value of a instance member variable cannot be modified in an instance member function\n    }\n}"}
{"text": "Cangjie programming language syntax:\nCompared to ordinary instance member functions, mut functions have an additional mut keyword to modify them.\nFor example, after adding the mut modifier before the function g in the following example, the value of the member variable i can be modified within the function body.struct Foo {\n    var i = 0\n\n\n    public mut func g() {\n        i += 1  // Ok\n    }\n}"}
{"text": "Cangjie programming language syntax:\nmut can only modify instance member functions, not static member functions.struct A {\n    public mut func f(): Unit {} // Ok\n    public mut operator func +(rhs: A): A { // Ok\n        A()\n    }\n    public mut static func g(): Unit {} // Error, static member functions cannot be modified with 'mut'\n}"}
{"text": "Cangjie programming language syntax:\nIn a mut function, this cannot be captured and cannot be used as an expression. Lambdas or nested functions in a mut function cannot capture instance member variables of a struct.\n\nError_case:\nstruct Foo {\n    var i = 0\n\n\n    public mut func f(): Foo {\n        let f1 = { => this } // Error, 'this' in mut functions cannot be captured\n        let f2 = { => this.i = 2 } // Error, instance member variables in mut functions cannot be captured\n        let f3 = { => this.i } // Error, instance member variables in mut functions cannot be captured\n        let f4 = { => i } // Error, instance member variables in mut functions cannot be captured\n        this // Error, 'this' in mut functions cannot be used as expressions\n    }\n}"}
{"text": "Cangjie programming language syntax:\nInstance member functions in interfaces can also be modified with mut.\nThe struct type must maintain the same mut modifier when implementing functions of an interface. Types other than struct cannot use the mut modifier when implementing functions of an interface.interface I {\n    mut func f1(): Unit\n    func f2(): Unit\n}\n\n\nstruct A <: I {\n    public mut func f1(): Unit {} // Ok: as in the interface, the 'mut' modifier is used\n    public func f2(): Unit {} // Ok: as in the interface, the 'mut' modifier is not used\n}\n\n\nstruct B <: I {\n    public func f1(): Unit {} // Error, 'f1' is modified with 'mut' in interface, but not in struct\n    public mut func f2(): Unit {} // Error, 'f2' is not modified with 'mut' in interface, but did in struct\n}\n\n\nclass C <: I {\n    public func f1(): Unit {} // Ok\n    public func f2(): Unit {} // Ok\n}"}
{"text": "Cangjie programming language syntax:\nWhen an instance of a struct is assigned to an interface type, it is a copy semantics, so the mut function of the interface cannot modify the value of the struct instance.interface I {\n    mut func f(): Unit\n}\nstruct Foo <: I {\n    public var v = 0\n    public mut func f(): Unit {\n        v += 1\n    }\n}\nmain() {\n    var a = Foo()\n    var b: I = a  \n    b.f()  // Calling 'f' via 'b' cannot modify the value of 'a'\n    println(a.v) // 0\n}"}
{"text": "Cangjie programming language syntax:\nSince struct is a value type, if a variable is of struct type and declared using let, it cannot access the mut function of that type.interface I {\n    mut func f(): Unit\n}\nstruct Foo <: I {\n    public var i = 0\n    public mut func f(): Unit {\n        i += 1\n    }\n}\nmain() {\n    let a = Foo()\n    a.f() // Error, 'a' is of type struct and is declared with 'let', the 'mut' function cannot be accessed via 'a'\n    var b = Foo()\n    b.f() // Ok\n    let c: I = Foo()\n    c.f() // Ok, 变量 c 为接口 I 类型，非 struct 类型，此处允许访问。\n}"}
{"text": "Cangjie programming language syntax:\nTo avoid escaping, if a variable's type is struct, that variable cannot use the type with mut modifier functions as a first-class citizen; it can only call these mut functions.interface I {\n    mut func f(): Unit\n}\n\n\nstruct Foo <: I {\n    var i = 0\n\n\n    public mut func f(): Unit {\n        i += 1\n    }\n}\n\n\nmain() {\n    var a = Foo()\n    var fn = a.f // Error, mut function 'f' of 'a' cannot be used as a first class citizen.\n    var b: I = Foo()\n    fn = b.f // Ok\n}"}
{"text": "Cangjie programming language syntax:\nTo avoid escaping, non-mut instance member functions (including lambda expressions) cannot directly access the mut functions of their enclosing type, whereas the reverse is true.struct Foo {\n    var i = 0\n\n\n    public mut func f(): Unit {\n        i += 1\n        g() // Ok\n    }\n\n\n    public func g(): Unit {\n        f() // Error, mut functions cannot be invoked in non-mut functions\n    }\n}\n\n\ninterface I {\n    mut func f(): Unit {\n        g() // Ok\n    }\n\n\n    func g(): Unit {\n        f() // Error, mut functions cannot be invoked in non-mut functions\n    }\n}"}
