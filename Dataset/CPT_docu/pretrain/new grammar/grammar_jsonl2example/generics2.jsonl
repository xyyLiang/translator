{"text": "Cangjie programming language syntax:\nIn the Cangjie programming language, generics refer to parameterized types, where parameterized types are types that are unknown at declaration time and need to be specified at use time. Type declarations and function declarations can be generic. The most common examples are container types like Array<T>, Set<T>, etc.\n\nIn Falcon, the declarations of function, class, interface, struct, and enum can all declare type parameters, meaning they can all be generic.\n\n  For the sake of discussion, let's define the following common terms:\n\nType Parameter: A type or function declaration may have one or more types that need to be specified at the point of use; these types are referred to as type parameters. When declaring parameters, an identifier must be given to reference them within the declaration body.\nType Argument: After declaring type parameters, when these types are referenced using identifiers, these identifiers are called type arguments.\nType Arguments: When specifying generic parameters when using a type or function declared with generics, these parameters are called type arguments.\nType Constructor: A type that requires zero, one, or more types as arguments is called a type constructor.\nType Parameters are generally declared after the type name or function name declaration, enclosed in angle brackets <...>. For example, In which T in List<T> is called a type parameter. For the reference to T in elem: Option<T>, it is called a type variable, similarly T in tail: Option<List<T>> is also called a type variable. The Int64 in the parameter of the function sumInt, where List<Int64> is called the type argument of List. List is the type constructor, and List<Int64> constructs a list type of type Int64 using the type argument Int64. The generic list can be declared as:class List<T> {\n    var elem: Option<T> = None\n    var tail: Option<List<T>> = None\n}\n\n\nfunc sumInt(a: List<Int64>) {  }"}
{"text": "Cangjie programming language syntax:\nIf a function declares one or more type parameters, it is called a generic function. Syntactically, the type parameters follow the function name and are enclosed in <>; if there are multiple type parameters, they are separated by.\nWhen declaring a global generic function, you only need to declare the type parameter in angle brackets after the function name, and then you can reference this type parameter in the function parameters, return type, and function body. For example, (a: T) is the formal parameter in the function declaration, which uses the type parameter T declared in the id function, and it is also used in the return type of the id function. the id function is defined as:func id<T>(a: T): T {\n    return a\n}"}
{"text": "Cangjie programming language syntax:\nFor another complex example, define a generic function composition, which declares three type parameters: T1, T2, and T3. Its function is to combine two functions f: (T1) -> T2 and g: (T2) -> T3 into a function of type (T1) -> T3.func composition<T1, T2, T3>(f: (T1) -> T2, g: (T2) -> T3): (T1) -> T3 {\n    return {x: T1 => g(f(x))}\n}"}
{"text": "Cangjie programming language syntax:\nBecause the functions that can be composed are of any type, for example, they can be compositions like (Int32) -> Bool, (Bool) -> Int64, or (Int64) -> Rune, (Rune) -> Int8, so generic functions are needed.func times2(a: Int64): Int64 {\n    return a * 2\n}\n\nfunc plus10(a: Int64): Int64 {\n    return a + 10\n}\n\nfunc times2plus10(a: Int64) {\n    return composition<Int64, Int64, Int64>(times2, plus10)(a)\n}\n\nmain() {\n  println(times2plus10(9))\n  return 0\n}"}
{"text": "Cangjie programming language syntax:\nLocal functions can also be generic functions. For example, the generic function id can be nested defined within other functions:func foo(a: Int64) {\n    func id<T>(a: T): T { a }\n\n    func double(a: Int64): Int64 { a + a }\n\n    return (id<Int64> ~> double)(a) == (double ~> id<Int64>)(a)\n}\n\n\nmain() {\n    println(foo(1))\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nMember functions of class, struct, and enum can be generic. For example:class A {\n    func foo<T>(a: T): Unit where T <: ToString {\n        println(\"${a}\")\n    }\n}\n\n\nstruct B {\n    func bar<T>(a: T): Unit where T <: ToString {\n        println(\"${a}\")\n    }\n}\n\n\nenum C {\n    | X | Y\n\n\n    func coo<T>(a: T): Unit where T <: ToString {\n        println(\"${a}\")\n    }\n}\n\n\nmain() {\n    var a = A()\n    var b = B()\n    var c = C.X\n    a.foo<Int64>(10)\n    b.bar<String>(\"abc\")\n    c.coo<Bool>(false)\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nIt's important to note that generic member functions declared in a class cannot be modified with the `open` keyword. If they are modified with `open`, an error will occur, for example:class A {\n    public open func foo<T>(a: T): Unit where T <: ToString { // Error, open generic function is not allowed\n        println(\"${a}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nWhen extending a type using the `extend` declaration, the extended functions can also be generic, for example, you can add a generic member function to the `Int64` type:extend Int64 {\n    func printIntAndArg<T>(a: T) where T <: ToString {\n        println(this)\n        println(\"${a}\")\n    }\n}\n\n\nmain() {\n    var a: Int64 = 12\n    a.printIntAndArg<String>(\"twelve\")\n}"}
{"text": "Cangjie programming language syntax:\nStatic generic functions can be defined in interfaces, classes, structs, and enums. For example, in the ToPair class below, a tuple is returned from an ArrayList:import std.collection.*\n\n\nclass ToPair {\n    public static func fromArray<T>(l: ArrayList<T>): (T, T) {\n        return (l[0], l[1])\n    }\n}\n\n\nmain() {\n    var res: ArrayList<Int64> = ArrayList([1,2,3,4])\n    var a: (Int64, Int64) = ToPair.fromArray<Int64>(res)\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nGenerics can be used to define generic interfaces. Taking Iterable from the standard library as an example, its member function iterator needs to return an Iterator type, which is a container iterator. Iterator is a generic interface, and inside Iterator, there is a next member function that returns the next element from the container type. The type returned by the next member function is a type that needs to be specified at use time, so Iterator needs to declare a generic parameter.public interface Iterable<E> {\n    func iterator(): Iterator<E>\n}\n\n\npublic interface Iterator<E> <: Iterable<E> {\n    func next(): Option<E>\n}\n\n\npublic interface Collection<T> <: Iterable<T> {\n     prop size: Int64\n     func isEmpty(): Bool\n}"}
{"text": "Cangjie programming language syntax:\nGeneric interfaces introduce the definition and usage of generic interfaces, and this section introduces the definition and usage of generic classes. For example, the key-value pairs of Map are defined using generic classes.\n\nIn the Map type, key-value pairs of the Node type can be defined using generic classes.Since the types of keys and values may be different and can be any type that meets the conditions, Node needs two type parameters K and V. K <: Hashable, K <: Equatable<K> are constraints for the key type, meaning K must implement the Hashable and Equatable<K> interfaces, which are the conditions that K needs to satisfy. For generic constraints, see the Generic Constraints chapter.public open class Node<K, V> where K <: Hashable & Equatable<K> {\n    public var key: Option<K> = Option<K>.None\n    public var value: Option<V> = Option<V>.None\n\n\n    public init() {}\n\n\n    public init(key: K, value: V) {\n        this.key = Option<K>.Some(key)\n        this.value = Option<V>.Some(value)\n    }\n}"}
{"text": "Cangjie programming language syntax:\nstruct type generics are similar to class. Below, you can use struct to define a type similar to a binary tuple:struct Pair<T, U> {\n    let x: T\n    let y: U\n    public init(a: T, b: U) {\n        x = a\n        y = b\n    }\n    public func first(): T {\n        return x\n    }\n    public func second(): U {\n        return y\n    }\n}\n\n\nmain() {\n    var a: Pair<String, Int64> = Pair<String, Int64>(\"hello\", 0)\n    println(a.first())\n    println(a.second())\n}"}
{"text": "Cangjie programming language syntax:\nIn the generic enum type design of the Cangjie programming language, the Option type is a typical example. For detailed description of Option, please refer to the Option type chapter. The Option type is used to represent that the value of a certain type may be empty. This way, Option can be used to represent a failure in computation on a certain type. It is uncertain on what type the failure occurs, so it is clear that Option is a generic type that requires a type parameter to be declared.package std.core // `Option` is defined in std.core.\n\n\npublic enum Option<T> {\n      Some(T)\n    | None\n\n\n    public func getOrThrow(): T {\n        match (this) {\n            case Some(v) => v\n            case None => throw NoneValueException()\n        }\n    }\n    ...\n}"}
{"text": "Cangjie programming language syntax:\nIt can be seen that Option<T> is divided into two cases, one is Some(T), used to represent a return result with a value, and the other is None, used to represent an empty result. The getOrThrow function is the function that returns the value inside Some(T), and the returned result is of type T. If the parameter is None, an exception is thrown directly.\n\nFor example, if you want to define a safe division, because the calculation in division may fail. If the divisor is 0, return None, otherwise return a result wrapped in Some.In this way, when the divisor is 0, the program will not throw an arithmetic exception due to division by 0 during execution.func safeDiv(a: Int64, b: Int64): Option<Int64> {\n    var res: Option<Int64> = match (b) {\n                case 0 => None\n                case _ => Some(a/b)\n            }\n    return res\n}"}
{"text": "Cangjie programming language syntax:\nGeneric types instantiated also have a subtype relationship. For exampleï¼ŒAccording to class C<Z> <: I<Z, Z> { }, it is known that C<Bool> <: I<Bool, Bool> and C<D> <: I<D, D> etc. This can be interpreted as \"for all (non-type parameterized) Z types, C<Z> <: I<Z, Z> holds true.\"interface I<X, Y> { }\nclass C<Z> <: I<Z, Z> { }"}
{"text": "Cangjie programming language syntax:\nI<D> <: I<C> does not hold (even if D <: C holds true), because in the Kaiten language, user-defined type constructors are not covariant at their type parameters.\n\nThe specific definition of covariance is: If A and B are (instantiated) types, T is a type constructor, and there is a type parameter X (e.g., interface T<X>), then\n\nIf T(A) <: T(B) if and only if A = B, then T is invariant.\nIf T(A) <: T(B) if and only if A <: B, then T is covariant at X.\nIf T(A) <: T(B) if and only if B <: A, then T is contravariant at X.\nSince in the current stage of Cangjie, all user-defined generic types are invariant at all their type parameters, given an interface I<X> and types A and B, only A = B can derive I<A> <: I<B>; conversely, if I<A> <: I<B> is known, A = B can also be derived (except for built-in types: built-in tuple types are covariant to each element type; built-in function types are contravariant at their parameter types and covariant at their return types.)\n\nGenerics impose some limitations on language expressiveness but also avoid certain security issues, such as the problem of \"covariant arrays throwing exceptions at runtime.\"open class C { }\nclass D <: C { }\n\n\ninterface I<X> { }"}
{"text": "Cangjie programming language syntax:\nWhen the name of a type is complex or not intuitive in a specific context, you can choose to use a type alias to set an alias for this type.The definition of a type alias starts with the keyword `type`, followed by the type alias (such as `I64` in the previous example), then an equal sign `=`, and finally the original type (i.e., the type being aliased, such as `Int64` in the previous example).type I64 = Int64"}
{"text": "Cangjie programming language syntax:\nType aliases can only be defined at the top level of a source file, and the original type must be visible at the point of alias definition. For example, in the following case, defining the alias for `Int64` in `main` will result in an error, and defining an alias for `LongNameClassB` when it is not visible will also result in an error.\n\nError_case:\nmain() {\n    type I64 = Int64 // Error, type aliases can only be defined at the top level of the source file\n}\n\n\nclass LongNameClassA { }\ntype B = LongNameClassB // Error, type 'LongNameClassB' is not defined"}
{"text": "Cangjie programming language syntax:\nA (or multiple) type alias definitions must not contain (direct or indirect) cyclic references.type A = (Int64, A) // Error, 'A' refered itself\ntype B = (Int64, C) // Error, 'B' and 'C' are circularly refered\ntype C = (B, Int64)"}
{"text": "Cangjie programming language syntax:\nA type alias does not define a new type; it merely defines an alternative name for the original type. It has the following use cases:\n Used as a type, for example:type A = B\nclass B {}\nvar a: A = B() // Use typealias A as type B"}
{"text": "Cangjie programming language syntax:\nA type alias does not define a new type; it merely defines an alternative name for the original type. It has the following use cases:\nWhen the actual type pointed to by the type alias is class, struct, it can be used as a constructor name:type A = B\nclass B {}\nfunc foo() { A() }  // Use type alias A as constructor of B"}
{"text": "Cangjie programming language syntax:\nA type alias does not define a new type; it merely defines an alternative name for the original type. It has the following use cases:\nWhen the actual type pointed to by the type alias is class, interface, struct, it can be used as the type name for accessing internal static member variables or functions:type A = B\nclass B {\n    static var b : Int32 = 0;\n    static func foo() {}\n}\nfunc foo() {\n    A.foo() // Use A to access static method in class B\n    A.b\n}"}
{"text": "Cangjie programming language syntax:\nA type alias does not define a new type; it merely defines an alternative name for the original type. It has the following use cases:\nWhen the actual type pointed to by the type alias is enum, it can be used as the type name for the constructor of the enum declaration:enum TimeUnit {\n    Day | Month | Year\n}\ntype Time = TimeUnit\nvar a = Time.Day  \nvar b = Time.Month   // Use type alias Time to access constructors in TimeUnit"}
{"text": "Cangjie programming language syntax:\nNote that current user-defined type aliases are not supported in type conversion expressions. Refer to the following example:type MyInt = Int32\nMyInt(0)  // Error, no matching function for operator '()' function call"}
{"text": "Cangjie programming language syntax:\nType aliases can also declare type parameters, but they cannot use where declarations for their parameters. Constraints for generic parameters will be explained later.\n\nWhen the name of a generic type is too long, you can use a type alias to declare a shorter alias for it. For example, a type named RecordData can be abbreviated as RD using a type alias:struct RecordData<T> {\n    var a: T\n    public init(x: T){\n        a = x\n    }\n}\n\n\ntype RD<T> = RecordData<T>\n\n\nmain(): Int64 {\n    var struct1: RD<Int32> = RecordData<Int32>(2)\n    return 1\n}"}
{"text": "Cangjie programming language syntax:\nThe role of generic constraints is to specify the operations and capabilities that generic type parameters possess when declaring functions, classes, interfaces, structs, or enums. Only by declaring these constraints can the corresponding member functions be called. In many scenarios, generic type parameters need to be constrained. Taking the id function as an example:func id<T>(a: T) {\n    return a\n}"}
{"text": "Cangjie programming language syntax:\nThe only thing that can be done is to return the value of the function parameter a, and not perform operations like a + 1 or println(\"${a}\") because it could be an arbitrary type, such as (Bool) -> Bool, making it impossible to add it to an integer. Similarly, because it is a function type, it cannot be output to the command line using the println function. However, if this generic parameter has constraints, more operations can be performed.\n\nConstraints are generally divided into interface constraints and subtype constraints. The syntax is to use the where keyword before the declaration of the function or type to declare the constraints. For the declared generic parameters T1, T2, you can declare generic constraints using where T1 <: Interface, T2 <: Type. Multiple constraints for the same type parameter can be connected using &. For example: where T1 <: Interface1 & Interface2.\n\nThe println function in Khronos can accept parameters of type string. If you need to convert a variable of a generic type to a string and print it to the command line, you can impose a constraint on this generic type parameter. This constraint is the ToString interface defined in core, which is clearly an interface constraint:package core // `ToString` is defined in core.\n\n\npublic interface ToString {\n    func toString(): String\n}"}
{"text": "Cangjie programming language syntax:\nConstraints are generally divided into interface constraints and subtype constraints. The syntax is to use the where keyword before the declaration of the function or type to declare the constraints. For the declared generic parameters T1, T2, you can declare generic constraints using where T1 <: Interface, T2 <: Type. Multiple constraints for the same type parameter can be connected using &. For example: where T1 <: Interface1 & Interface2.\n\nWith this constraint, you can define a function named genericPrint:func genericPrint<T>(a: T) where T <: ToString {\n    println(a)\n}\n\n\nmain() {\n    genericPrint<Int64>(10)\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nIf the type argument of the genericPrint function does not implement the ToString interface, the compiler will report an error. For example, when passing a function as a parameter.If the file is compiled, the compiler will throw an error that the generic type parameter does not satisfy the constraint. Because the type argument of the genericPrint function does not satisfy the constraint (Int64) -> Int64 <: ToString.func genericPrint<T>(a: T) where T <: ToString {\n    println(a)\n}\n\n\nmain() {\n    genericPrint<(Int64) -> Int64>({ i => 0 })\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nIn addition to expressing constraints through interfaces, you can also use subtypes to constrain a generic type parameter. For example: when declaring a Zoo<T> type, but requiring that the type parameter T declared here be constrained, the constraint is that T needs to be a subtype of the Animal type, where the Animal type declares a run member function. Here, two subtypes Dog and Fox are declared, both of which implement the run member function. This way, in the Zoo<T> type, you can call the run member function on animal instances stored in the animals array list:import std.collection.*\n\n\nabstract class Animal {\n    public func run(): String\n}\n\n\nclass Dog <: Animal {\n    public func run(): String {\n        return \"dog run\"\n    }\n}\n\n\nclass Fox <: Animal {\n    public func run(): String {\n        return \"fox run\"\n    }\n}\n\n\nclass Zoo<T> where T <: Animal {\n    var animals: ArrayList<Animal> = ArrayList<Animal>()\n    public func addAnimal(a: T) {\n        animals.append(a)\n    }\n\n\n    public func allAnimalRuns() {\n        for(a in animals) {\n            println(a.run())\n        }\n    }\n}\n\n\nmain() {\n    var zoo: Zoo<Animal> = Zoo<Animal>()\n    zoo.addAnimal(Dog())\n    zoo.addAnimal(Fox())\n    zoo.allAnimalRuns()\n    return 0\n}"}
