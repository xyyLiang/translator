{"text": "Cangjie programming language syntax:\n"}
{"text": "Cangjie programming language syntax:\n"}
{"text": "Cangjie programming language syntax:\nAs projects grow in size, it becomes difficult to manage the source code in just one very large file. In this case, the source code can be grouped according to functions, and the code of different functions can be managed separately, and each group of independently managed code will generate an output file. When using, project management is more efficient by importing the corresponding output files to use the corresponding functions, or through the interaction and combination of different functions to achieve more complex features.\n\nIn the Cangjie programming language, a package is the smallest unit of compilation, and each package can output AST files, static library files, dynamic library files and other products independently. Each package has its own namespace, and top-level definitions or declarations with the same name are not allowed in the same package (except for function overloads). Multiple source files can be included in a package.\n\nA module is a collection of packages and is the smallest unit published by a third-party developer. The program entry of a module can only be in its root directory, and its top level can only have at most one main as the program entry, which has no parameters or the parameter type is Array, and the return type is integer type or Unit type."}
{"text": "Cangjie programming language syntax:\nIn the Cangjie programming language, package declarations start with the keyword package, followed by the root package to the current package and run by . The package name that separates all packages on the path. The package name must be a legitimate, common identifier (without the original identifier). For example:package pkg1      // root package pkg1\npackage pkg1.sub1 // root package pkg1's subpackage  sub1"}
{"text": "Cangjie programming language syntax:\nThe package declaration must be on the first line of the source file that is not empty or commented, and the package declaration must be consistent for different source files within the same package.// file 1\n// Comments are accepted\npackage test\n// declarations...\n\n// file 2\nlet a = 1 // Error, package declaration must appear first in a file\npackage test\n// declarations..."}
{"text": "Cangjie programming language syntax:\nThe package name of Cangjie should reflect the path of the current source file relative to the root directory src of the project's source code, and replace the path separator with a decimal point. For example, if the source code of a package is under src/directory_0/directory_1 and the root package name is pkg, the package declaration in its source code should be package pkg.directory_0.directory_1.\n\n  It is important to note that:\n\n  The folder name of the package must be the same as the package name.\n  By default, the root directory of the source code is src.\nPackages in the root directory of the source code can have no package declaration, and the compiler will specify the package name default by default.\n  Suppose the source code directory structure looks like this:\n// The directory structure is as follows:\nsrc\n`-- directory_0\n    |-- directory_1\n    |    |-- a.cj\n    |    `-- b.cj\n    `-- c.cj\n`-- main.cjThe package declarations in a.cj, b.cj, c.cj, main.cj can be:\n// a.cj\n// in file a.cj, the declared package name must correspond to relative path directory_0/directory_1.\npackage default.directory_0.directory_1\n\n// b.cj\n// in file b.cj, the declared package name must correspond to relative path directory_0/directory_1.\npackage default.directory_0.directory_1\n\n// c.cj\n// in file c.cj, the declared package name must correspond to relative path directory_0.\npackage default.directory_0\n\n// main.cj\n// file main.cj is in the module root directory and may omit package declaration.\nmain() {\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nIn addition, package declarations must not cause naming conflicts: subpackages cannot have the same name as the top-level declaration of the current package.\n\n  Here are some examples of errors:// a.cj\npackage a\npublic class B { // Error, 'B' is conflicted with sub-package 'a.B'\n    public static func f() {}\n}\n\n\n// b.cj\npackage a.B\npublic func f {}\n\n\n// main.cj\nimport a.B // ambiguous use of 'a.B'\n\n\nmain() {\n    a.B.f()\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nIn the Cangjie programming language, access modifiers can be used to control the visibility of top-level declarations such as types, variables, functions, etc. There are 4 access modifiers in Cangjie language: private, internal, protected, and public, and the semantics of different access modifiers when decorating top-level elements are as follows.\n\nprivate indicates that it is only visible in the current file. Different files can't access this type of member.\ninternal indicates that it is visible only in the current package and its sub-packages (including the sub-packages of the sub-package). You can access such members in the same package without importing, and you can access such members in the sub-packages of the current package (including the sub-packages of the sub-package).\nprotected means that it is only visible within the current module. Files of the same package can access such members without importing, other packages of different packages but within the same module can access these members by importing, and packages of different modules cannot access these members.\npublic indicates that it is visible both inside and outside the module. Files from the same package can access such members without importing, and other packages can access these members by importing.\n\nModifiers\tfile\tPackages and sub-packages\tmodule\tAll packages\nprivate\tY\tN\tN\tN\ninternal\tY\tY\tN\tN\nprotected\tY\tY\tY\tN\npublic\tY\tY\tY\tY\n\nThe access modifiers and default modifiers (default modifiers are modifier semantics in the case of omission, and these default modifiers also allow explicit writing) are specified as follows:\n\npackage supports internal, protected, and public, and the default modifier is public.\nimport supports the use of the All Access modifier, and the default modifier is private.\nOther top-level declarations support the use of the All Access modifier, which is internalized by default.package a\nprivate func f1() { 1 }   //f1 is only visible within the current file\nfunc f2() { 2 }           // f2 is only visible within the current package and sub packages\nprotected func f3() { 3 } // f3 is only visible within the current module\npublic func f4() { 4 }    // f4 is visible both inside and outside the current module"}
{"text": "Cangjie programming language syntax:\nCangjie's access level is sorted as public > protected > internal > private. The access modifier for a claim must not be higher than the level of the access modifier of the type used in the claim, as shown in the following example:\nArguments and return values in function declarations// a.cj\npackage a\nclass C {}\npublic func f1(a1: C) // Error, public declaration f1 cannot use internal type C.\n{\n    return 0\n}\npublic func f2(a1: Int8): C // Error, public declaration f2 cannot use internal type C.\n{\n    return C()\n}\npublic func f3 (a1: Int8) // Error, public declaration f3 cannot use internal type C.\n{\n    return C()\n}"}
{"text": "Cangjie programming language syntax:\nCangjie's access level is sorted as public > protected > internal > private. The access modifier for a claim must not be higher than the level of the access modifier of the type used in the claim, as shown in the following example:\nVariable declarations// a.cj\npackage a\nclass C {}\npublic let v1: C = C() // Error, public declaration v1 cannot use internal type C.\npublic let v2 = C() // Error, public declaration v2 cannot use internal type C."}
{"text": "Cangjie programming language syntax:\nCangjie's access level is sorted as public > protected > internal > private. The access modifier for a claim must not be higher than the level of the access modifier of the type used in the claim, as shown in the following example:\nThe class inherited from the class declaration// a.cj\npackage a\nopen class C1 {}\npublic class C2 <: C1 {} // Error, public declaration C2 cannot use internal type C1."}
{"text": "Cangjie programming language syntax:\nCangjie's access level is sorted as public > protected > internal > private. The access modifier for a claim must not be higher than the level of the access modifier of the type used in the claim, as shown in the following example:\ntype-implemented interfaces// a.cj\npackage a\ninterface I {}\npublic enum E <: I { A } // Error, public declaration uses internal types."}
{"text": "Cangjie programming language syntax:\nCangjie's access level is sorted as public > protected > internal > private. The access modifier for a claim must not be higher than the level of the access modifier of the type used in the claim, as shown in the following example:\nType arguments for generic types// a.cj\npackage a\npublic class C1<T> {}\nclass C2 {}\npublic let v1 = C1<C2>() // Error, public declaration v1 cannot use internal type C2."}
{"text": "Cangjie programming language syntax:\nCangjie's access level is sorted as public > protected > internal > private. The access modifier for a claim must not be higher than the level of the access modifier of the type used in the claim, as shown in the following example:\nwhere constraint in the upper bound of the type// a.cj\npackage a\ninterface I {}\npublic class B<T> where T <: I {}  // Error, public declaration B cannot use internal type I."}
{"text": "Cangjie programming language syntax:\nIt is worth noting that:\nDeclarations decorated by public can use any type visible in this package in their initialization expressions or function bodies, including those that are decorated by public and those that are not.// a.cj\npackage a\nclass C1 {}\nfunc f1(a1: C1)\n{\n  return 0\n}\npublic func f2(a1: Int8) // Ok.\n{\n  var v1 = C1()\n  return 0\n}\npublic let v1 = f1(C1()) // Ok.\npublic class C2 // Ok.\n{\n  var v2 = C1()\n}"}
{"text": "Cangjie programming language syntax:\nIt is worth noting that:\nPublic-decorated top-level declarations can use anonymous functions, or any top-level function, including types that are decorated by public and those that are not.public var t1: () -> Unit = { => } // Ok.\nfunc f1(): Unit {}\npublic let t2 = f1 // Ok.\n\n\npublic func f2() // Ok.\n{\n  return f1\n}"}
{"text": "Cangjie programming language syntax:\nIt is worth noting that:\nThe default modifier for built-in types such as Rune and Int64 is public.var num = 5\npublic var t3 = num // Ok."}
{"text": "Cangjie programming language syntax:\nUse the import statement to import declarations or definitions from other packages\nIn the Cangjie programming language, you can import a top-level declaration or definition in other packages through the import fullPackageName.itemName syntax, where fullPackageName is the full path package name and itemName is the name of the declaration. The location of the import statement in the source file must be after the package declaration and before the other declarations or definitions. For example:package a\nimport std.math.*\nimport package1.foo\nimport {package1.foo, package2.bar}"}
{"text": "Cangjie programming language syntax:\nUse the import statement to import declarations or definitions from other packages\nIf you want to import multiple itemNames that belong to the same fullPackageName, you can use import fullPackageName. {itemName[, itemName]*} syntax, for example:import package1.{foo, bar, fuzz}\n//This is equivalent to:\nimport package1.foo\nimport package1.bar\nimport package1.fuzz"}
{"text": "Cangjie programming language syntax:\nIn addition to importing a specific top-level declaration or definition via the import fullPackagename.itemName syntax, you can use the import packageName.* syntax to import all visible top-level declarations or definitions in the packageName package. For example:import package1.*\nimport {package1.*, package2.*}"}
{"text": "Cangjie programming language syntax:\nIt should be noted that:\n\nThe scope level of the imported member is lower than the member declared by the current package.\nIf the module name or package name of an exported package is tampered with to make it inconsistent with the module name or package name specified during export, an error is reported during import.\nOnly the top-level declarations or definitions that are visible in the current file are allowed to be imported, and importing invisible declarations or definitions will result in an error at the import site.\nProhibits importing declarations or definitions of the package in which the current source file resides.\nIt is forbidden to import circular dependencies between packages, and if there are circular dependencies between packages, the compiler will report an error.\nThe following is an example:// pkga/a.cj\npackage pkga    // Error, packages pkga pkgb are in circular dependencies.\nimport pkgb.*\n\n\nclass C {}\npublic struct R {}\n\n\n// pkgb/b.cj\npackage pkgb\n\n\nimport pkga.*\n\n\n// pkgc/c1.cj\npackage pkgc\n\n\nimport pkga.C // Error, 'C' is not accessible in package 'pkga'.\nimport pkga.R // OK, R is an external top-level declaration of package pkga.\nimport pkgc.f1 // Error, package 'pkgc' should not import itself.\n\n\npublic func f1() {}\n\n\n// pkgc/c2.cj\npackage pkgc\n\n\nfunc f2() {\n    /* OK, the imported declaration is visible to all source files of the same package\n     * and accessing import declaration by its name is supported.\n     */\n    R()\n\n\n    // OK, accessing imported declaration by fully qualified name is supported.\n    pkga.R()\n\n\n    // OK, the declaration of current package can be accessed directly.\n    f1()\n\n\n    // OK, accessing declaration of current package by fully qualified name is supported.\n    pkgc.f1()\n}"}
{"text": "Cangjie programming language syntax:\nIn the Cangjie programming language, if the imported declaration or definition has the same name as the top-level declaration or definition in the current package and does not constitute a function overload, the imported declaration and definition will be obscured. If the imported declaration or definition has the same name as the top-level declaration or definition in the current package and constitutes a function overload, the function will be determined according to the rules of the function overload when the function is called.// pkga/a.cj\npackage pkga\n\n\npublic struct R {}            // R1\npublic func f(a: Int32) {}    // f1\npublic func f(a: Bool) {} // f2\n\n\n// pkgb/b.cj\npackage pkgb\nimport pkga.*\n\n\nfunc f(a: Int32) {}         // f3\nstruct R {}                 // R2\n\n\nfunc bar() {\n    R()     // OK, R2 shadows R1.\n    f(1)    // OK, invoke f3 in current package.\n    f(true) // OK, invoke f2 in the imported package\n}"}
{"text": "Cangjie programming language syntax:\nImplicitly import the core package\nTypes such as String and Range can be used out-of-the-box, not because they are built-in, but because the compiler automatically implicitly imports all public-decorated declarations in the core package for the source code."}
{"text": "Cangjie programming language syntax:\nUse import as to rename the name of the import\nThe namespaces of different packages are separated, so there may be top-level declarations with the same name between different packages. When importing top-level declarations with the same name for different packages, you can use import packageName.name as newName to rename them to avoid conflicts. If there are no name conflicts, you can still rename the imported content by importing as. import as has the following rules:\n\nWhen an imported declaration is renamed using import as, the current package can only use the new name after the rename, and the original name cannot be used.\n\nIf there is a conflict between the renamed name and other names in the top-level scope of the current package, and the declarations corresponding to these names are all function types, the reloaded function will be participated, otherwise the weight definition will be incorrect.\n\nYou can rename package names in the form of import pkg as newPkgName to solve the naming conflict of packages with the same name in different modules.// a.cj\npackage p1\npublic func f1() {}\n\n\n// d.cj\npackage p2\npublic func f3() {}\n\n\n// b.cj\npackage p1\npublic func f2() {}\n\n\n// c.cj\npackage pkgc\npublic func f1() {}\n\n\n// main.cj\nimport p1 as A\nimport p1 as B\nimport p2.f3 as f  // OK\nimport pkgc.f1 as a\nimport pkgc.f1 as b // OK\n\n\nfunc f(a: Int32) {}\n\n\nmain() {\n    A.f1()  // OK, package name conflict is resolved by renaming package name.\n    B.f2()  // OK, package name conflict is resolved by renaming package name.\n    p1.f1() // Error, the original package name cannot be used.\n    a()     // Ok.\n    b()     // Ok.\n    pkgc.f1()    // Error, the original name cannot be used.\n}"}
{"text": "Cangjie programming language syntax:\nThe namespaces of different packages are separated, so there may be top-level declarations with the same name between different packages. When importing top-level declarations with the same name for different packages, you can use import packageName.name as newName to rename them to avoid conflicts. If there are no name conflicts, you can still rename the imported content by importing as. import as has the following rules:\nIf you do not rename the name of the imported conflict, no error will be reported at the import statement; When you use it, you will get an error because you can't import a unique name. In this case, you can define an alias by import as or import fullPackageName as a namespace.// a.cj\npackage p1\npublic class C {}\n\n\n// b.cj\npackage p2\npublic class C {}\n\n\n// main1.cj\npackage pkga\nimport p1.C\nimport p2.C\n\n\nmain() {\n    let _ = C() // Error\n}\n\n\n// main2.cj\npackage pkgb\nimport p1.C as C1\nimport p2.C as C2\n\n\nmain() {\n    let _ = C1() // Ok\n    let _ = C2() // Ok\n}\n\n\n// main3.cj\npackage pkgc\nimport p1\nimport p2\n\n\nmain() {\n    let _ = p1.C() // Ok\n    let _ = p2.C() // Ok\n}"}
{"text": "Cangjie programming language syntax:\nRe-export an imported name\nIn the development of large, feature-rich projects, it is very common for package P2 to make heavy use of the declarations imported from package P1, and when package P3 imports package P2 and uses the features in it, the declarations in P1 also need to be visible to package P3. If package P3 is required to import the claims in P1 used in P2 on its own, this process will be too cumbersome. Therefore, it is desirable to be able to import the declarations in p1 used by p2 when p2 is imported.\n\nIn the Cangjie programming language, import can be modified by private, internal, protected, and public access modifiers. Imports that are decorated with public, protected, or internal can re-export imported members (if they are not unavailable in the package due to conflicting names or obscurations). Other packages can be imported and used directly based on visibility and use the content that is re-exported in this package, without having to import it from the original package.\n\nprivate import means that the imported content is only accessible in the current file, private is the default modifier of import, and import without writing access modifiers is equivalent to private import.\ninternal import means that the imported content is accessible in both the current package and its child packages, including the child packages of the child package. Explicit import is required for non-current package access.\nprotected import means that the imported content is accessible within the current module. Explicit import is required for non-current package access.\npublic import means that the imported content is accessible externally. Explicit import is required for non-current package access.\nIn the example below, B is a subpackage of A, where the function F defined in B is reexported via public import.package a\npublic import a.b.f\n\npublic let x = 0\ninternal package a.b\n\npublic func f() { 0 }\nimport a.f  // Ok\nlet _ = f() // Ok"}
{"text": "Cangjie programming language syntax:\nIt is important to note that packages cannot be reexported: if the import is a package, the import is not allowed to be public, protected, or internal.public import a.b // Error, cannot re-export package"}
{"text": "Cangjie programming language syntax:\nThe entry point of the Cangjie program is main, and the top layer of the package in the root directory of the source file can only have one main at most.\n\nIf the module is compiled to generate an executable, the compiler only looks for main at the top level of the root directory of the source file. If it is not found, the compiler will report an error; If main is found, the compiler further checks its arguments and return value type. It is important to note that main cannot be modified by access modifiers, and when a package is imported, the main defined in the package will not be imported.\n\nThe main as the entry point of the program can have no argument or the parameter type is Array<String>, and the return value type can be Unit or integer.\n\nmain, without arguments:// main.cj\nmain(): Int64 { // Ok.\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\n<String> Parameter type is Array main:// main.cj\nmain(args: Array<String>): Unit { // Ok.\n    for (arg in args) {\n        println(arg)\n    }\n}"}
