{"text": "Cangjie programming language syntax:\nExtensions can add new functionality to types visible in the current package (excluding functions, tuples, interfaces).\n\nWhen it is not possible to break the encapsulation of the extended type but you want to add additional functionality, you can use extension.\n\n  The functionalities that can be added include:\n\n  Adding member functions\n  Adding operator overloading functions\n  Add member attributes\n  Implement interfaces\nWhile extensions can add additional functionality, they cannot change the encapsulation of the extended type, so extensions do not support the following features:\n\n  Extensions cannot add member variables.\n  Extended functions and attributes must have implementations.\nExtended functions and attributes cannot use open, override, or redef modifiers.\nExtensions cannot access private-modified members of the extended type.\nBased on whether the extension implements new interfaces, extensions can be divided into two usage types: direct extensions and interface extensions. A direct extension is an extension that does not include additional interfaces; an interface extension is an extension that includes interfaces. Interface extensions can be used to add new features to existing types while implementing interfaces, enhancing abstract flexibility."}
{"text": "Cangjie programming language syntax:\nAn example of a simple extension syntax structure is as follows.As shown in the example ï¼Œextensions are declared using the extend keyword, followed by the type being extended (String) and the extension's functionality.extend String {\n    public func printSize() {\n        println(\"the size is ${this.size}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nAfter extending the String type with the printSize function, you can access this function on String instances within the current package, as if the function were inherently part of String itself.main() {\n    let a = \"123\"\n    a.printSize() // the size is 3\n}"}
{"text": "Cangjie programming language syntax:\nWhen the extended type is a generic type, there are two extension syntaxes to extend functionality for generic types.\n\nOne is to extend a specific instantiation of a generic type, where the extend keyword allows specifying an arbitrary fully instantiated generic type. The functionality added to these types can only be used when the type matches exactly, and the type arguments of the generic type must meet the constraints specified at the generic type definition.\n\n  For example, Foo<T> as shown below.class Foo<T> where T <: ToString {}\n\n\nextend Foo<Int64> {} // Ok\n\n\nclass Bar {}\nextend Foo<Bar> {} // Error"}
{"text": "Cangjie programming language syntax:\nWhen the extended type is a generic type, there are two extension syntaxes to extend functionality for generic types.One is to extend a specific instantiation of a generic type, where the extend keyword allows specifying an arbitrary fully instantiated generic type. \nAnother approach is to introduce generic formal parameters after extend for generic extensions. Generic extensions can be used to extend generic types that are not instantiated or not fully instantiated. Generic formal parameters declared after extend must be directly or indirectly used on the extended generic type. The functionality added to these types can only be used when the type and constraints match completely.\n\n  For example, MyList<T> as shown below.class MyList<T> {\n    public let data: Array<T> = Array<T>()\n}\n\n\nextend<T> MyList<T> {} // OK\nextend<R> MyList<R> {} // OK\nextend<T, R> MyList<(T, R)> {} // OK\nextend MyList {} // Error\nextend<T, R> MyList<T> {} // Error\nextend<T, R> MyList<T, R> {} // Error"}
{"text": "Cangjie programming language syntax:\nFor extending generic types, additional generic constraints can be declared to implement functions that can only be used in limited cases.\n\nFor example, you can define a type called Pair, which can conveniently store two elements (similar to a Tuple).\n\nIt is desired that the Pair type can accommodate any type, so there should be no constraints on the two generic parameters, ensuring that Pair can hold all types.\n\nHowever, it is also desired that when two elements can be compared for equality, the Pair should also be able to compare for equality, which can be achieved using extensions.\n\nAs shown in the following code, using extension syntax, T1 and T2 are constrained to support equals, allowing the Pair to also implement the equals function.class Pair<T1, T2> {\n    var first: T1\n    var second: T2\n    public init(a: T1, b: T2) {\n        first = a\n        second = b\n    }\n}\n\n\ninterface Eq<T> {\n    func equals(other: T): Bool\n}\n\n\nextend<T1, T2> Pair<T1, T2> where T1 <: Eq<T1>, T2 <: Eq<T2> {\n    public func equals(other: Pair<T1, T2>) {\n        first.equals(other.first) && second.equals(other.second)\n    }\n}\n\n\nclass Foo <: Eq<Foo> {\n    public func equals(other: Foo): Bool {\n        true\n    }\n}\n\n\nmain() {\n    let a = Pair(Foo(), Foo())\n    let b = Pair(Foo(), Foo())\n    println(a.equals(b)) // true\n}"}
{"text": "Cangjie programming language syntax:\nFor example, in the following example, the Array type itself does not implement the PrintSizeable interface, but it can be extended to add an additional member function printSize and implement PrintSizeable.When using the extension to implement PrintSizeable for Array, it is equivalent to implementing the PrintSizeable interface when defining the Array.Array can be used as the implementation type of PrintSizeable, as shown in the following code.interface PrintSizeable {\n    func printSize(): Unit\n}\n\n\nextend<T> Array<T> <: PrintSizeable {\n    public func printSize() {\n        println(\"The size is ${this.size}\")\n    }\n}\nmain() {\n    let a: PrintSizeable = Array<Int64>()\n    a.printSize() // 0\n}"}
{"text": "Cangjie programming language syntax:\nMultiple interfaces can be implemented simultaneously within the same extension, separated by & between interfaces, with no order precedence among them.\n\nAs shown in the following code, Foo can be implemented with I1, I2, and I3 simultaneously within the extension.interface I1 {\n    func f1(): Unit\n}\n\n\ninterface I2 {\n    func f2(): Unit\n}\n\n\ninterface I3 {\n    func f3(): Unit\n}\n\n\nclass Foo {}\n\n\nextend Foo <: I1 & I2 & I3 {\n    public func f1(): Unit {}\n    public func f2(): Unit {}\n    public func f3(): Unit {}\n}"}
{"text": "Cangjie programming language syntax:\nAdditional generic constraints can also be declared in interface extensions to implement interfaces that can only be satisfied under specific constraints.\n\nFor example, the Pair type mentioned above can be made to implement the Eq interface, so that Pair itself can also become a type that satisfies the Eq constraint, as shown in the following code.class Pair<T1, T2> {\n    var first: T1\n    var second: T2\n    public init(a: T1, b: T2) {\n        first = a\n        second = b\n    }\n}\n\n\ninterface Eq<T> {\n    func equals(other: T): Bool\n}\n\n\nextend<T1, T2> Pair<T1, T2> <: Eq<Pair<T1, T2>> where T1 <: Eq<T1>, T2 <: Eq<T2> {\n    public func equals(other: Pair<T1, T2>) {\n        first.equals(other.first) && second.equals(other.second)\n    }\n}\n\n\nclass Foo <: Eq<Foo> {\n    public func equals(other: Foo): Bool {\n        true\n    }\n}\n\n\nmain() {\n    let a = Pair(Foo(), Foo())\n    let b = Pair(Foo(), Foo())\n    println(a.equals(b)) // true\n}"}
{"text": "Cangjie programming language syntax:\nIf the type being extended already includes the functions or attributes required by the interface, then these functions or attributes do not need to and cannot be re-implemented in the extension.\n\nFor example, the following example defines a new interface Sizeable, the purpose of which is to obtain the size of a certain type. Since it is already known that Array includes this function, it can be made to implement Sizeable through extension without adding additional functions.interface Sizeable {\n    prop size: Int64\n}\n\n\nextend<T> Array<T> <: Sizeable {}\n\n\nmain() {\n    let a: Sizeable = Array<Int64>()\n    println(a.size)\n}"}
{"text": "Cangjie programming language syntax:\nAn extension itself cannot be modified with modifiers.\n\nFor example, in the following example, the direct extension of A uses the public modifier, which results in a compilation error.public class A {}\npublic extend A {}  // Error, expected no modifier before extend"}
{"text": "Cangjie programming language syntax:\nModifiers that can be used for extension members are: static, public, protected, internal, private, mut.\n\nMembers modified with private can only be used within the extension itself and are not visible externally.\nMembers decorated with `internal` can be used within the current package and sub-packages (including sub-packages of sub-packages), which is the default behavior.\nMembers decorated with `protected` can be accessed within the current module (subject to export rules). When the extended type is a class, it can also be accessed within the class's subclass definition body.\nMembers decorated with `static` can only be accessed through the type name and not through instance objects.\nExtensions to struct types can define `mut` functions.package p1\n\n\npublic open class A {}\n\n\nextend A {\n    public func f1() {}\n    protected func f2() {}\n    private func f3() {}\n    static func f4() {}\n}\n\n\nmain() {\n    A.f4()\n    var a = A()\n    a.f1()\n    a.f2()\n}"}
{"text": "Cangjie programming language syntax:\nMember definitions within extensions do not support the use of open, override, or redef modifiers.class Foo {\n    public open func f() {}\n    static func h() {}\n}\n\n\nextend Foo {\n    public override func f() {} // Error\n    public open func g() {} // Error\n    redef static func h() {} // Error\n}"}
{"text": "Cangjie programming language syntax:\nImplementing an interface of another package for a type of another package may cause confusion in understanding.\n\nTo prevent a type from being accidentally implemented with an inappropriate interface, Jaeger does not allow the definition of orphan extensions, which are extensions that neither define an interface (including all interfaces in the interface inheritance chain) in the same package nor define an interface extension in the same package as the extended type.\n\nAs shown in the following code, it is not possible to implement Bar from package b for Foo in package a within package c.\n\nBar can only be implemented for Foo in package a or within package b.// package a\npublic class Foo {}\n\n\n// package b\npublic interface Bar {}\n\n\n// package c\nimport a.Foo\nimport b.Bar\n\n\nextend Foo <: Bar {} // Error"}
{"text": "Cangjie programming language syntax:\nInstance members of extensions can use this, just like at the type definition location, with the same functionality. Similarly, instance members of extensions can also omit this access. Instance members of extensions cannot use super.class A {\n    var v = 0\n}\n\n\nextend A {\n    func f() {\n        print(this.v) // Ok\n        print(v) // Ok\n    }\n}"}
{"text": "Cangjie programming language syntax:\nExtensions cannot access members modified by private in the extended type.class A {\n    private var v1 = 0\n    protected var v2 = 0\n}\n\n\nextend A {\n    func f() {\n        print(v1) // Error\n        print(v2) // Ok\n    }\n}"}
{"text": "Cangjie programming language syntax:\nExtensions cannot override any members of the extended type.class A {\n    func f() {}\n}\n\n\nextend A {\n    func f() {} // Error\n}"}
{"text": "Cangjie programming language syntax:\nExtensions are also not allowed to obscure any members added by other extensions.class A {}\n\n\nextend A {\n    func f() {}\n}\n\n\nextend A {\n    func f() {} // Error\n}"}
{"text": "Cangjie programming language syntax:\nWithin the same package, the same type can be extended multiple times, and in the extension, you can directly call non-private modified functions from other extensions of the extended type.class Foo {}\n\n\nextend Foo { // OK\n    private func f() {}\n    func g() {}\n}\n\n\nextend Foo { // OK\n    func h() {\n        g() // OK\n        f() // Error\n    }\n}"}
{"text": "Cangjie programming language syntax:\nWhen extending generic types, additional generic constraints can be used. The visibility rules between any two extensions of a generic type are as follows:\n1.If the constraints of the two extensions are the same, the two extensions are mutually visible, meaning functions or properties within one extension can be directly used within the other;\n2.If the constraints of the two extensions are different and there is an inclusion relationship between them, the more permissive extension is visible to the more restrictive extension, otherwise, it is not visible;\n3.When the constraints of the two extensions are different and there is no inclusion relationship between them, both extensions are mutually invisible.\n\nExample: Suppose there are two extensions for the same type E<X>, named Extension 1 and Extension 2, and the constraints on X are stricter in Extension 1 than in Extension 2. Then, the functions and attributes in Extension 1 are invisible to Extension 2, whereas the functions and attributes in Extension 2 are visible to Extension 1.open class A {}\nclass B <: A {}\nclass E<X> {}\n\n\ninterface I1 {\n    func f1(): Unit\n}\ninterface I2 {\n    func f2(): Unit\n}\n\n\nextend<X> E<X> <: I1 where X <: B {  // extension 1\n    public func f1(): Unit {\n        f2() // OK\n    }\n}\n\n\nextend<X> E<X> <: I2 where X <: A   { // extension 2\n    public func f2(): Unit {\n        f1() // Error\n    }\n}"}
{"text": "Cangjie programming language syntax:\nExtensions can also be imported and exported, but extensions themselves cannot use the public modifier. There are special rules for exporting extensions.\n\nFor direct extensions, the extension's functionality will only be exported if the extended type and the members added in the extension are both public or protected, and they are in the same package.\n\nAll direct extensions other than these cannot be exported and can only be used within the current package.\n\nAs shown in the following code, Foo is a type modified with public, and f is in the same package as Foo, so f will be exported along with Foo. However, g and Foo are not in the same package, so g will not be exported.// package a\n\n\npublic class Foo {}\n\n\nextend Foo {\n    public func f() {}\n}\n\n\n// package b\nimport a.*\n\n\nextend Foo {\n    public func g() {}\n}\n\n\n// package c\nimport a.*\nimport b.*\n\n\nmain() {\n    let a = Foo()\n    a.f() // OK\n    a.g() // Error\n}"}
{"text": "Cangjie programming language syntax:\nFor interface extension, there are two cases:\n1.If the interface extension and the extended type are in the same package, but the interface is from an import, the extended functionality will only be exported when the extended type is marked with public.\n2.If the interface extension and the interface are in the same package, the extended functionality will only be exported when the interface is marked with public.\nAs shown in the following code, both Foo and I are marked with public, so the extension of Foo can be exported.// package a\n\n\npublic class Foo {}\n\n\npublic interface I {\n    func g(): Unit\n}\n\n\nextend Foo <: I {\n    public func g(): Unit {}\n}\n\n\n// package b\nimport a.*\n\n\nmain() {\n    let a: I = Foo()\n    a.g()\n}"}
{"text": "Cangjie programming language syntax:\nSimilar to exporting extensions, importing extensions does not require explicitly using the import statement. Importing an extension only needs to import the extended type and interface, which allows importing all accessible extensions.\n\nAs shown in the following code, in package b, only importing Foo is sufficient to use the function f in the corresponding extension of Foo.\n\nFor interface extensions, it is necessary to import both the extended type, the extension interface, and the generic constraints (if any) to use them. Therefore, in package c, both Foo and I need to be imported to use the function g in the corresponding extension.// package a\npackage a\npublic class Foo {}\nextend Foo {\n    public func f() {}\n}\n\n\n// package b\npackage b\nimport a.Foo\n\n\npublic interface I {\n    func g(): Unit\n}\nextend Foo <: I {\n    public func g() {\n        this.f() // OK\n    }\n}\n\n\n// package c\npackage c\nimport a.Foo\nimport b.I\n\n\nfunc test() {\n    let a = Foo()\n    a.f() // OK\n    a.g() // OK\n}"}
