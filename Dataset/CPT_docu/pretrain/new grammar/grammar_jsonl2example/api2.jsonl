{"text": "Cangjie programming language syntax:\nThe Cangjie programming language library includes STD modules (standard library modules) and some commonly used extension modules, each of which contains several packages to provide specific and rich functions related to the module.\n\nThe standard library provides developers with the most common APIs, including input and output functions, basic data structures and algorithms, date and time representations, and more. The extended library focuses on a certain area, such as the compress module provides compression and decompression capabilities, the crypto module provides encryption and decryption related capabilities, and the .net module focuses on providing efficient network protocol parsing and network communication capabilities.\n\nThe standard library and the officially provided extension library all comply with the programming specifications of the Cangjie language, and meet the official standards in terms of function, performance, and security.\n\nillustrate\nBoth the standard library and the official extension library are currently released with the Cangjie compiler and toolchain, and do not need to be downloaded separately.\nAccording to the subsequent evolution plan, the extension library may be separated from the Cangjie compiler and toolchain releases and put into a special repository management."}
{"text": "Cangjie programming language syntax:\nIn the Cangjie programming language, a package is the smallest unit of compilation, and each package can output AST files, static library files, dynamic library files and other products independently. Packages can define sub-packages, thus forming a tree structure. A package without a parent package is called a root package, and the entire tree of a root package and its children (including the child packages of a child package) is called a module. The name of the module is the same as the root package, and it is the smallest unit published by a third-party developer.\n\nThe rules for importing packages are as follows:\n\nYou can import a top-level declaration or definition from a package with the following syntax:\n\nimport fullPackageName.itemName\nwhere fullPackageName is the full path package name, and itemName is the declared name, for example:\n\nimport std.collection.ArrayList\nIf you want to import multiple itemNames that belong to the same fullPackageName, you can use:\n\nimport fullPackageName.{itemName[, itemName]*}\nFor example:\n\nimport std.collection.{ArrayList, HashMap}\nYou can also import all the top-level declarations or definitions of the public decorating in the fullPackageName package, and the syntax is as follows:\n\nimport fullPackageName.*\nFor example:\n\nimport std.collection.*"}
{"text": "Cangjie programming language syntax:\nList of modules\nThe current Cangjie standard library provides the following modules:\n\nModule name\tfunction\nstd\tSTD module refers to a standard library, which refers to a set of functions, classes, structs, etc., that are predefined in a programming language and are designed to provide commonly used functions and tools so that developers can write programs faster and more efficiently.\ncompress\tThe compress module provides compression and decompression functions.\ncrypto\tThe crypto module provides secure cryptographic capabilities.\nencoding\tThe encoding module provides character encoding and decoding functions.\nfuzz\tThe fuzz module provides fuzzing capabilities based on coverage feedback.\nlog\tThe log module provides logging capabilities.\nnet\tThe .NET module provides capabilities related to network communication.\nserialization\tThe Serialization module provides serialization and deserialization capabilities."}
{"text": "Cangjie programming language syntax:\nIntroduction to the STD feature\nSTD module refers to a standard library, which refers to a set of functions, classes, structs, etc., that are predefined in a programming language and are designed to provide commonly used functions and tools so that developers can write programs faster and more efficiently.\n\nThe capabilities provided by the Cangjie Standard Library include (but are not limited to):\n\nInput and output: console input and output, file input and output, etc.\nData structures: arrays, linked lists, hash tables, etc.\nAlgorithms: sorting, summing, exponentiation, logarithms, etc.\nDate & Time: Get the time, format the time, set a scheduled task, and more.\nConcurrent programming: locks, atomic operations, etc.\nCangjie Standard Library has three characteristics and pursuits:\n\nEasy to use: The standard library is released with the compiler and toolchain, and does not need to be downloaded separately by the user, and is ready to use out of the box.\nVersatile: The standard library provides some of the most commonly used library capabilities for developers and is designed to solve most of the basic problems for developers.\nQuality benchmarking: The standard library pursues to set an example and benchmark for other Cangjie libraries in terms of performance and code style."}
{"text": "Cangjie programming language syntax:\nA list of packages for the std module\nThe std module provides the following packages:\n\nPackage name\tfunction\ncore\tThe core package is the core package of the standard library, which provides some of the most basic API capabilities for programming in the Cangjie language.\nargopt\tThe argopt package provides the ability to parse parameter names and parameter values from command line parameter strings.\nast\tThe AST package mainly contains the syntax parser and Cangjie syntax tree node of the Cangjie source code, and provides syntax parsing functions.\nbinary\tThe binary package provides different end-order conversion interfaces for the underlying data type and binary byte arrays, as well as an end-order reversal interface.\ncollection\tThe collection package provides efficient implementations of common data structures, definitions of interfaces related to abstractions, and functions that are commonly used in collection types.\ncollection.concurrent\tThe collection.concurrent package provides a concurrency-safe implementation of collection types.\nconsole\tThe console package provides methods for interacting with standard inputs, standard outputs, and standard errors.\nconvert\tThe convert package provides a series of functions that go from a string to a specific type.\ncrypto.cipher\tThe crypto.cipher package provides a common interface for symmetric encryption and decryption.\ncrypto.digest\tThe crypto.digest package provides a common interface to common digest algorithms, including MD5, SHA1, SHA224, SHA256, SHA384, SHA512, HMAC, SM3.\ndatabase.sql\tThe database.sql package provides an interface for Cangjie to access the database.\nformat\tThe format package provides formatting capabilities, mainly to convert Cangjie type instances into formatted strings.\nfs\tThe FS (File System) package provides some operation functions for files, folders, paths, and file metadata information.\nI\tThe ability of the IO package provider to exchange data with external devices.\nlog\tThe log package provides log management and printing functions.\nmath\tThe math package provides common mathematical operations, constant definitions, floating-point number processing, and more.\nmath.numeric\tThe math.numeric package provides extensibility beyond the expressible range of the base type.\nobjectpool\tThe objectpool package provides the ability to cache and reuse objects.\nthe\tThe OS package provides capabilities to obtain or manipulate information about the current process (such as process parameters, environment variables, directory information, etc.), register callback functions, and exit the current process.\nos.posix\tThe os.posix package is mainly adapted to the POSIX system interface.\nos.process\tThe os.process package mainly provides process operation interfaces, including process creation, standard stream acquisition, process waiting, process information query, etc.\noverflow\tThe overflow package provides overflow handling-related capabilities.\nrandom\tThe random package provides the ability to generate pseudo-random numbers.\nregex\tThe ability of the regex package to analyze and process text using regular expressions (only ASCII encoded strings are supported), and supports functions such as finding, splitting, replacing, validating, and more.\nruntime\tThe runtime package interacts with the program's runtime environment, providing a set of functions and variables for controlling, managing, and monitoring the program's execution.\nsocket\tThe socket package is used for network communication, providing functions such as starting the socket server, connecting to the socket server, sending data, and receiving data.\nsort\tThe sort package provides sorting functions of the array type.\nsync\tThe sync package provides capabilities related to concurrent programming.\ntime\tThe time package provides time-related types, including datetime, time interval, monotonic time, and time zone, etc., and provides the ability to calculate and compare.\nunicode\tUnicode packages provide the ability to process characters according to the Unicode encoding standard.\nunit test\tThe unittest package is used to write unit test code for the Cangjie project, providing basic functions including code writing, running, and commissioning.\nunittest.mock\tThe unittest.mock package provides a mock framework for Cangjie unit testing, and provides an API for creating and configuring mock objects that have consistent signatures with real objects.\nunittest.testmacro\tunittest.testmacro provides the macros that users need for unit testing frameworks.\nunittest.mock.mockmacro\tunittest.mock.mockmacro provides the mock framework with the macros that users need.\nunittest.common\tunittest.common provides the unit testing framework with the types needed for printing and some general methods.\nunittest.diff\tunittest.diff provides the unit testing framework with the API it needs to print diff comparison information.\nunittest.prop_test\tunittest.prop_test provides unit testing frameworks with the types and some common methods needed for parametric testing."}
{"text": "Cangjie programming language syntax:\nstd.core package:\nThe core package is the core package of the standard library, which provides some of the most basic API capabilities for programming in the Cangjie language.\n\nIt provides built-in types (signed integer, unsigned integer, floating-point type, etc.), common functions (print, println, eprint, etc.), common interfaces (ToString, Hashable, Equatable, Collection, etc.), common classes and structs (Array, String, Range, etc.), and common exception classes (Error, Exception, and some of their subdivided subclasses).\n\nillustrate\nCore packages don't need to be imported explicitly, they are imported by default.\nThe name of the function\tfunction\nCJ_CORE_AddAtexitCallback(() -> Unit)\tRegisters an exit function that is executed when the current process exits.\nCJ_CORE_ExecAtexitCallbacks()\tExecute the registered exit function, which directly ends the current process.\nacquireArrayRawData(Array<T>) where T <: CType\tTo get<T> the raw pointer instance of the data in the Array, T needs to satisfy the CType constraint.\nalignOf<T>() where T <: CType\tGets the memory alignment value for type T.\neprint(String, Bool)\tUsed to print error messages.\neprintln(String)\tUsed to print the error message with a line break at the end.\nifNone(Option<T>, () -> Unit)\tIf the input is Option.None type data, the action function is executed.\nifSome(Option<T>, (T) -> Unit)\tIf the input is Option.Some data, the action function is executed.\nprint(Bool, Bool)\tA string representation that outputs bool type data to the console.\nprint(Float16, Bool)\tA string representation that outputs Float16 type data to the console.\nprint(Float32, Bool)\tA string representation of type data that outputs Float32 to the console.\nprint(Float64, Bool)\tA string representation that outputs Float64 type data to the console.\nprint(Int16, Bool)\tA string representation that outputs Int16 type data to the console.\nprint(Int32, Bool)\tA string representation that outputs Int32 type data to the console.\nprint(Int64, Bool)\tA string representation that outputs data of type Int64 to the console.\nprint(Int8, Bool)\tA string representation that outputs Int8 type data to the console.\nprint(Rune, Bool)\tA string representation that outputs rune-type data to the console.\nprint(String, Bool)\tOutputs a specified string to the console.\nprint(UInt16, Bool)\tA string representation that outputs UInt16 type data to the console.\nprint(UInt32, Bool)\tA string representation that outputs UInt32 type data to the console.\nprint(UInt64, Bool)\tA string representation that outputs UInt64 type data to the console.\nprint(UInt8, Bool)\tA string representation that outputs UInt8 type data to the console.\nprint<T>(T, Bool) where T <: ToString\tOutputs a string representation of a T-type instance to the console.\nprintln()\tOutputs line breaks to stdout.\nprintln(Bool)\tA string representation of the Bool type data is output to the console, with a line break added at the end.\nprintln(Float16)\tA string representation of type Float16 data is output to the console, with line breaks added at the end.\nprintln(Float32)\tA string representation of type Float32 data is output to the console, with line breaks added at the end.\nprintln(Float64)\tOutputs a string representation of type Float64 data to the console, with line breaks added at the end.\nprintln(Int16)\tA string representation of type Int16 data is output to the console, with line breaks added at the end.\nprintln(Int32)\tA string representation of type Int32 data is output to the console, with line breaks added at the end.\nprintln(Int64)\tA string representation of type Int64 data is output to the console, with line breaks added at the end.\nprintln(Int8)\tA string representation of type Int8 data is output to the console, with line breaks added at the end.\nprintln(Rune)\tA string representation of Rune type data is output to the console, with line breaks added at the end.\nprintln(String)\tOutput a specified string to the console with a line break at the end.\nprintln(UInt16)\tA string representation of UInt16 type data is output to the console, with line breaks added at the end.\nprintln(UInt32)\tOutputs a string representation of UInt32 type data to the console, with line breaks added at the end.\nprintln(UInt64)\tA string representation of UInt64 type data is output to the console, with line breaks added at the end.\nprintln(UInt8)\tA string representation of UInt8 type data is output to the console, with line breaks added at the end.\nprintln<T>(T) where T <: ToString\tOutput a string representation of a T-type instance to the console, with a line break added at the end.\nrefEq(Object, Object)\tDetermine whether the memory addresses of the two object instances are the same.\nreleaseArrayRawData(CPointerHandle<T>) where T <: CType\tRelease the original pointer instance, which is obtained via acquireArrayRawData.\nsizeOf<T>() where T <: CType\tThe amount of memory space occupied to get type T.\nzeroValue<T>()\tGet a T-type instance that has been fully zero-initialized."}
{"text": "Cangjie programming language syntax:\nfunc sizeOf<T>() where T <: CType\n\npublic func sizeOf<T>(): UIntNative where T <: CType\n\nFunction: Gets the amount of memory space occupied by type T.\n\nReturn value:UIntNative - The number of bytes of memory space occupied by type T."}
{"text": "Cangjie programming language syntax:\nfunc zeroValue<T>()\npublic unsafe func zeroValue<T>(): T\nFunction: Get a T-type instance that has been zero-initialized.\n\nnote:This instance must be set to the value of the normal initialization before use, otherwise it will cause the program to crash.\n\nReturn value:T - A fully zero-initialized instance of type T."}
{"text": "Cangjie programming language syntax:\nfunc println()\npublic func println(): Unit\nFunction: Output line breaks to stdout."}
{"text": "Cangjie programming language syntax:\nfunc alignOf<T>() where T <: CType\npublic func alignOf<T>(): UIntNative where T <: CType\nFunction: Get the memory alignment value of type T.\n\nReturn value:UIntNative - The number of bytes to be memory-aligned to type T."}
{"text": "Cangjie programming language syntax:\nfunc print(Bool, Bool)\npublic func print(b: Bool, flush!: Bool = false): Unit\nFunction: Outputs a string representation of Bool type data to the console.\n\nParameter:\n\nb: Bool—Bool type data to be exported.\nflush!: Bool - Whether to empty the cache, true to empty, false not to empty, default false."}
{"text": "Cangjie programming language syntax:\nfunc print(Float16, Bool)\npublic func print(f: Float16, flush!: Bool = false): Unit\nFunction: Outputs a string representation of Float16 type data to the console.\n\nParameter:\n\nf: Float16—Float16 data to be exported.\nflush!: Bool - Whether to empty the cache, true to empty, false not to empty, default false."}
{"text": "Cangjie programming language syntax:\nfunc print(Rune, Bool)\npublic func print(c: Rune, flush!: Bool = false): Unit\nFunction: A string representation of rune type data that outputs to the console.\n\nParameter:\n\nc: Rune - Rune type data to be exported.\nflush!: Bool - Whether to empty the cache, true to empty, false not to empty, default false."}
{"text": "Cangjie programming language syntax:\nfunc print(String, Bool)\npublic func print(str: String, flush!: Bool = false): Unit\nFunction: Output a specified string to the console.\n\nParameter:\n\nstr: String - The string to be output.\nflush!: Bool - Whether to empty the cache, true to empty, false not to empty, default false."}
{"text": "Cangjie programming language syntax:\nclass ArrayIterator<T>\npublic class ArrayIterator<T> <: Iterator<T> {\n    public init(data: Array<T>)\n}\nFunctions: Array iterators, the iteration functions are described in detail in the Iterable and Iterator descriptions.\n\nParent Type:\n\nIterator<T>\ninit(Array<T>)\npublic init(data: Array<T>)\nFunction: Given an Array instance, create its corresponding iterator to iterate through all objects in the array instance.\n\nParameter:\n\ndata: Array - Array instance.\nfunc iterator()\npublic func iterator(): Iterator<T>\nFeature: Gets the current iterator instance itself.\n\nReturn value:\n\nIterator - The current iterator instance itself.\nfunc next()\npublic func next(): Option<T>\nFunction: Returns the next value in the array iterator.\n\nReturn value:\n\nOption - the next member in the array iterator, encapsulated with Option, which returns None at the end of the iteration."}
{"text": "Cangjie programming language syntax:\nclass Box<T>\npublic class Box<T> {\n    public var value: T\n    public init(v: T)\n}\nFeature: The Box type provides the ability to add a layer of class encapsulation to other types.\n\nIf the T type itself is not referential, such as the struct type, the Box type will be referential.\n\nvar value\npublic var value: T\nFunction: Get or modify the value of the package.\n\nType: T\n\ninit(T)\npublic init(v: T)\nFunction: Given a T-type instance, construct the corresponding Box instance.\n\nParameter:\n\nv: T - Instances of any type.\nextend<T> Box<T> <: Comparable<Box<T>> where T <: Comparable<T>\nextend<T> Box<T> <: Comparable<Box<T>> where T <: Comparable<T>\nFunction: Extend the Comparable<Box> interface for the Box class to provide the ability to compare sizes.\n\nThe size relationship of a Box instance is the same as that of its encapsulated T instance.\n\nParent Type:\n\nComparable<Box<T>>\nfunc compare(Box<T>)\n\npublic func compare(that: Box<T>): Ordering\nFunction: Determine the size relationship between the current Box instance and another Box instance.\n\nParameter:\n\nthat: Box - Another Box object compared.\nReturn value:\n\nOrdering - Returns Ordering if the current Box instance is greater than that. GT, which is equal to returning Ordering. EQ, less than returns Ordering.LT.\noperator func !=(Box<T>)\n\npublic operator func !=(that: Box<T>): Bool\nFunction: Compare whether Box objects are not equal.\n\nParameter:\n\nthat: Box - Another Box object compared.\nReturn value:\n\nBool—The current Box object is not equal to the parameter Box object returns true, otherwise it returns false.\noperator func <(Box<T>)\n\npublic operator func <(that: Box<T>): Bool\nFunction: Compare the size of Box objects.\n\nParameter:\n\nthat: Box - Another Box object compared.\nReturn value:\n\nBool—The current Box object is smaller than the parameter Box object returns true, otherwise it returns false.\noperator func <=(Box<T>)\n\npublic operator func <=(that: Box<T>): Bool\nFunction: Compare the size of Box objects.\n\nParameter:\n\nthat: Box - Another Box object compared.\nReturn value:\n\nBool—The current Box object returns true if it is less than or equal to the parameter Box object, otherwise it returns false.\noperator func ==(Box<T>)\n\npublic operator func ==(that: Box<T>): Bool\nFunction: Compare whether Box objects are equal.\n\nParameter:\n\nthat: Box - Another Box object compared.\nReturn value:\n\nBool—The current Box object is equal to the parameter Box object returns true, otherwise returns false.\noperator func >(Box<T>)\n\npublic operator func >(that: Box<T>): Bool\nFunction: Compare the size of Box objects.\n\nParameter:\n\nthat: Box - Another Box object compared.\nReturn value:\n\nBool—The current Box object returns true if it is larger than the parameter Box object, otherwise it returns false.\noperator func >=(Box<T>)\n\npublic operator func >=(that: Box<T>): Bool\nFunction: Compare the size of Box objects.\n\nParameter:\n\nthat: Box - Another Box object compared.\nReturn value:\n\nBool—The current Box object returns true if it is greater than or equal to the parameter Box object, otherwise it returns false.\nextend<T> Box<T> <: Hashable where T <: Hashable\nextend<T> Box<T> <: Hashable where T <: Hashable\nParent Type:\n\nHashable\nfunc hashCode()\n\npublic func hashCode(): Int64\nFunction: Get the hash value of the Box object.\n\nIn effect, the value is the hash of the T-type instance encapsulated in Box.\n\nReturn value:\n\nInt64—The hash value of the current Box object.\nextend<T> Box<T> <: ToString where T <: ToString\nextend<T> Box<T> <: ToString where T <: ToString\nFunction: Extended the ToString interface for Box<T> type, and supported conversion to string operation.\n\nParent Type:\n\nToString\nfunc toString()\n\npublic func toString(): String\nFunction: Get the string representation of the Box object, and the string content is the string representation of the T-type instance encapsulated by the current instance.\n\nReturn value:\n\nString - The converted string."}
{"text": "Cangjie programming language syntax:\nclass Future<T>\npublic class Future<T>\nFunction: Future<T> represents a Cangjie thread task, which can be used to obtain the calculation results of the Cangjie thread and send a cancellation signal to the Cangjie thread.\n\nThe return type of the spawn expression is Future<T>, where the type of T depends on the return value type of the closure in the spawn expression.\n\nprop thread\npublic prop thread: Thread\nFunction: Obtain the Thread instance corresponding to the Cangjie thread.\n\nType: Thread\n\nfunc cancel()\npublic func cancel(): Unit\nFunction: Send a cancellation request to the Cangjie thread corresponding to the current Future instance. This method does not immediately stop the thread execution, but only sends the request, and accordingly, the function hasPendingCancellation of the Thread class can be used to check if there is a cancellation request on the thread, and the developer can use this check to decide whether and how to terminate the thread early.\n\nfunc get()\npublic func get(): T\nFunction: Block the current thread, wait for and get the result of the thread corresponding to the current Future<T> object.\n\nReturn value:\n\nT - The return value of the thread represented by the current Future<T> instance after it has ended.\nfunc get(Int64)\npublic func get(ns: Int64): Option<T>\nFunction: Block the current thread, wait for a specified period of time, and get the return value of the thread corresponding to the current Future<T> object.\n\nIf the corresponding thread does not complete the execution within the specified time, the function will return None if ns < = 0, which is equivalent to get(), that is, there is no limit to the waiting time. If a thread exits execution with an exception, the exception will continue to be thrown at the get call.\n\nParameter:\n\nns: Int64—Wait time in nanoseconds.\nReturn value:\n\nOption<T> - Returns the execution result of the Cangjie thread after the specified period of time.\nfunc tryGet()\npublic func tryGet(): Option<T>\nFunction: Attempts to get the execution result, does not block the current thread. If the corresponding thread does not complete, the function returns None.\n\nReturn value:\n\nOption<T> - Returns None if the current Cangjie thread is not complete, otherwise the execution result is returned."}
{"text": "Cangjie programming language syntax:\nclass Iterator<T>\npublic abstract class Iterator<T> <: Iterable<T>\nFunction: This class represents an iterator and provides the next method to support iterative traversal of members in the container.\n\nParent Type:\n\nIterable<T>\nfunc iterator()\npublic func iterator() : Iterator<T>\nFunction: Returns to the iterator itself.\n\nReturn value:\n\nIterator<T> - The iterator itself.\nfunc next()\npublic func next(): Option<T>\nFeature: Get the next element in the iteration process.\n\nReturn value:\n\nOption<T> - The next element in the iteration process.\nextend<T> Iterator<T>\nextend<T> Iterator<T>\nFunction: Extend the Iterator<T> type.\n\nfunc all((T) -> Bool)\n\npublic func all(predicate: (T)-> Bool): Bool\nFunction: Determine whether all elements of the iterator meet the conditions.\n\nParameter:\n\npredicate: (T) -> Bool - Given condition.\nReturn value:\n\nBool - Whether the elements are all satisfied.\nfunc year((T) -> Bool)\n\npublic func any(predicate: (T)-> Bool): Bool\nFunction: Determine whether the iterator has any element that satisfies the conditions.\n\nParameter:\n\npredicate: (T) -> Bool - Given condition.\nReturn value:\n\nBool—Whether there are any elements that meet the criteria.\nfunc at(Int64)\n\npublic func at(n: Int64): Option<T>\nFunction: Get the nth element of the current iterator.\n\nParameter:\n\nn: Int64 - The number of given.\nReturn value:\n\nOption—Returns the corresponding position element, or None if n is greater than the number of remaining elements.\nfunc concat(Iterator<T>)\n\npublic func concat(other: Iterator<T>): Iterator<T>\nFunction: Connect two iterators in series, with the current iterator coming first and the iterator represented by the parameters last.\n\nParameter:\n\nother: Iterator - The iterator to be concatenated at the back.\nReturn value:\n\nIterator - Returns the new iterator after concatenation.\nfunc count()\n\npublic func count(): Int64\nFunction: Count the number of elements contained in the current iterator.\n\nReturn value:\n\nInt64 - Returns the number of elements the iterator contains.\nfunc enumerate()\n\npublic func enumerate(): Iterator<(Int64, T)>\nFunction: Used to get an iterator with an index.\n\nReturn value:\n\nIterator <(Int64, T) > - Returns an iterator with an index.\nfunc filter((T) -> Bool)\n\npublic func filter(predicate: (T)-> Bool): Iterator<T>\nFunction: Filter out the elements that meet the criteria.\n\nParameter:\n\npredicate: (T) -> Bool - Given a condition, elements with a true condition will appear in the returned iterator in order.\nReturn value:\n\nIterator - Returns a new iterator.\nfunc filterMap<R>((T) -> Option<R>)\n\npublic func filterMap<R>(transform: (T)-> Option<R>): Iterator<R>\nFunction: Perform both the filtering operation and the mapping operation at the same time, and return a new iterator.\n\nParameter:\n\ntransform: (T) -> Option - The given mapping function. The function returns a value of Some, which corresponds to a filter whose predicate is true, and vice versa.\nReturn value:\n\nIterator - Returns a new iterator.\nfunc first()\n\npublic func first(): Option<T>\nFunction: Get the head element of the current iterator.\n\nReturn value:\n\nOption—Returns the header element, or None if empty.\nfunc flatMap<R>((T) -> Iterator<R>)\n\npublic func flatMap<R>(transform: (T)-> Iterator<R>): Iterator<R>\nFunction: Create a map with flatten functionality.\n\nParameter:\n\ntransform: (T) -> Iterable - The given mapping function.\nReturn value:\n\nIterator - Returns a mapping with flatten functionality.\nfunc fold<R>(R, (R, T) -> R)\n\npublic func fold<R>(initial: R, operation: (R, T)->R): R\nFunction: Calculates from left to right using the specified initial value.\n\nParameter:\n\ninitial: R—The initial value of a given R type.\noperation: (R, T) -> R - Given calculation function.\nReturn value:\n\nR—Returns the final calculated value.\nfunc forEach((T) -> Unit)\n\npublic func forEach(action: (T)-> Unit): Unit\nFunction: Iterate through all elements of the current iterator and perform a given action on each element.\n\nParameter:\n\naction: (T) -> Unit - Given operational function.\nfunc inspect((T) -> Unit)\n\npublic func inspect(action: (T) -> Unit): Iterator<T>\nFunction: The iterator performs an additional operation on the current element each time it calls next() (does not consume elements in the iterator).\n\nParameter:\n\naction: (T) -> Unit - Given operational function.\nReturn value:\n\nIterator - Returns a new iterator.\nfunc isEmpty()\n\npublic func isEmpty(): Bool\nFunction: Determine whether the current iterator is empty.\n\nReturn value:\n\nBool—Returns whether the current iterator is empty.\nfunc last()\n\npublic func last(): Option<T>\nFunction: Get the current iterator tail element.\n\nReturn value:\n\nOption—Returns a trailing element, or None if empty.\nfunc map<R>((T) -> R)\n\npublic func map<R>(transform: (T)-> R): Iterator<R>\nFunction: Create a mapping.\n\nParameter:\n\ntransform: (T) ->R - The given mapping function.\nReturn value:\n\nIterator - Returns a mapping.\nfunc none((T) -> Bool)\n\npublic func none(predicate: (T)-> Bool): Bool\nFunction: Determines whether all elements in the current iterator do not meet the conditions.\n\nParameter:\n\npredicate: (T) -> Bool - Given condition.\nReturn value:\n\nBool—Whether none of the elements in the current iterator meet the criteria.\nfunc reduce((T, T) -> T)\n\npublic func reduce(operation: (T, T) -> T): Option<T>\nFunction: Uses the first element as the initial value, calculated from left to right.\n\nParameter:\n\noperation: (T, T) -> T - The given calculation function.\nReturn value:\n\nOption—Returns the result of the calculation.\nfunc skip(Int64)\n\npublic func skip(count: Int64): Iterator<T>\nFeature: Skip a specific number from the current iterator from front to back.\n\nWhen the count is less than 0, an exception is thrown. When count is equal to 0, it doesn't skip any elements and returns to the original iterator quite nothing. When the count is greater than 0 and the count is less than the size of the iterator, the count of elements is skipped and a new iterator with the remaining elements is returned. When count is greater than or equal to the size of the iterator, all elements are skipped and an empty iterator is returned.\n\nParameter:\n\ncount: Int64 - The number to skip.\nReturn value:\n\nIterator - Returns an iterator that skips the specified number of elements.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when count < 0.\nfunc step(Int64)\n\npublic func step(count: Int64): Iterator<T>\nFeature: The iterator skips a specific number each time next() is called.\n\nWhen the count is less than or equal to 0, an exception is thrown. When count is greater than 0, next() is called each time count is skipped until the iterator is empty.\n\nParameter:\n\ncount: Int64 - The number of times to skip each call to next().\nReturn value:\n\nIterator - Returns a new iterator that skips a certain number each time next() is called.\nAbnormal:\n\nIllegalArgumentException - 当 count <= 0 时，抛出异常。\nfunc take(Int64)\n\npublic func take(count: Int64): Iterator<T>\nFunction: Fetch a specific number from the current iterator.\n\nRemoves a specific number of elements from the current iterator from back to front. When the count is less than 0, an exception is thrown. When count is equal to 0, the element is not taken and an empty iterator is returned. When the count is greater than 0 and less than the size of the iterator, the first count element is taken and a new iterator is returned. When the count is greater than or equal to the size of the iterator, all elements are taken and the original iterator is returned.\n\nParameter:\n\ncount: Int64 - The number to be removed.\nReturn value:\n\nIterator - Returns an iterator that takes out the specified number of elements.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when count < 0.\nfunc zip<R>(Iterator<R>)\n\npublic func zip<R>(it: Iterator<R>): Iterator<(T, R)>\nFunction: Merge two iterators into one (the length depends on the shorter iterator).\n\nParameter:\n\nit: Iterable - One of the iterators to merge.\nReturn value:\n\nIterator <(T, R)> - Returns a new iterator.\nextend<T> Iterator<T> where T <: Comparable<T>\nextend<T> Iterator<T> where T <: Comparable<T>\nFunction: Extend the Comparable<T> interface for the Iterator<T> type to support comparison operations.\n\nfunc max()\n\npublic func max(): Option<T>\nFunction: Filter the largest elements.\n\nReturn value:\n\nOption - Returns the largest element, or None if empty.\nfunc min()\n\npublic func min(): Option<T>\nFunction: Filter for the smallest elements.\n\nReturn value:\n\nOption—Returns the smallest element, or None if empty.\nextend<T> Iterator<T> where T <: Equatable<T>\nextend<T> Iterator<T> where T <: Equatable<T>\nFunction: Extend the Equatable<T> interface for the Iterator<T> type, and support judgment and other operations.\n\nfunc contains(T)\n\npublic func contains(element: T): Bool\nFunction: Iterate through all elements to determine whether the specified elements are included.\n\nParameter:\n\nelement: T - The element to find.\nReturn value:\n\nBool—Whether or not to contain the specified element.\nclass Object\npublic open class Object <: Any {\n    public const init()\n}\nObject is the parent class of all classes, and all classes inherit from it by default. The Object class does not contain any members, i.e. the Object is an \"empty\" class.\n\nParent Type:\n\nAny\ninit()\npublic const init()\nFunction: Construct an object instance."}
{"text": "Cangjie programming language syntax:\nclass RangeIterator<T> <: Iterator<T> where T <: Countable<T> & Comparable<T> & Equatable<T>\npublic class RangeIterator<T> <: Iterator<T> where T <: Countable<T> & Comparable<T> & Equatable<T>\nFunction: Iterator of type Range, the iteration function is described in the Iterable and Iterator interface descriptions.\n\nParent Type:\n\nIterator<T>\nfunc iterator()\npublic func iterator(): Iterator<T>\nFunction: Get the current iterator instance.\n\nReturn value:\n\nIterator<T> - Current iterator instance.\nfunc next()\npublic func next(): Option<T>\nFunction: Get the next value in the Range iterator.\n\nReturn value: The next member in the Range iterator, encapsulated with Option, returns None at the end of the iteration."}
{"text": "Cangjie programming language syntax:\nclass StackTraceElement\npublic open class StackTraceElement {\n    public let declaringClass: String\n    public let methodName: String\n    public let fileName: String\n    public let lineNumber: Int64\n    public init(declaringClass: String, methodName: String, fileName: String, lineNumber: Int64)\n}\nFunction: indicates the specific information of an exception stack, including the class name, function name, file name, and line number where the exception occurred.\n\nlet declaringClass\npublic let declaringClass: String\nFunction: Obtain the class name where the exception occurred.\n\nType: String\n\nlet fileName\npublic let fileName: String\nFunction: Obtain the file name where the exception occurred.\n\nType: String\n\nlet lineNumber\npublic let lineNumber: Int64\nFunction: Obtain the line number where the exception occurs.\n\nType: Int64\n\nlet method\npublic let methodName: String\nFunction: Obtain the name of the function where the exception occurred.\n\nType: String\n\ninit(String, String, String, Int64)\npublic init(declaringClass: String, methodName: String, fileName: String, lineNumber: Int64)\nFunction: Construct an exception stack instance and specify the class name, function name, file name, and line number.\n\nParameter:\n\ndeclaringClass: String - The name of the class.\nmethodName: String - The name of the function.\nfileName: String - The name of the file.\nlineNumber: Int64—Line number."}
{"text": "Cangjie programming language syntax:\nclass StringBuilder\npublic class StringBuilder <: ToString {\n    public init()\n    public init(str: String)\n    public init(r: Rune, n: Int64)\n    public init(value: Array<Rune>)\n    public init(capacity: Int64)\n}\nFunction: This class is mainly used for string construction.\n\nStringBuilder is more efficient at building strings than String:\n\nFunctionally support passing in multiple types of values, which will automatically convert them to a String type object and append them to a constructed string.\nIn terms of performance, the dynamic scaling algorithm is used to reduce the frequency of memory requests, and the speed of constructing strings is faster, and the memory resources are usually less.\nnote\nStringBuilder only supports UTF-8 encoded character data.\n\nParent Type:\n\nToString\nprop capacity\npublic prop capacity: Int64\nFunction: Get the StringBuilder instance can accommodate the length of the string at this time, and the value will increase with the scale-out.\n\nType: Int64\n\nprop size\npublic prop size: Int64\nFunction: Get the length of the string in the StringBuilder instance.\n\nType: Int64\n\ninit()\npublic init()\nFunction: Construct an empty StringBuilder instance with an initial capacity of 32.\n\ninit(Array<Rune>)\npublic init(value: Array<Rune>)\nFunction: Initialize a StringBuilder instance with an array of characters specified by the parameter value, the initial capacity of which is the value size, and the initial content is the character content contained in the value.\n\nParameter:\n\nvalue: Array<Rune> - Initializes an array of characters for the StringBuilder instance.\ninit(Int64)\npublic init(capacity: Int64)\nFunction: Initialize an empty StringBuilder instance with the capacity parameter specified by the capacity, the initial capacity of the instance is the value size, and the initial content is a few \\0 characters.\n\nParameter:\n\ncapacity: Int64 - Initializes the byte capacity of the StringBuilder, with values in the range of (0, Int64.Max).\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the value of the parameter capacity is less than or equal to 0.\ninit(Rune, Int64)\npublic init(r: Rune, n: Int64)\nFunction: Initialize a StringBuilder instance with n r characters with an initial capacity of n and an initial content of n r characters.\n\nParameter:\n\nr: Rune - Initializes the character of the StringBuilder instance.\nn: Int64—The number of characters r, in the range of [0, int64.max].\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the parameter n is less than 0.\ninit(String)\npublic init(str: String)\nFunction: Constructs a StringBuilder instance based on a specified initial string, with an initial capacity of the size of the specified string and an initial content of the specified string.\n\nParameter:\n\nstr: String - The string that initializes the StringBuilder instance.\nfunc append(Array<Rune>)\npublic func append(runeArr: Array<Rune>): Unit\nFunction: Insert all characters in a Rune array at the end of the StringBuilder.\n\nParameter:\n\nruneArr: Array<Rune> - Inserted Rune array.\nfunc append<T>(Array<T>) where T <: ToString\npublic func append<T>(val: Array<T>): Unit where T <: ToString\nFunction: Insert the string representation of Array<T> specified by the parameter val at the end of the StringBuilder, and type T needs to implement the ToString interface.\n\nParameter:\n\nval: Array<T> - Inserted Array<T> instance.\nfunc append(Bool)\npublic func append(b: Bool): Unit\nFunction: Insert a string representation of parameter b at the end of the StringBuilder.\n\nParameter:\n\nb: Bool—The value of the Bool type inserted.\nfunc append(CString)\npublic func append(cstr: CString): Unit\nFunction: Insert the parameter cstr at the end of the StringBuilder to specify the contents of CString.\n\nParameter:\n\ncstr: CString - Inserted CString.\nfunc append(Float16)\npublic func append(n: Float16): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: Float16—The value of type Float16 that is inserted.\nfunc append(Float32)\npublic func append(n: Float32): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: Float32—The value of type Float32 that was inserted.\nfunc append(Float64)\npublic func append(n: Float64): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: Float64—The value of type Float64 that was inserted.\nfunc append(Int16)\npublic func append(n: Int16): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: Int16—A value of type Int16 that was inserted.\nfunc append(Int32)\npublic func append(n: Int32): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: Int32—The value of type Int32 that was inserted.\nfunc append(Int64)\npublic func append(n: Int64): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: Int64—The value of type Int64 that was inserted.\nfunc append(Int8)\npublic func append(n: Int8): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: Int8—A value of type Int8 that was inserted.\nfunc append(Rune)\npublic func append(r: Rune): Unit\nFunction: Inserts the character specified by the parameter r at the end of the StringBuilder.\n\nParameter:\n\nr: Rune - Inserted character.\nfunc append(String)\npublic func append(str: String): Unit\nFunction: Insert the string specified by the parameter str at the end of the StringBuilder.\n\nParameter:\n\nstr: String - Inserted string.\nfunc append(StringBuilder)\npublic func append(sb: StringBuilder): Unit\nFunction: Inserts the contents of the StringBuilder specified by the parameter sb at the end of the StringBuilder.\n\nParameter:\n\nsb: StringBuilder - The inserted instance of StringBuilder.\nfunc append<T>(T) where T <: ToString\npublic func append<T>(v: T): Unit where T <: ToString\nFunction: Insert the parameter v at the end of the StringBuilder specifying the string representation of type T, type T needs to implement the ToString interface.\n\nParameter:\n\nv: T—Inserted T-type instance.\nfunc append(UInt16)\npublic func append(n: UInt16): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: UInt16 - Inserted value of type UInt16.\nfunc append(UInt32)\npublic func append(n: UInt32): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: UInt32 - The value of type UInt32 that was inserted.\nfunc append(UInt64)\npublic func append(n: UInt64): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: UInt64 - Inserted value of type UInt64.\nfunc append(UInt8)\npublic func append(n: UInt8): Unit\nFunction: Insert a string representation of the parameter n at the end of the StringBuilder.\n\nParameter:\n\nn: UInt8 - Inserted value of type UInt8.\nfunc appendFromUtf8(Array<Byte>)\npublic func appendFromUtf8(arr: Array<Byte>): Unit\nFunction: Insert an array of bytes pointed to by the parameter arr at the end of the StringBuilder.\n\nThe function requires the parameter arr to be UTF-8 encoded, and if it doesn't, an exception will be thrown.\n\nParameter:\n\narr: Array<Byte> - Array of bytes inserted.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when the byte array does not conform to the utf8 encoding rules.\nfunc appendFromUtf8Unchecked(Array<Byte>)\npublic unsafe func appendFromUtf8Unchecked(arr: Array<Byte>): Unit\nFunction: Insert an array of bytes pointed to by the parameter arr at the end of the StringBuilder.\n\nCompared with the appendFromUtf8 function, it does not check UTF-8 related rules for byte arrays, so the strings it constructs are not necessarily guaranteed to be legitimate, and even unexpected exceptions occur.\n\nParameter:\n\narr: Array<Byte> - Array of bytes inserted.\nfunc reserve(Int64)\npublic func reserve(additional: Int64): Unit\nFunction: Expand the StringBuilder to an additional size.\n\nWhen additional is less than or equal to zero, or the remaining capacity is greater than or equal to addition, the expansion does not occur. If the remaining capacity is less than additional, the capacity is expanded to 1.5 times the current capacity (rounded down) and the maximum value of size + additional.\n\nParameter:\n\nadditional: Int64 - Specifies the size of the StringBuilder.\nfunc reset(? Int64)\npublic func reset(capacity!: Option<Int64> = None): Unit\nFunction: Empty the current StringBuilder and reset the capacity to the value specified by capacity.\n\nParameter:\n\ncapacity!: Option<Int64> - The capacity of the StringBuilder instance after the reset, the value range is None and (Some(0), Some(Int64.Max)], and the default value None indicates the default size capacity (32).\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the value of the parameter capacity is less than or equal to 0.\nfunc toString()\npublic func toString(): String\nFunction: Get a string in a StringBuilder instance.\n\nnote\nThis function does not copy string data.\n\nReturn value:\n\nString - A string in a StringBuilder instance.\nclass Thread\npublic class Thread\nFunction: The Thread class represents a cangjie class, which can be used to obtain the thread ID and name, query whether the thread has a cancellation request, and register the handler function for the thread's unhandled exception.\n\nInstances of this type cannot be constructed, but can only be obtained from the thread property of the Future object or the currentThread static property of the Thread class.\n\nstatic prop currentThread\npublic static prop currentThread: Thread\nFunction: Get the Thread object of the currently executing thread.\n\nType: Thread\n\nprop hasPendingCancellation\npublic prop hasPendingCancellation: Bool\nFunction: Whether the thread has a cancellation request, that is, whether a cancellation request has been sent through future.cancel(), the common user is Thread.currentThread.hasPendingCancellation.\n\nType: Bool\n\nprop id\npublic prop id: Int64\nFunction: Obtain the identity of the current executing thread, represented by Int64, all surviving threads have different identifiers, but there is no guarantee that its identity will be reused when the thread execution is over.\n\nType: Int64\n\nprop name\npublic mut prop name: String\nFunction: Get or set the name of the thread, and get the settings are atomic.\n\nType: String\n\nstatic func handleUncaughtExceptionBy((Thread, Exception) -> Unit)\npublic static func handleUncaughtExceptionBy(exHandler: (Thread, Exception) -> Unit): Unit\nFunction: Register a handler for an exception that is not handled by the thread.\n\nWhen a thread is terminated prematurely due to an exception, if the global unhandled exception function is registered, the function will be called and the thread will be terminated, and when an exception is thrown in the function, a prompt message will be printed to the terminal and the thread will be terminated, but the abnormal call stack information will not be printed. If no global exception handler is registered, the exception call stack information is printed to the terminal by default.\n\nWhen a handler is registered more than once, subsequent registrations overwrite the previous handler.\n\nWhen multiple threads terminate due to an exception at the same time, the handler will be executed concurrently, so developers need to ensure the concurrency correctness in the handler.\n\nThe first parameter type of the handler is Thread, which is the thread where the exception occurred, and the second parameter type, Exception, is the exception that was not handled by the thread.\n\nParameter:\n\nexHandler: (Thread, Exception) -> Unit -The processing function for registration."}
{"text": "Cangjie programming language syntax:\nclass ThreadLocal<T>\npublic class ThreadLocal<T>\nFunction: This class represents the local variable of the Cangjie thread.\n\nCompared to normal variables, thread local variables have different access semantics. When multiple threads share the same thread local variable, each thread has its own copy of the value. A thread's access to a variable reads and writes the value of the thread's local without affecting the value of the variable in other threads.\n\nfunc get()\npublic func get(): ?T\nFunction: Get the value of the local variable of the Cangjie thread.\n\nReturn value:\n\n? T - Returns the value if the current thread local variable is not null, and None if it is null.\nfunc set(? T)\npublic func set(value: ?T): Unit\nFunction: Set the value of the local variable of the Cangjie thread through value, if you pass None, the value of the local variable will be deleted, and it will not be available in the subsequent operation of the thread.\n\nParameter:\n\nvalue: ? T - The value of the local variable that needs to be set."}
{"text": "Cangjie programming language syntax:\nstd.argopt package:\nFunction introduction\nThe argopt package provides the ability to parse parameter names and parameter values from command line parameter strings.\n\nCommand-line arguments are arguments passed to a program on the command line, and they are used to specify the program's configuration or behavior. For example, a command-line program might have a parameter that specifies the name of the file it is working with, or a parameter that specifies the database it uses. These parameters are usually parsed and passed to the program's code so that the program can perform its function correctly based on these parameters.\n\nCommand line arguments are divided into short command line arguments and long command line arguments, differing in their length and readability. Short command-line arguments are usually made up of a single letter and are easy to remember; Long command-line arguments are usually made up of one or more words and are easy to understand.\n\nClass name\tfunction\nArgOpt\tArgopt is used to parse command-line arguments and provides the ability to get the parsed results."}
{"text": "Cangjie programming language syntax:\nclass Argopt\npublic class ArgOpt {\n    public init(shortArgFormat: String)\n    public init(longArgList: Array<String>)\n    public init(shortArgFormat: String, longArgList: Array<String>)\n    public init(args: Array<String>, shortArgFormat: String, longArgList: Array<String>)\n}\nFunction: Argopt is used to parse command-line arguments and provides the ability to get the parsing results.\n\nA command-line argument consists of a prefix symbol, a parameter name, and a parameter value.\n\nwhere \"-\" indicates the prefix of short parameters (short command line arguments) and \"--\" indicates long arguments (long command line arguments). The parseable short parameter parameter name can only be a letter, and the parseable long parameter parameter name string must meet the following requirements: start with a letter, and the parameter name cannot contain \"=\".\n\nFor example, \"-a123\" and \"--target=abc.txt\" are two command line arguments, \"a\" is a short parameter, and \"target\" is a long parameter. \"-123\" and \"--tar=get=abc.txt\" are the wrong command line arguments.\n\nThis class allows the user to specify parameter names and parameter strings, and provides a method for parsing strings based on parameter names.\n\nWhen you specify a short parameter name and a long parameter name, the format is as follows:\n\nThe parameter of the short parameter string is in the format: \"a:\", and the specification is: a combination of a letter and \":\", for example: \"ab:\", in this case, only \"b\" is parsed as the short parameter name.\nThe format of the string is \"--testA=\" or \"testA=\", and the specification is: \"--\" + the name of the long parameter + \"=\" (the prefix \"--\" can be omitted).\nWhen parsing a command line argument based on a parameter name, if the command line argument is in the correct format and has the corresponding parameter name, it can be parsed correctly and obtained by the user. Otherwise, it will not be resolved.\n\nFor example, if the parameter name is \"a:b:\" and the command line parameter is \"-a123 -cofo\", the command line argument with the parameter name \"a\" and the parameter value \"123\" will be parsed. -cofo\" will not be resolved.\n\ninit(Array<String>)\npublic init(longArgList: Array<String>)\nFunction: Construct an ArgOpt instance and parse the long reference name from the string of the list.\n\nParameter:\n\nlongArgList: Array<String> - An array of strings containing long references.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when a long argument string in an array of strings does not conform to the specification, or the string does not conform to UTF-8 encoding, or the Unicode character does not exist.\ninit(Array<String>, String, Array<String>)\npublic init(args: Array<String>, shortArgFormat: String, longArgList: Array<String>)\nFunction: Construct an ArgOpt instance, parse the short parameter name from the short parameter name string, parse the long parameter name from the string of the list, and parse the corresponding value of the parameter name from the command line parameter specified by the parameter args according to the parsed parameter name.\n\nParameter:\n\nargs: Array<String> - An array of command line argument strings to be parsed.\nshortArgFormat: String - A string containing a short argument.\nlongArgList: Array<String> - An array of strings containing long references.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when a short argument string does not conform to the specification, or a long argument string in an array of strings does not conform to the specification, or the string does not conform to UTF-8 encoding, or the Unicode character does not exist.\ninit(String)\npublic init(shortArgFormat: String)\nFunction: Construct an ArgOpt instance and parse the short parameter name from the short parameter name string.\n\nParameter:\n\nshortArgFormat: String - A string containing a short argument.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when the short argument string does not conform to the specification, or the string does not conform to UTF-8 encoding, or when the Unicode character does not exist.\ninit(String, Array<String>)\npublic init(shortArgFormat: String, longArgList: Array<String>)\nFunction: Construct an ArgOpt instance and parse the short parameter name from the short parameter name string and the long parameter name from the string of the list.\n\nParameter:\n\nshortArgFormat: String - A string containing a short argument.\nlongArgList: Array<String> - An array of strings containing long references.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when a short argument string does not conform to the specification, or a long argument string in a string array does not conform to the specification, or the string does not conform to UTF-8 encoding, or when the Unicode character does not exist.\nfunc getArg(String)\npublic func getArg(arg: String): Option<String>\nFunction: Returns the parsed value of the parameter arg specified.\n\nParameter:\n\narg: String - A string consisting of a prefix and a parameter name (the prefix can be omitted).\nReturn value:\n\nOption<String> - Parameter parsed value.\nfunc getArgumentsMap()\npublic func getArgumentsMap(): HashMap<String, String>\nFunction: Obtain all parsed parameter names and parameter values and return them in the form of a hash table.\n\nReturn value:\n\nHashMap < String, String > - The parsed parameter is named as the key, and the parameter value is a hash table of the value.\nfunc getUnparseArgs()\npublic func getUnparseArgs(): Array<String>\nFunction: Returns unparsed command line arguments.\n\nReturn value:\n\nArray<String> - An array of strings that have not been parsed."}
{"text": "Cangjie programming language syntax:\nUse of spawn\nThe main thread and the new thread are trying to print some text at the same time.\n\nHere's the code:import std.sync.sleep\nimport std.time.{Duration, DurationExtension}\n\nmain(): Int64 {\n    spawn { =>\n        for (i in 0..10) {\n            println(\"New thread, number = ${i}\")\n            sleep(100 * Duration.millisecond) /* 睡眠 100 毫秒 */\n        }\n    }\n\n\n    for (i in 0..5) {\n        println(\"Main thread, number = ${i}\")\n        sleep(100 * Duration.millisecond) /* 睡眠 100 毫秒 */\n    }\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nFuture's get\nThe main thread waits for the creation thread to finish executing before executing.\n\nHere's the code:import std.sync.sleep\nimport std.time.{Duration, DurationExtension}\n\n\nmain(): Int64 {\n    let fut: Future<Unit> = spawn { =>\n        for (i in 0..10) {\n            println(\"New thread, number = ${i}\")\n            sleep(100 * Duration.millisecond) /* 睡眠 100 毫秒 */\n        }\n    }\n\n\n    fut.get() /* 等待线程完成 */\n\n\n    for (i in 0..5) {\n        println(\"Main thread, number = ${i}\")\n        sleep(100 * Duration.millisecond) /* 睡眠 100 毫秒 */\n    }\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nCancel the Cangjie thread\nThe child thread receives a cancellation request from the main thread.main(): Unit {\n    let future = spawn { // Create a new thread\n        while (true) {\n            if (Thread.currentThread.hasPendingCancellation) {\n                return 0\n            }\n        }\n        return 1\n    }\n    //...\n    future.cancel()    // Send a termination request\n    let res = future.get() // Wait for thread termination\n    println(res) // 0\n}"}
{"text": "Cangjie programming language syntax:\nThere are two functions in the C code: the getCString function, which returns a string pointer on the C side; printCString function, which is used to print CString from the Cangjie side.#include <stdio.h>\n\nchar *str = \"CString in C code.\";\n\nchar *getCString() { return str; }\n\nvoid printCString(char *s) { printf(\"%s\\n\", s); }"}
{"text": "Cangjie programming language syntax:\nIn the Cangjie code, create a CString object and pass it to the C-side print. And get the C-side string and print it on the Cangjie side:foreign func getCString(): CString\nforeign func printCString(s: CString): Unit\n\n\nmain() {\n   //Construct CString instance on Cangjie side and pass it to C side\n    unsafe {\n        let s: CString = LibC.mallocCString(\"CString in Cangjie code.\")\n        printCString(s)\n        LibC.free(s)\n    }\n\n    //Apply for a string pointer on the C side, pass it to the Cangjie side to become a CString instance, and then convert it to the Cangjie String type\n    unsafe {\n       \n        let cs = getCString()\n        println(cs.toString())\n    }\n\n   //Using CSStringResource to Automatically Manage CString Memory in the Try with Source Syntax Context\n    let cs = unsafe { LibC.mallocCString(\"CString in Cangjie code.\") }\n    try (csr = cs.asResource()) {\n        unsafe { printCString(csr.value) }\n    }\n\n    0\n}"}
{"text": "Cangjie programming language syntax:\nparsing of long commandimport std.argopt.*\n\nmain() {\n    let shortArgs: Array<String> = Array<String>([\"--test1=abc\", \"--test2=123\", \"--test3 xyz\"])\n    let shortArgName: String = \"\"\n    let longArgName: Array<String> = Array<String>([\"--test1=\", \"test2=\", \"--test3=\"])\n    let ao: ArgOpt = ArgOpt(shortArgs, shortArgName, longArgName)\n    println(ao.getArg(\"--test1\") ?? \"None\")\n    println(ao.getArg(\"--test2\") ?? \"None\")\n    println(ao.getArg(\"--test3\") ?? \"None\")\n}"}
{"text": "Cangjie programming language syntax:\nshort command line argument parsingimport std.argopt.*\n\nmain() {\n    let shortArgs: Array<String> = Array<String>([\"-a123\", \"-bofo\", \"-cccc\"])\n    let shortArgName: String = \"a:b:c\"\n    let longArgName: Array<String> = Array<String>()\n    let ao: ArgOpt = ArgOpt(shortArgs, shortArgName, longArgName)\n    println(ao.getArg(\"-a\") ?? \"None\")\n    println(ao.getArg(\"-b\") ?? \"None\")\n    println(ao.getArg(\"-c\") ?? \"None\")\n}"}
{"text": "Cangjie programming language syntax:\nFunction introduction\nThe AST package mainly contains the syntax parser and Cangjie syntax tree node of the Cangjie source code, and provides syntax parsing functions. The tokens of the Cangjie source code can be parsed into Abstract Syntax Tree node objects.\n\nThe Cangjie ast package provides a related function for Macro With Context, which is used to obtain context-related information during the expansion process when the macro is expanded. In the case of nested macros, the inner macro can call the library function assertParentContext(String) to ensure that the inner macro call is nested within a specific outer macro call. If the inner macro calls this function without being nested in a given outer macro call, the function will throw an error. At the same time, the function insideParentContext(String) is also used to check if the inner macro call is nested within a specific outer macro call, but returns a Boolean value. Macro With Context functions can only be called as functions, cannot be assigned to variables, and cannot be used as arguments or return values.\n\nThe Macro With Context function is as follows:\n\nassertParentContext(String)\ngetChildMessages(String)\ninsideParentContext(String)\nsetItem(String, Bool)\nsetItem(String, Int64)\nsetItem(String, String)\n\nfunction\nThe name of the function\tfunction\nassertParentContext(String)\tCheck if the current macro call is within a specific macro call. If the check does not meet expectations, the compiler will display an error message.\ncangjieLex(String)\tConvert the string to the Tokens type.\ncangjieLex(String, Bool)\tConvert the string to the Tokens type.\ncompareTokens(Tokens, Tokens)\tIt is used to compare whether the two tokens are consistent.\ndiagReport(DiagReportLevel, Tokens, String, String)\tThe error reporting interface outputs error messages in the macro expansion stage of the compilation process, and supports two levels of error reporting: WARNING and ERROR.\ngetChildMessages(String)\tGets the information sent by a specific inner macro.\ngetTokenKind(UInt16)\tConverts lexical unit type numbers to TokenKinds.\ninsideParentContext(String)\tChecks whether the current macro call is within a specific macro call and returns a boolean.\nparseDecl(Tokens, String)\tUsed to parse a set of lexical units to get a node of type Decl.\nparseDeclFragment(Tokens, Int64)\tIt is used to parse a set of lexical units, get a node of type Decl and continue to parse the index of the node.\nparseExpr(Tokens)\tUsed to parse a set of lexical units to get a node of type Expr.\nparseExprFragment(Tokens, Int64)\tIt is used to parse a set of lexical units, get a node of type Expr and continue to parse the index of the node.\nparseProgram(Tokens)\tIt is used to parse the source code of a single Cangjie file and obtain a node of type Program.\nsetItem(String, Bool)\tThe inner macro sends information of type Bool to the outer macro through this interface.\nsetItem(String, Int64)\tThe inner macro sends information of type Int64 to the outer macro through this interface.\nsetItem(String, String)\tThe inner macro sends information of type string to the outer macro through this interface.\ninterface\nThe name of the interface\tfunction\nToBytes\tSerialization of the corresponding type is provided.\nToTokens\tThe interface that implements the conversion of the corresponding type of instance to the Tokens type is used as the interface that must be implemented to support the quote interpolation operation."}
{"text": "Cangjie programming language syntax:\nMacros are defined as follows:// macro_definition.cj\nmacro package macro_definition\nimport std.ast.*\n\npublic macro Outter(input: Tokens): Tokens {\n    return input\n}\n\npublic macro Inner(input: Tokens): Tokens {\n    assertParentContext(\"Outter\")\n    return input\n}\n\n//The macro calls are as follows:\n// macro_call.cj\npackage macro_calling\n\nimport macro_definition.*\n\nmain() {\n    @Outter var a = 0\n    @Inner var b = 0 // error: The macro call 'Inner' should with the surround code contains a call 'Outter'.\n}"}
{"text": "Cangjie programming language syntax:\nAs you can see in the code above, the Inner macro is defined using the assertParentContext function to check if it is in the Outter macro during the call phase, and in the case of the code sample's macro call, the compiler will report an error because Outter and Inner do not have such a nested relationship at the time of call.\n\nMacros are defined as follows:// macro_definition.cj\nmacro package macro_definition\nimport std.ast.*\n\npublic macro Outter(input: Tokens): Tokens {\n    let messages = getChildMessages(\"Inner\")\n    for (m in messages) {\n        let value1 = m.getString(\"key1\") // get value: \"value1\"\n        let value2 = m.getString(\"key2\") // get value: \"value2\"\n        println(\"value1: ${value1}  value2: ${value2}\")\n    }\n    return input\n}\n\npublic macro Inner(input: Tokens): Tokens {\n    assertParentContext(\"Outter\")\n    setItem(\"key1\", \"value1\")\n    setItem(\"key2\", \"value2\")\n    return input\n}\n\n//The macro calls are as follows:\n// macro_call.cj\nimport std.ast.*\n\n\nimport macro_definition.*\n\n\nmain() {\n    @Outter(\n        @Inner var cnt = 0\n    )\n    println(cnt)\n}"}
{"text": "Cangjie programming language syntax:\nThe Cangjie AST package provides a rich syntax tree node for representing the Cangjie source code. Due to the rich types of nodes and the different properties between different nodes, the use process may be confused, so we have implemented a dump function for each AST node to facilitate the real-time view of the overall structure of the syntax tree nodes, and avoid the trouble caused by repeatedly viewing the manual.\n\nExample:import std.ast.*\nmain() {\n    let input = quote(var demo: Int64 = 1) //Assuming the current number of lines of code is 3\n    let varDecl = parseDecl(input)\n    varDecl.dump()\n}\n\n//Results:\nVarDecl {\n  -keyword: Token {\n    value: \"var\"\n    kind: VAR\n    pos: 3: 23\n  }\n  -identifier: Token {\n    value: \"demo\"\n    kind: IDENTIFIER\n    pos: 3: 27\n  }\n  -declType: PrimitiveType {\n    -keyword: Token {\n      value: \"Int64\"\n      kind: INT64\n      pos: 3: 33\n    }\n  }\n  -assign: Token {\n    value: \"=\"\n    kind: ASSIGN\n    pos: 3: 39\n  }\n  -expr: LitConstExpr {\n    -literal: Token {\n      value: \"1\"\n      kind: INTEGER_LITERAL\n      pos: 3: 41\n    }\n  }\n}"}
{"text": "Cangjie programming language syntax:\nexample of manipulating an AST object\nAfter you obtain a node of the ClassDecl type, you can add, delete, modify, and search the node. The code looks like this:import std.ast.*\nmain() {\n    let input: Tokens = quote(\n        class Data {\n            var a: Int32\n            init(a_: Int32) {\n                a = a_\n            }\n        }\n    )\n    let decl = parseDecl(input) //Get a Decl declaration node\n    var classDecl = match (decl as ClassDecl) { //The specific type of decl is ClassDecl, perform type conversion on it.\n        case Some(v) => v\n        case None => throw Exception()\n    }\n    var identifier = classDecl.identifier\n    //Add a member function to the node to obtain the value of a\n    var funcdecl = FuncDecl(quote(func getValue() {a}))\n    classDecl.body.decls.append(funcdecl)\n    println(\"Identifier value is ${identifier.value}\")\n    println(\"ClassDecl body size is ${classDecl.body.decls.size}\")\n    0\n}"}
{"text": "Cangjie programming language syntax:\nAn example of parsing the Cangjie source code into an AST object\nHere's a class Data:\nclass Data {\n    var a: Int32\n    init(a_: Int32) {\n        a = a_\n    }\n}\n\nUse the parse function to parse the above code into a decl object, as shown below:import std.ast.*\n\nmain() {\n    let input: Tokens = quote(\n        class Data {\n            var a: Int32\n            init(a_: Int32) {\n                a = a_\n            }\n        }\n    )\n    let decl = parseDecl(input) \n    var classDecl = match (decl as ClassDecl) { //The specific type of decl is ClassDecl, perform type conversion on it.\n        case Some(v) => v\n        case None => throw Exception()\n    }\n    classDecl.dump()\n}"}
{"text": "Cangjie programming language syntax:\nThe Cangjie ast package provides a custom error reporting interface, diagReport. It is convenient for users who define macros to customize the error content of the tokens when parsing the incoming tokens.\n\nThe custom error API provides the same output format as the native compiler, allowing users to report WARNING and ERROR.\nExamples for proper use\nMacros are defined as follows:// macro_definition.cj\nmacro package macro_definition\nimport std.ast.*\n\npublic macro testDef(input: Tokens): Tokens {\n    for (i in 0..input.size) {\n        if (input[i].kind == IDENTIFIER) {\n            diagReport(DiagReportLevel.ERROR, input[i..(i + 1)], \"This expression is not allowed to contain identifier\",   \"Here is the illegal identifier\")\n        }\n    }\n    return input\n}\n\nThe macro calls are as follows:\n\n// macro_call.cj\npackage macro_calling\n\nimport std.ast.*\nimport macro_definition.*\n\nmain(): Int64 {\n    let a = @testDef(1)\n    let b = @testDef(a)\n    let c = @testDef(1 + a)\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nDefine the behavior of the access variable declaration node: inherit from Visitor and override the access function, find the undefined variable, and store its variable lexical unit.import std.ast.*\n\nclass MyVisitor <: Visitor {\n    public var uninitializedVars = Tokens() //Store variable lexical units\n    override public func visit(varDecl: VarDecl) {\n        try {\n            varDecl.expr\n        } catch (e: ASTException) {\n            uninitializedVars.append(varDecl.identifier)\n        }\n        breakTraverse() //Will not continue to traverse the child nodes of varDecl\n        return\n    }\n}\n\nmain(): Int64 {\n    let input = quote(\n        var a : Int64\n    )\n    let varDecl = parseDecl(input)\n    let visitor = MyVisitor() //MyVisitor defines the handling of varDecl nodes\n    varDecl.traverse(visitor) //Implement processing of varDecl nodes\n    println(\"Uninitialized VarDecl size is ${visitor.uninitializedVars.size}\")\n    0\n}"}
{"text": "Cangjie programming language syntax:\nFunction introduction\nThe current binary package provides the following features:\n\nThe conversion interface between Cangjie data type and binary byte sequence is divided into two conversion types: big-endian and little-endian order.\nThe interface for converting the size and end order of the Cangjie data type.\nillustrate\nIn general, multi-byte objects are stored as contiguous sequences of bytes. In memory or digital communication links, the order in which bytes are arranged is called endianness. End-order is also known as byte order or tail order.\nThere are two ways to arrange bytes: a multi-digit low bit is stored on the low address side of the memory, and the high bit is stored on the high address side of the memory, which is called little-endian; Otherwise, it is called big-endian.\nList of APIs\ninterface\nThe name of the interface\tfunction\nBigEndianOrder<T>\tBig-endian sequence conversion interface.\nLittleEndianOrder<T>\tLittle-endian sequence conversion interface.\nSwapEndianOrder<T>\tInvert byte order interface."}
{"text": "Cangjie programming language syntax:\ninterface BigEndianOrder<T>\npublic interface BigEndianOrder<T> {\n    func writeBigEndian(buffer: Array<Byte>): Int64\n    static func readBigEndian(buffer: Array<Byte>): T\n}\nFunction: Big-endian sequence conversion interface.\n\nstatic func readBigEndian(Array<Byte>)\n\npublic static func readBigEndian(buffer: Array<Byte>): Bool\nFunction: Read a Bool value from a byte array in big-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be read.\nReturn value:\n\nBool - Bool value。\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to read the Bool value.//Example:\nimport std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let buffer: Array<Byte> = [0x1]\n    let n = Bool.readBigEndian(buffer)\n    @Assert(n, true)\n}"}
{"text": "Cangjie programming language syntax:\nfunc writeBigEndian(Array<Byte>)\n\npublic func writeBigEndian(buffer: Array<Byte>): Int64\nFunction: Write Bool values in big-endian order to a byte array.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be written.\nReturn value:\n\nInt64—The number of bytes of data written.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to store the Bool value.\nExample:import std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let buffer = Array<Byte>(8, item: 0)\n    let n = true.writeBigEndian(buffer)\n    @Assert(n, 1)\n    @Assert(buffer[..n], [0x01u8])\n}"}
{"text": "Cangjie programming language syntax:\ninterface BigEndianOrder<T>\npublic interface BigEndianOrder<T> {\n    func writeBigEndian(buffer: Array<Byte>): Int64\n    static func readBigEndian(buffer: Array<Byte>): T\n}\nFunction: Big-endian sequence conversion interface.\n\nstatic func readBigEndian(Array<Byte>)\n\npublic static func readBigEndian(buffer: Array<Byte>): Float16\nFunction: Read a Float16 value from a byte array in big-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be read.\nReturn value:\n\nFloat16 - Float16 value。\nAbnormal:\n\nIllegalArgumentException - Throws an exception when the buffer is too small to read the Float16 value.\nExample:import std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let buffer: Array<Byte> = [0x4A, 0x40]\n    let n = Float16.readBigEndian(buffer)\n    @Assert(n, 12.5)\n}"}
{"text": "Cangjie programming language syntax:\ninterface BigEndianOrder<T>\npublic interface BigEndianOrder<T> {\n    func writeBigEndian(buffer: Array<Byte>): Int64\n    static func readBigEndian(buffer: Array<Byte>): T\n}\nFunction: Big-endian sequence conversion interface.\n\nfunc writeBigEndian(Array<Byte>)\n\npublic func writeBigEndian(buffer: Array<Byte>): Int64\nFunction: Write the Float16 value to a byte array in big-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be written.\nReturn value:\n\nInt64—The number of bytes of data written.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when the buffer is too small to store the Float16 value.\nExample:import std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let buffer = Array<Byte>(8, item: 0)\n    let n = 12.5f16.writeBigEndian(buffer)\n    @Assert(n, 2)\n    @Assert(buffer[..n], [0x4A, 0x40])\n}"}
{"text": "Cangjie programming language syntax:\ninterface LittleEndianOrder<T>\npublic interface LittleEndianOrder<T> {\n    func writeLittleEndian(buffer: Array<Byte>): Int64\n    static func readLittleEndian(buffer: Array<Byte>): T\n}\nFunction: Little-endian sequence conversion interface.\n\nstatic func readBigEndian(Array<Byte>)\nstatic func readBigEndian(buffer: Array<Byte>): T\nFunction: Read a T-value from a byte array in big-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be read.\nReturn value:\n\nT - T value.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to read the T-value.\nfunc writeBigEndian(Array<Byte>)\nfunc writeBigEndian(buffer: Array<Byte>): Int64\nFunction: Write T-values to byte arrays in big-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be written.\nReturn value:\n\nInt64—The number of bytes of data written.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to store the T value.import std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let buffer: Array<Byte> = [0x1]\n    let n = Bool.readBigEndian(buffer)\n    @Assert(n, true)\n}"}
{"text": "Cangjie programming language syntax:\ninterface LittleEndianOrder<T>\npublic interface LittleEndianOrder<T> {\n    func writeLittleEndian(buffer: Array<Byte>): Int64\n    static func readLittleEndian(buffer: Array<Byte>): T\n}\nFunction: Little-endian sequence conversion interface.\n\nstatic func readLittleEndian(Array<Byte>)\nstatic func readLittleEndian(buffer: Array<Byte>): T\nFunction: Read a T-value from an array of bytes in little-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be read.\nReturn value:\n\nT - T value.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to read the T-value.\nfunc writeLittleEndian(Array<Byte>)\nfunc writeLittleEndian(buffer: Array<Byte>): Int64\nFunction: Write the T-value in little-endian order to a byte array.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be written.\nReturn value:\n\nInt64—The number of bytes of data written.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to store the T value.\nextend Bool <: LittleEndianOrder<Bool>\nextend Bool <: LittleEndianOrder<Bool>\nFeature: Extend the LittleEndianOrder interface for Bool to enable the conversion of Bool values to little-endian sequences.\n\nParent Type:\n\nLittleEndianOrder<Bool>\nstatic func readLittleEndian(Array<Byte>)\n\npublic static func readLittleEndian(buffer: Array<Byte>): Bool\nFunction: Read a Bool value from a byte array in little-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be read.\nReturn value:\n\nBool - Bool 值。\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to read the Bool value.Example:\nimport std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let buffer: Array<Byte> = [0x1]\n    let n = Bool.readLittleEndian(buffer)\n    @Assert(n, true)\n}"}
{"text": "Cangjie programming language syntax:\ninterface LittleEndianOrder<T>\npublic interface LittleEndianOrder<T> {\n    func writeLittleEndian(buffer: Array<Byte>): Int64\n    static func readLittleEndian(buffer: Array<Byte>): T\n}\nFunction: Little-endian sequence conversion interface.\n\nfunc writeLittleEndian(Array<Byte>)\n\npublic func writeLittleEndian(buffer: Array<Byte>): Int64\nFunction: Write Bool values in a little-endian order to a byte array.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be written.\nReturn value:\n\nInt64—The number of bytes of data written.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to store the Bool value.\nExample:import std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let buffer = Array<Byte>(8, item: 0)\n    let n = true.writeLittleEndian(buffer)\n    @Assert(n, 1)\n    @Assert(buffer[..n], [0x01])\n}"}
{"text": "Cangjie programming language syntax:\ninterface LittleEndianOrder<T>\npublic interface LittleEndianOrder<T> {\n    func writeLittleEndian(buffer: Array<Byte>): Int64\n    static func readLittleEndian(buffer: Array<Byte>): T\n}\nFunction: Little-endian sequence conversion interface.\n\nextend Float16 <: LittleEndianOrder<Float16>\nextend Float16 <: LittleEndianOrder<Float16>\nFeature: Extend the LittleEndianOrder interface for Float16 to convert Float16 values to little-endian-endian sequences.\n\nParent Type:\n\nLittleEndianOrder<Float16>\nstatic func readLittleEndian(Array<Byte>)\n\npublic static func readLittleEndian(buffer: Array<Byte>): Float16\nFunction: Read a Float16 value from a byte array in little-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be read.\nReturn value:\n\nFloat16 - Float16 值。\nAbnormal:\n\nIllegalArgumentException - Throws an exception when the buffer is too small to read the Float16 value.\nExample:import std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let buffer: Array<Byte> = [0x40, 0x4A]\n    let n = Float16.readLittleEndian(buffer)\n    @Assert(n, 12.5)\n}"}
{"text": "Cangjie programming language syntax:\ninterface LittleEndianOrder<T>\npublic interface LittleEndianOrder<T> {\n    func writeLittleEndian(buffer: Array<Byte>): Int64\n    static func readLittleEndian(buffer: Array<Byte>): T\n}\nFunction: Little-endian sequence conversion interface.\n\nextend Int64 <: LittleEndianOrder<Int64>\nextend Int64 <: LittleEndianOrder<Int64>\nFeature: Extend the LittleEndianOrder interface for Int64 to enable the conversion of Int64 values to little-endian-endian sequences.\n\nParent Type:\n\nLittleEndianOrder<Int64>\nstatic func readLittleEndian(Array<Byte>)\n\npublic static func readLittleEndian(buffer: Array<Byte>): Int64\nFunction: Read an Int64 value from a byte array in little-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer used to store data to be read.\nReturn value:\n\nInt64 - Int64 value。\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to read the Int64 value.\n\nfunc writeLittleEndian(Array<Byte>)\n\npublic func writeLittleEndian(buffer: Array<Byte>): Int64\nFunction: Write Int64 values to a byte array in little-endian order.\n\nParameter:\n\nbuffer: Array<Byte> - A buffer that is used to store data to be written.\nReturn value:\n\nInt64—The number of bytes of data written.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the buffer is too small to store the Int64 value.\n\nExample:import std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let buffer: Array<Byte> = [0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\n    let n = Int64.readLittleEndian(buffer)\n    @Assert(n, 0x1234567890123456i64)\n}"}
{"text": "Cangjie programming language syntax:\ninterface SwapEndianOrder<T>\npublic interface SwapEndianOrder<T> {\n    func swapBytes(): T\n}\nFunction: Invert byte order interface.\n\nfunc swapBytes()\nfunc swapBytes(): T\nFunction: Invert the byte order of the T-values.\n\nReturn value:\n\nT - T value。\nextend Int16 <: SwapEndianOrder<Int16>\nextend Int16 <: SwapEndianOrder<Int16>\nFeature: Extend the SwapEndianOrder interface for Int16 to enable the byte order of Int16 values to be reversed.\n\nParent Type:\n\nSwapEndianOrder<Int16>\nfunc swapBytes()\n\npublic func swapBytes(): Int16\nFunction: Invert the byte order of int16 values.\n\nReturn value:\n\nInt16 - Int16 值。\nExample:import std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let n = 0x1234i16\n    let m = n.swapBytes()\n    @Assert(m, 0x3412)\n}"}
{"text": "Cangjie programming language syntax:\ninterface SwapEndianOrder<T>\npublic interface SwapEndianOrder<T> {\n    func swapBytes(): T\n}\nFunction: Invert byte order interface.\n\nextend UInt16 <: SwapEndianOrder<UInt16>\nextend UInt16 <: SwapEndianOrder<UInt16>\nFeature: Extend the SwapEndianOrder interface for UInt16 to enable inverting the byte order of UInt16 values.\n\nParent Type:\n\nSwapEndianOrder<UInt16>\nfunc swapBytes()\n\npublic func swapBytes(): UInt16\nFeature: Invert the byte order of UInt16 values.\n\nReturn value:\n\nUInt16—The UInt16 value.\nExample:import std.binary.*\nimport std.unittest.*\nimport std.unittest.testmacro.*\n\n\nmain() {\n    let n = 0x1234u16\n    let m = n.swapBytes()\n    @Assert(m, 0x3412)\n}"}
{"text": "Cangjie programming language syntax:\nstd.collection package\nThe collection package provides efficient implementations of common data structures, definitions of interfaces related to abstractions, and functions that are commonly used in collection types.\n\nThis package implements the following commonly used data structures:\n\nArrayList: Variable, continuous arrays, used with caution when you need to store an indefinite amount of data, or when you need to dynamically adjust the size of the array based on runtime conditions, using ArrayList can lead to increased overhead for memory allocation and release.\n\nLinkedList: Linked list structure, LinkedList has the advantage that it can dynamically add or remove elements without the need to move other elements. This makes it useful in situations where you need to add or remove elements frequently. It can also be easily modified or deleted, and multiple elements can be stored in a list. The downside of LinkedList is that it requires additional memory to store references to each element, which can lead to wasted memory.\n\nHashMap: A hash table that stores key-value pairs and allows quick access to values based on keys. Used when you need to use a mapping relationship and you need to look it up quickly.\n\nHashSet: A collection data structure based on a hash table, which can be used to quickly retrieve and delete elements, with efficient insert, delete, and find operations.\n\nTreeMap: an ordered mapping table based on red and black trees. Typically, you can use TreeMap when you need to sort elements in a natural or custom order.\n\nNone of the collection types provided by the collection package support concurrency security, and concurrency-safe collections can be found in the collection.concurrent package."}
{"text": "Cangjie programming language syntax:\nstd.collection package\nfunction name\tfunction\nall<T>((T) -> Bool)\tDetermines whether all elements of the iterator meet the conditions.\nany<T>((T) -> Bool)\tDetermines whether the iterator has any element that satisfies the conditions.\nat<T>(Int64)\tGets the element at the location specified by the iterator.\ncollectArrayList<T>(Iterable<T>)\tConvert an iterator to an ArrayList type.\ncollectArray<T>(Iterable<T>)\tConvert an iterator to an Array type.\ncollectHashMap<K, V>(Iterable<(K, V)>) where K <: Hashable & Equatable<K>\tConvert an iterator to a HashMap type.\ncollectHashSet<T>(Iterable<T>) where T <: Hashable & Equatable<T>\tConvert an iterator to a HashSet type.\ncollectString<T>(String) where T <: ToString\tConvert an iterator that implements the ToString interface to a String type.\nconcat<T>(Iterable<T>)\tConcatenate two iterators.\ncontains<T>(T) where T <: Equatable<T>\tIterate through all elements to determine whether the specified element is included and return the element.\ncount<T>(Iterable<T>)\tCount the number of elements that the iterator contains.\nenumerate<T>(Iterable<T>)\tUsed to get an iterator with an index.\nfilter<T>((T) -> Bool)\tFilter out the elements that meet the criteria.\nfilterMap<T, R>((T) -> ? R)\tPerform both the filtering and mapping operations to return a new iterator.\nfirst<T>(Iterable<T>)\tGet the head element.\nflatMap<T, R>( (T) -> Iterable<R>)\tCreate a mapping with flatten functionality.\nflatten<T, R>(Iterable<T>) where T <: Iterable<R>\tExpand the nested iterator by one layer.\nfold<T, R>(R, (R, T) -> R)\tCalculate from left to right using the specified initial value.\nforEach<T>((T) -> Unit)\tIterate through all the elements, specifying the given action.\ninspect<T>((T) -> Unit)\tThe iterator performs an additional action on the current element each time it calls next() (it does not consume elements in the iterator).\nisEmpty<T>(Iterable<T>)\tDetermines whether the iterator is empty.\nlast<T>(Iterable<T>)\tGets the tail element.\nmap<T, R>((T) -> R)\tCreate a mapping.\nmax<T>(Iterable<T>) where T <: Comparable<T>\tFilter for the largest elements.\nmin<T>(Iterable<T>) where T <: Comparable<T>\tFilter for the smallest elements.\nnone<T>((T) -> Bool)\tDetermine if none of the iterators meet the conditions.\nreduce<T>((T, T) -> T)\tUsing the first element as the initial value, it is calculated from left to right.\nskip<T>(Int64)\tSkip a specific number from the iterator.\nstep<T>(Int64)\tThe iterator skips a certain number each time it calls next().\ntake<T>(Int64)\tFetch a specific number from the iterator.\nzip<T, R>(Iterable<R>)\tMerge the two iterators into one (the length depends on the shorter iterator)."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\ninterface\nThe name of the interface\tfunction\nMap<K, V> where K <: Equatable<K>\tProvides a way to map keys to values.\nSet<T> where T <: Equatable<T>\tA collection that does not contain duplicate elements.\nEquatableCollection<T> where T <: Equatable<T>\tDefines the types of collections that can be compared.\n\nClass name\tfunction\nArrayList<T>\tProvides the ability to make arrays of variable length.\nArrayListIterator<T>\tThis class mainly implements the iterator function of ArrayList<T>.\nHashMapIterator<K, V> where K <: Hashable & Equatable<K>\tThis class mainly implements the iterator function of HashMap.\nHashMap<K, V> where K <: Hashable & Equatable<K>\tMap<K, V> where K <: Equatable<K> 接口的哈希表实现。\nHashSet<T> where T <: Hashable & Equatable<T>\t基于 HashMap<K, V> where K <: Hashable & Equatable<K> 实现的 Set<T> where T <: Equatable<T> 接口的实例。\nLinkedListNode<T>\tLinkedList<T> 上的节点。\nLinkedList<T>\tImplement the data structure of doubly linked lists.\nTreeMap<K, V> where K <: Comparable<K>\tMap<K, V> where K <: Equatable<K> interface instance based on balanced binary search tree."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nfunc all<T>((T) -> Bool)\npublic func all<T>(predicate: (T) -> Bool): (Iterable<T>) -> Bool\nFunction: Determine whether all elements of the iterator meet the conditions.\n\nParameter:\n\npredicate: (T) -> Bool - 给定的条件。\nReturn value:\n\n(Iterable) -> Bool - Returns a function that determines that all conditions are met.\nfunc any<T>((T) -> Bool)\npublic func any<T>(predicate: (T) -> Bool): (Iterable<T>) -> Bool\nFunction: Determine whether the iterator has any element that satisfies the conditions.\n\nParameter:\n\npredicate: (T) -> Bool - 给定的条件。\nReturn value:\n\n(Iterable) -> Bool - Returns a function that determines that any one of the conditions is satisfied.\nfunc at<T>(Int64)\npublic func at<T>(n: Int64): (Iterable<T>) -> Option<T>\nFunction: Get the element at the specified position of the iterator.\n\nParameter:\n\nn: Int64 - The number of given.\nReturn value:\n\n(Iterable) -> Option - Returns a function to get the element at the corresponding position, or None if the iterator is empty."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nfunc collectArrayList<T>(Iterable<T>)\npublic func collectArrayList<T>(it: Iterable<T>): ArrayList<T>\nFunction: Convert an iterator to an ArrayList type.\n\nParameter:\niterable: Iterable - The given iterator.\n\nReturn value:\nArrayList<T> - return a ArrayList。\n\nfunc collectArray<T>(Iterable<T>)\npublic func collectArray<T>(it: Iterable<T>): Array<T>\nFunction: Convert an iterator to an Array type.\n\nParameter:\niterable: Iterable - The given iterator.\n\nReturn value:\nArray - Returns an array.\n\nfunc collectHashMap<K, V>(Iterable<(K, V)>) where K <: Hashable & Equatable<K>\npublic func collectHashMap<K, V>(it: Iterable<(K, V)>): HashMap<K, V> where K <: Hashable & Equatable<K>\nFunction: Convert an iterator to a HashMap type.\n\nParameter:\niterable<(K, V)> - Given iterator.\n\nReturn value:\nHashMap < K, V > - return a HashMap。\nfunc collectHashSet<T>(Iterable<T>) where T <: Hashable & Equatable<T>\npublic func collectHashSet<T>(it: Iterable<T>): HashSet<T> where T <: Hashable & Equatable<T>\nFunction: Convert an iterator to a HashSet type.\n\nParameter:\n\niterable: Iterable - The given iterator.\nReturn value:\nHashSet - Returns a HashSet.\n\nfunc collectString<T>(String) where T <: ToString\npublic func collectString<T>(delimiter!: String = \"\"): (Iterable<T>) -> String where T <: ToString\nFunction: Convert an iterator that implements the ToString interface to a String type.\n\nParameter:\n\ndelimiter!: String - String concatenation separator.\nReturn value:\n\n(Iterable) -> String - Returns a conversion function.\nfunc concat<T>(Iterable<T>)\npublic func concat<T>(other: Iterable<T>): (Iterable<T>) -> Iterator<T>\nFunction: Connect two iterators in series.\n\nParameter:\nother: Iterable - Iterator to be concatenated at the back.\nReturn value:\n(Iterable) -> Iterator - Returns a concatenation function.\n\nfunc contains<T>(T) where T <: Equatable<T>\npublic func contains<T>(element: T): (Iterable<T>) -> Bool where T <: Equatable<T>\nFunction: Iterate through all elements to determine whether the specified element is included and return the element.\n\nParameter:\nelement: T - The element to find.\n\nReturn value:\n(Iterable) -> Bool - Returns a lookup function.\nfunc count<T>(Iterable<T>)\npublic func count<T>(it: Iterable<T>): Int64\nFunction: Count the number of elements contained in the iterator.\n\nParameter:\niterable: Iterable - The given iterator.\n\nReturn value:\nInt64 - Returns the number of elements the iterator contains."}
{"text": "Cangjie programming language syntax:\nstd.collection package\nfunc enumerate<T>(Iterable<T>)\npublic func enumerate<T>(it: Iterable<T>): Iterator<(Int64, T)>\nFunction: Used to get an iterator with an index.\n\nParameter:\n\niterable: Iterable - The given iterator.\nReturn value:\n\nIterator <(Int64, T) > - Returns an iterator with an index.\nfunc filter<T>((T) -> Bool)\npublic func filter<T>(predicate: (T) -> Bool): (Iterable<T>) -> Iterator<T>\nFunction: Filter out the elements that meet the criteria.\n\nParameter:\n\npredicate: (T) -> Bool - 给定的条件。\nReturn value:\n\n(Iterable) -> Iterator - Returns a filter function.\nfunc filterMap<T, R>((T) -> ? R)\npublic func filterMap<T, R>(transform: (T)-> ?R): (Iterable<T>) ->Iterator<R>\nFunction: Perform both the filtering operation and the mapping operation at the same time, and return a new iterator.\n\nParameter:\n\ntransform: (T) -> ? R - The given mapping function. The function returns a value of Some, which corresponds to a filter whose predicate is true, and vice versa.\nReturn value:\n\n(Iterable) -> Iterator - Returns a filtering and mapping function.\nfunc first<T>(Iterable<T>)\npublic func first<T>(it: Iterable<T>): Option<T>\nFunction: Get the header element.\n\nParameter:\n\niterable: Iterable - The given iterator.\nReturn value:\n\nOption—Returns the header element, or None if empty.\nfunc flatMap<T, R>( (T) -> Iterable<R>)\npublic func flatMap<T, R>(transform: (T) -> Iterable<R>): (Iterable<T>) -> Iterator<R>\nFunction: Create a map with flatten functionality.\n\nParameter:\n\ntransform: (T) -> Iterable<R> - 给定的映射函数。\nReturn value:\n\n(Iterable) -> Iterator - Returns a mapping function with flatten functionality.\nfunc flatten<T, R>(Iterable<T>) where T <: Iterable<R>\npublic func flatten<T, R>(it: Iterable<T>): Iterator<R> where T <: Iterable<R>\nFunction: Expand nested iterators by one layer.\n\nParameter:\n\niterable: Iterable - The given iterator.\nReturn value:\n\nIterator - Returns an iterator after expanding one layer.\nfunc fold<T, R>(R, (R, T) -> R)\npublic func fold<T, R>(initial: R, operation: (R, T) -> R): (Iterable<T>) -> R\nFunction: Calculates from left to right using the specified initial value.\n\nParameter:\n\ninitial: R—The initial value of a given R type.\noperation: (R, T) -> R - Given calculation function.\nReturn value:\n\n(Iterable) -> R - Returns a folding function.\nfunc forEach<T>((T) -> Unit)\npublic func forEach<T>(action: (T) -> Unit): (Iterable<T>) -> Unit\nFunction: Iterate through all elements, specify a given action.\n\nParameter:\n\naction: (T) -> Unit - Given operational function.\nReturn value:\n\n(Iterable) -> Unit - Returns a function that performs a traversal operation.\nfunc inspect<T>((T) -> Unit)\npublic func inspect<T>(action: (T)->Unit): (Iterable<T>) ->Iterator<T>\nFunction: The iterator performs an additional operation on the current element each time it calls next() (does not consume elements in the iterator).\n\nParameter:\n\naction: (T) -> Unit - Given operational function.\nReturn value:\n\n(Iterable) -> Iterator - Returns a function that performs additional operations on each element of the iterator.\nfunc isEmpty<T>(Iterable<T>)\npublic func isEmpty<T>(it: Iterable<T>): Bool\nFunction: Determine whether the iterator is empty.\n\nParameter:\n\niterable: Iterable - The given iterator.\nReturn value:\n\nBool - Returns whether the iterator is empty or not.\nfunc last<T>(Iterable<T>)\npublic func last<T>(it: Iterable<T>): Option<T>\nFunction: Get tail elements.\n\nParameter:\n\niterable: Iterable - The given iterator.\nReturn value:\n\nOption—Returns a trailing element, or None if empty.\nfunc map<T, R>((T) -> R)\npublic func map<T, R>(transform: (T) -> R): (Iterable<T>) -> Iterator<R>\nFunction: Create a mapping.\n\nParameter:\n\ntransform: (T) ->R - The given mapping function.\nReturn value:\n\n(Iterable) -> Iterator - Returns a mapping function.\nfunc max<T>(Iterable<T>) where T <: Comparable<T>\npublic func max<T>(it: Iterable<T>): Option<T> where T <: Comparable<T>\nFunction: Filter the largest elements.\n\nParameter:\n\niterable: Iterable - The given iterator.\nReturn value:\n\nOption - Returns the largest element, or None if empty.\nfunc min<T>(Iterable<T>) where T <: Comparable<T>\npublic func min<T>(it: Iterable<T>): Option<T> where T <: Comparable<T>\nFunction: Filter for the smallest elements.\n\nParameter:\n\niterable: Iterable - The given iterator.\nReturn value:\n\nOption—Returns the smallest element, or None if empty.\nfunc none<T>((T) -> Bool)\npublic func none<T>(predicate: (T) -> Bool): (Iterable<T>) -> Bool\nFunction: Determine whether all elements in the iterator do not meet the conditions.\n\nParameter:\n\npredicate: (T) -> Bool 。\nReturn value:\n\n(Iterable) -> Bool - Returns a function that judges do not meet the condition."}
{"text": "Cangjie programming language syntax:\nfunc reduce<T>((T, T) -> T)\npublic func reduce<T>(operation: (T, T) -> T): (Iterable<T>) -> Option<T>\nFunction: Uses the first element as the initial value, calculated from left to right.\n\nParameter:\n\noperation: (T, T) -> T - Given operation function.\nReturn value:\n\n(Iterable) -> Option—Returns a merge function.\nfunc skip<T>(Int64)\npublic func skip<T>(count: Int64): (Iterable<T>) -> Iterator<T>\nFeature: Skip a specific number from the iterator.\n\nWhen the count is less than 0, an exception is thrown. When count is equal to 0, it doesn't skip any elements and returns to the original iterator quite nothing. When the count is greater than 0 and the count is less than the size of the iterator, the count of elements is skipped and a new iterator with the remaining elements is returned. When count is greater than or equal to the size of the iterator, all elements are skipped and an empty iterator is returned.\n\nParameter:\n\ncount: Int64 - The number to skip.\nReturn value:\n\n(Iterable) -> Iterator - Returns a function that skips the specified number of elements.\nAbnormal:\n\nIllegalArgumentException - when count <= 0,throw an exception,\nfunc step<T>(Int64)\npublic func step<T>(count: Int64): (Iterable<T>) -> Iterator<T>\nFeature: The iterator skips a specific number each time next() is called.\n\nWhen the count is less than or equal to 0, an exception is thrown. When count is greater than 0, next() is called each time count is skipped until the iterator is empty.\n\nParameter:\n\ncount: Int64 - The number of times to skip each call to next().\nReturn value:\n\n(Iterable) -> Iterator - Returns a function that changes the iterator to skip a certain number of functions each time next() is called.\nAbnormal:\n\nIllegalArgumentException - when count <= 0,throw an exception\nfunc take<T>(Int64)\npublic func take<T>(count: Int64): (Iterable<T>) -> Iterator<T>\nFunction: Fetch a specific number from the iterator.\n\nWhen the count is less than 0, an exception is thrown. When count is equal to 0, the element is not taken and an empty iterator is returned. When the count is greater than 0 and less than the size of the iterator, the first count element is taken and a new iterator is returned. When the count is greater than or equal to the size of the iterator, all elements are taken and the original iterator is returned.\n\nParameter:\n\ncount: Int64 - The number to be removed.\nReturn value:\n\n(Iterable) -> Iterator - Returns a function that takes out a specified number of elements.\nAbnormal:\n\nIllegalArgumentException - when count <= 0,throw an exception,\nfunc zip<T, R>(Iterable<R>)\npublic func zip<T, R>(other: Iterable<R>): (Iterable<T>) -> Iterator<(T, R)>\nFunction: Merge two iterators into one (the length depends on the shorter iterator).\n\nParameter:\n\nother: Iterable - One of the iterators to merge.\nReturn value:\n\n(Iterable) -> Iterator <(T, R) > - Returns a merge function."}
{"text": "Cangjie programming language syntax:\nstd.collection package\ninterface EquatableCollection<T> where T <: Equatable<T>\npublic interface EquatableCollection<T> <: Collection<T> where T <: Equatable<T> {\n    func contains(element: T): Bool\n    func containsAll(elements: Collection<T>): Bool\n}\nFunction: Defines the types of collections that can be compared.\n\nParent Type:\n\nCollection<T>\nfunc contains(T)\nfunc contains(element: T): Bool\nFunction: Determine whether the key contains the specified element.\n\nParameter:\n\nelement: T - Specifies the element to be determined whether the keys contain the element.\nReturn value:\n\nBool - Contains returns true, otherwise returns false.\nfunc containsAll(Collection<T>)\nfunc containsAll(elements: Collection<T>): Bool\nFunction: Determines whether Keys contains all the elements of a specified collection.\n\nParameter:\n\nelements: Collection<T> - 待判断的集合 elements。\nReturn value:\n\nBool - Returns true if it contains, false if it doesn't."}
{"text": "Cangjie programming language syntax:\nstd.collection package\ninterface Map<K, V> where K <: Equatable<K>\nFunction: The Map interface provides a way to map keys to values. It allows us to use keys to find values, so it can be used to store and manipulate key-value pairs.\n\nMaps cannot contain duplicate keys, and each key can only be mapped to a maximum of one value.public interface Map<K, V> <: Collection<(K, V)> where K <: Equatable<K> {\n    func get(key: K): Option<V>\n    func contains(key: K): Bool\n    func containsAll(keys: Collection<K>): Bool\n    mut func put(key: K, value: V): Option<V>\n    mut func putAll(elements: Collection<(K, V)>): Unit\n    mut func remove(key: K): Option<V>\n    mut func removeAll(keys: Collection<K>): Unit\n    mut func removeIf(predicate: (K, V) -> Bool): Unit\n    mut func clear(): Unit\n    func clone(): Map<K, V>\n    operator func [](key: K): V\n    operator func [](key: K, value!: V): Unit\n    func keys(): EquatableCollection<K>\n    func values(): Collection<V>\n    prop size: Int64\n    func isEmpty(): Bool\n    func iterator(): Iterator<(K, V)>\n}\n\nParent Type:\nCollection<(K, V)>"}
{"text": "Cangjie programming language syntax:\nstd.collection package\ninterface Map<K, V> where K <: Equatable<K>\nFunction: The Map interface provides a way to map keys to values. It allows us to use keys to find values, so it can be used to store and manipulate key-value pairs.\n\nMaps cannot contain duplicate keys, and each key can only be mapped to a maximum of one value.\nprop size\nprop size: Int64\nFunction: Returns the number of all key-value pairs in the map.\n\nType: Int64\n\nfunc clear()\nmut func clear(): Unit\nFunction: Clear all key-value pairs.\n\nfunc clone()\nfunc clone(): Map<K, V>\nFunction: Clone Map.\n\nReturn value:\n\nMap < K, V > - 返回一个 Map<K, V>。\nfunc contains(K)\nfunc contains(key: K): Bool\nFunction: Determines whether to include a mapping of a specified key.\n\nParameter:\n\nkey: K - Pass the key to be judged.\nReturn value:\n\nBool - Returns true if present; Otherwise, false is returned.\nfunc containsAll(Collection<K>)\nfunc containsAll(keys: Collection<K>): Bool\nFunction: Determines whether to contain a mapping of a specified collection key.\n\nParameter:\n\nkeys: Collection - A collection of keys to be determined.\nReturn value:\n\nBool - Returns true if present; Otherwise, false is returned.\nfunc get(K)\nfunc get(key: K): Option<V>\nFunction: Get the mapped value in the map according to the key.\n\nParameter:\n\nkey: K - Pass the key to get the value.\nReturn value:\n\nOption—The value in the Map corresponding to the Key.\nfunc isEmpty()\nfunc isEmpty(): Bool\nFunction: Check if the map is empty.\n\nReturn value:\n\nBool - Returns true if the map is empty; Otherwise, false is returned.\nfunc iterator()\nfunc iterator(): Iterator<(K, V)>\nFeature: An iterator that returns the Map.\n\nReturn value:\n\nIterator <(K, V) > - Iterator for Map.\nfunc keys()\nfunc keys(): EquatableCollection<K>\nFunction: Returns all keys in the Map and stores all keys in an EquatableCollection container.\n\nReturn value:\n\nEquatableCollection - Holds all returned keys.\nfunc put(K, V)\nmut func put(key: K, value: V): Option<V>\nFunction: Put the incoming key-value pairs into the map. For keys that are already in the map, the value of that key map is replaced with the new value.\n\nParameter:\n\nkey: K - The key to be placed.\nvalue: V—The value to be assigned.\nReturn value:\n\nOption - If the key exists before the assignment, the old value is encapsulated with Option; Otherwise, return to Option. None。\nfunc putAll(Collection<(K, V)>)\nmut func putAll(elements: Collection<(K, V)>): Unit\nFunction: Put new key-value pairs into a map. For keys that are already in the map, the value of that key map is replaced with the new value.\n\nParameter:\n\nelements: Collection<(K, V)> - A collection of key-value pairs that need to be put into a Map.\nfunc remove(K)\nmut func remove(key: K): Option<V>\nFunction: Removes the mapping of the specified key from this map, if it exists.\n\nParameter:\n\nkey: K - Pass in the key you want to delete.\nReturn value:\n\nOption—The value of the key removed from the Map. Encapsulated with Option.\nfunc removeAll(Collection<K>)\nmut func removeAll(keys: Collection<K>): Unit\nFunction: Removes the mapping of the specified collection from this mapping, if it exists.\n\nParameter:\n\nkeys: Collection - Pass in the collection you want to delete.\nfunc removeIf((K, V) -> Bool)\nmut func removeIf(predicate: (K, V) -> Bool): Unit\nFunction: Pass in a lambda expression, and if the condition is met, delete the corresponding key-value pair.\n\nParameter:\n\npredicate: (K, V) ->Bool - Pass a lambda expression for judgment.\nfunc values()\nfunc values(): Collection<V>\nFunction: Returns all values in the Map and stores all values in a Collection container.\n\nReturn value:\n\nCollection—Holds all returned values.\noperator func [](K)\noperator func [](key: K): V\nFunction: The operator overloads the collection, returns the value corresponding to the key if the key exists, and throws an exception if it does not exist.\n\nParameter:\n\nkey: K - The key that needs to be looked.\nReturn value:\n\nV - The value corresponding to the key.\noperator func [](K, V)\noperator func [](key: K, value!: V): Unit\nFunction: The operator overloads the collection, if the key exists, the new value overwrites the old value, and if the key does not exist, adds this key-value pair.\n\nParameter:\n\nkey: K - The key that needs to be set.\nvalue!: V - Pass the value to be set."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\ninterface Set<T> where T <: Equatable<T>\npublic interface Set<T> <: Collection<T> where T <: Equatable<T> {\n    func contains(element: T): Bool\n    func subsetOf(other: Set<T>): Bool\n    func containsAll(elements: Collection<T>): Bool\n    mut func put(element: T): Bool\n    mut func putAll(elements: Collection<T>): Unit\n    mut func remove(element: T): Bool\n    mut func removeAll(elements: Collection<T>): Unit\n    mut func removeIf(predicate: (T) -> Bool): Unit\n    mut func clear(): Unit\n    mut func retainAll(elements: Set<T>): Unit\n    func clone(): Set<T>\n}\nFeature: A collection that does not contain duplicate elements.\n\nThe Set interface does not specify an internal implementation, and in an instance of the Set interface, the internal elements are usually unordered and cannot be accessed by the index, nor is the order in which the elements are inserted is guaranteed.\n\nParent Type:\n\nCollection<T>"}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nFeature: A collection that does not contain duplicate elements.\n\nThe Set interface does not specify an internal implementation, and in an instance of the Set interface, the internal elements are usually unordered and cannot be accessed by the index, nor is the order in which the elements are inserted is guaranteed.\n\nParent Type:\n\nCollection<T>\nfunc clear()\nmut func clear(): Unit\nFunction: Clear all key-value pairs.\n\nfunc clone()\nfunc clone(): Set<T>\nFunction: Clone this set and return the cloned new set.\n\nReturn value:\n\nSet - The new set.\nfunc contains(T)\nfunc contains(element: T): Bool\nFunction: Returns true if the collection contains the specified element.\n\nParameter:\n\nelement: T - The element that needs to be judged.\nReturn value:\n\nBool - Returns true if contained; Otherwise, false is returned.\nfunc containsAll(Collection<T>)\nfunc containsAll(elements: Collection<T>): Bool\nFunction: Check if the collection contains other collections.\n\nParameter:\n\nelements: Collection - Other collections.\nReturn value:\n\nBool - Returns true if the collection contains the specified collection; Otherwise, false is returned.\nfunc put(T)\nmut func put(element: T): Bool\nFunction: Add element actions. If the element already exists, it will not be added.\n\nParameter:\n\nelement: T - The element to be added.\nReturn value:\n\nBool - Returns true if added successfully; Otherwise, false is returned.\nfunc putAll(Collection<T>)\nmut func putAll(elements: Collection<T>): Unit\nFunction: Add all elements in the Collection to this Set, if the element exists, do not add it.\n\nParameter:\n\nelements: Collection - A collection of elements that need to be added.\nfunc remove(T)\nmut func remove(element: T): Bool\nFunction: Removes the specified element from the collection, if it exists.\n\nParameter:\n\nelement: T - The element to be deleted.\nReturn value:\n\nBool - Returns true if the specified element is present in the collection and the deletion is successful, otherwise it returns false.\nfunc removeAll(Collection<T>)\nmut func removeAll(elements: Collection<T>): Unit\nFunction: Removes all elements in this Set that are also contained in the specified Collection.\n\nParameter:\n\nelements: Collection<T> - 传入 Collection<T>。\nfunc removeIf((T) -> Bool)\nmut func removeIf(predicate: (T) -> Bool): Unit\nFunction: Pass in a lambda expression, and if the true condition is met, delete the corresponding element.\n\nParameter:\n\npredicate: (T) ->Bool - Pass in a lambda expression to judge.\nfunc retainAll(Set<T>)\nmut func retainAll(elements: Set<T>): Unit\nFunction: Only the duplicate elements in the Set and the input parameter Set are retained.\n\nParameter:\n\nelements: Set - A collection of elements to save.\nfunc subsetOf(Set<T>)\nfunc subsetOf(other: Set<T>): Bool\nFunction: Check if the collection is a subset of other collections.\n\nParameter:\n\nother: Set - Other collections.\nReturn value:\n\nBool - Returns true if the set is a subset of the specified set; Otherwise, false is returned."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass ArrayList<T>\npublic class ArrayList<T> <: Collection<T> {\n    public init()\n    public init(capacity: Int64)\n    public init(size: Int64, initElement: (Int64) -> T)\n    public init(elements: Array<T>)\n    public init(elements: Collection<T>)\n}\nFunction: The ability to provide variable-length arrays.\n\nArrayList is a linear, dynamic array that, unlike Array, automatically resizes as needed and doesn't need to be specified when created.\n\nillustrate\nWhen an element is added to a dynamic array, if the array is full, a larger memory space is reallocated and the original element is copied to the new memory space.\n\nDynamic arrays have the advantage of saving memory space and can be automatically sized as needed, so they are ideal for situations where elements need to be added or removed frequently. However, the downside of dynamic arrays is that they can cause performance degradation when reallocating memory space, so this needs to be taken into account when using dynamic arrays.\n\nParent Type:\n\nCollection<T>"}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass ArrayList<T>\nprop size\npublic prop size: Int64\nFunction: Returns the number of elements in this ArrayList.\n\nType: Int64\n\ninit()\npublic init()\nFunction: Construct an ArrayList with an initial capacity size of 16.\n\ninit(Array<T>)\npublic init(elements: Array<T>)\nFunction: Construct an ArrayList containing all elements in the specified array.\n\nnote\nWhen T is of type Int64, the variable-length syntactic sugar version of the constructor may be ambiguous with public init(Int64), e.g. ArrayList(8, 9) constructs an ArrayList with two elements, and ArrayList(8) constructs an ArrayList with a capacity of 8.\n\nParameter:\n\nelements: Array<T> 。\ninit(Collection<T>)\npublic init(elements: Collection<T>)\nFunction: Construct an ArrayList containing all elements in the specified set. The elements are arranged in the order returned by the collection's iterators.\n\nParameter:\n\nelements: Collection<T> 。\ninit(Int64)\npublic init(capacity: Int64)\nFunction: Construct an ArrayList with an initial capacity of the specified size.\n\nParameter:\n\ncapacity: Int64—The initial capacity size specified.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown if the size of the argument is less than 0.\ninit(Int64, (Int64) -> T)\npublic init(size: Int64, initElement: (Int64) -> T)\nFunction: Construct an ArrayList with a specified initial number of elements and a specified rule function. The constructor sets the capacity of the ArrayList based on the size parameter.\n\nParameter:\n\nsize: Int64 - The number of elements of the initialization function.\ninitElement: (Int64) ->T - Initialization function passed.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown if the size is less than 0.\nfunc append(T)\npublic func append(element: T): Unit\nFunction: Append the specified element to the end of this ArrayList.\n\nParameter:\n\nelement: T—The inserted element, of type T.\nExample:\n\nSee the append/insert function of ArrayList for an example.\n\nfunc appendAll(Collection<T>)\npublic func appendAll(elements: Collection<T>): Unit\nFunction: Append all elements in the specified set to the end of this ArrayList.\n\nThe function traverses the set of incoming arguments in the order of the iterator and inserts all elements into the tail of this ArrayList.\n\nParameter:\n\nelements: Collection<T> - A collection of elements that need to be inserted."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass ArrayList<T>\n\nfunc capacity()\npublic func capacity(): Int64\nFunction: Returns the capacity size of this ArrayList.\n\nReturn value:\n\nInt64 - The capacity size of this ArrayList.\nfunc clear()\npublic func clear(): Unit\nFunction: Remove all elements from this ArrayList.\n\nExample:\n\nSee the remove/clear/slice function of ArrayList for an example.\n\nfunc clone()\npublic func clone(): ArrayList<T>\nFeature: Returns a copy (shallow copy) of this ArrayList instance.\n\nReturn value:\n\nArrayList<T> - Returns a new ArrayList<T>.\nfunc get(Int64)\npublic func get(index: Int64): ?T\nFunction: Returns the element at the specified location in this ArrayList.\n\nParameter:\n\nindex: Int64 - The index of the element to be returned.\nReturn value:\n\n? T - Returns the element at the specified location, and if the index size is less than 0 or greater than or equal to the number of elements in the ArrayList, return None.\nExample:\n\nSee the get/set function of ArrayList for an example.\n\nfunc getRawArray()\npublic unsafe func getRawArray(): Array<T>\nFunction: Returns the raw data of the ArrayList.\n\nnote\nThis is an unsafe interface and needs to be used in the context of unsafe.\n\nRaw data refers to an array of the underlying implementation of ArrayList, whose size is greater than or equal to the number of elements in the ArrayList, and where the index is greater than or equal to the size of the ArrayList may contain uninitialized elements, access to which may result in undefined behavior.\n\nReturn value:\n\nArray<T> - The underlying raw data for ArrayList.\nfunc insert(Int64, T)\npublic func insert(index: Int64, element: T): Unit\nFunction: Inserts the specified element at the specified location in this ArrayList.\n\nParameter:\n\nindex: Int64 - The target index of the inserted element.\nelement: T—The type T element to insert.\nAbnormal:\n\nIndexOutOfBoundsException - An exception is thrown when the index is out of range.\nExample:\n\nSee the append/insert function of ArrayList for an example.\n\nfunc insertAll(Int64, Collection<T>)\npublic func insertAll(index: Int64, elements: Collection<T>): Unit\nFunction: Inserts all elements in the specified collection into this ArrayList starting from the specified location.\n\nThe function traverses the set of incoming arguments in the order of the iterator and inserts all the elements into the specified position.\n\nParameter:\n\nindex: Int64 - The target index to be inserted into the collection.\nelements: Collection<T> - A collection of T-type elements to insert.\nAbnormal:\n\nIndexOutOfBoundsException - An exception is thrown when the index is out of range.\nExample:\n\nSee the remove/clear/slice function of ArrayList for an example.\n\nfunc isEmpty()\npublic func isEmpty(): Bool\nFunction: Determine if the ArrayList is empty.\n\nReturn value:\n\nBool - Returns true if empty, false otherwise.\nfunc iterator()\npublic func iterator(): Iterator<T>\nFeature: Returns an iterator for the elements in this ArrayList.\n\nReturn value:\n\nIterator<T> - Iterator for the element in the ArrayList.\nfunc prepend(T)\npublic func prepend(element: T): Unit\nFunction: At the starting position, insert the specified element into this ArrayList.\n\nParameter:\n\nelement: T - Inserts a T-type element.\nfunc prependAll(Collection<T>)\npublic func prependAll(elements: Collection<T>): Unit\nFunction: Inserts all elements in the specified set into this ArrayList from the starting position.\n\nThe function traverses the set of incoming arguments in the order of the iterator and inserts all the elements into the specified position.\n\nParameter:\n\nelements: Collection<T> - A collection of T-type elements to insert.\nfunc remove(Int64)\npublic func remove(index: Int64): T\nFunction: Deletes the element at the specified location in this ArrayList.\n\nParameter:\n\nindex: Int64 - The index of the deleted element.\nReturn value:\n\nT—The removed element.\nAbnormal:\n\nIndexOutOfBoundsException - An exception is thrown when the index is out of range.\nExample:\n\nSee the remove/clear/slice function of ArrayList for an example.\n\nfunc remove(Range<Int64>)\npublic func remove(range: Range<Int64>): Unit\nFunction: Deletes all elements contained in the Range range in this ArrayList.\n\nnote\nIf the parameter range is a Range instance constructed using the Range constructor, and hasEnd is false, the end value does not take effect, and is not affected by the value of isClosed passed in during construction, and the array slice is taken to the last element of the original array.\n\nParameter:\n\nrange: Range<Int64> - The range of elements that need to be deleted.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when the step of the range is not equal to 1.\nIndexOutOfBoundsException - Thrown when the start or end of a range is less than 0, or the end is greater than the length of the array.\nfunc removeIf((T) -> Bool)\npublic func removeIf(predicate: (T) -> Bool): Unit\nFunction: Removes all elements in this ArrayList that satisfy a given lambda expression or function.\n\nParameter:\n\npredicate: (T) ->Bool - Pass the criteria for determining the deletion.\nfunc reserve(Int64)\npublic func reserve(additional: Int64): Unit\nFeature: Increase the capacity of this ArrayList instance.\n\nExpand the ArrayList to an additional size, and when additional is less than or equal to zero, the expansion will not occur. When the remaining capacity of ArrayList is greater than or equal to addition, the expansion does not occur. When the remaining capacity of ArrayList is less than addition, the maximum value of (1.5 times the original capacity is rounded down) and (additional + used capacity) is used to scale out.\n\nParameter:\n\nadditional: Int64 - The size to be scaled up.\nAbnormal:\n\nOverflowException - An exception is thrown when additional + used capacity exceeds Int64.Max.\nfunc reverse()\npublic func reverse(): Unit\nFunction: Reverses the order of the elements in this ArrayList.\n\nfunc set(Int64, T)\npublic func set(index: Int64, element: T): Unit\nFunction: Replaces the element specified in the specified position in this ArrayList with the specified element.\n\nParameter:\n\nindex: Int64—The index value to set.\nelement: T - T type element.\nAbnormal:\n\nIndexOutOfBoundsException - An exception is thrown when the index is less than 0 or greater than or equal to the number of elements in the ArrayList.\nExample:\n\nSee the get/set function of ArrayList for an example.\n\nfunc slice(Range<Int64>)\npublic func slice(range: Range<Int64>): ArrayList<T>\nFunction: The input parameter range is used as the index to return the ArrayList<T> corresponding to the index.\n\nnote\nIf the parameter range is an instance of Range constructed using the Range constructor, it has the following behavior:\n\nThe value of start is the value passed in by the constructor itself, and is not affected by the value of hasStart passed in at construction time.\nWhen hasEnd is false, the end value does not take effect, and is not affected by the value of isClosed passed in during construction, and the array slice is taken to the last element of the original array.\nParameter:\n\nrange: Range<Int64> - The range of the slices that are delivered.\nReturn value:\n\nArrayList<T> - The array of the slices.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when range.step is not equal to 1.\nIndexOutOfBoundsException - Throws an exception when range is invalid.\nExample:\n\nSee the remove/clear/slice function of ArrayList for an example.\n\nfunc sortBy(Bool, (T, T) -> Ordering)\npublic func sortBy(stable!: Bool = false, comparator!: (T, T) -> Ordering): Unit\nFunction: Sort elements in an array.\n\nThrough the comparison function passed in, according to the result of its return value of the Ordering type, the array can be custom-sortedcomparator: (t1: T, t2: T) -> Ordering, if the return value of the comparator is Ordering.GT, t1 after t2 after sorting; If the return value of the comparator is Ordering.LT, t1 is before t2 after sorting; If the comparator returns Ordering.EQ and is a stable order, then t1 precedes t2; If the comparator returns Ordering.EQ and is unstable ordering, then t1,t2 are in indeterminate order.\n\nParameter:\n\nstable!: Bool - Whether to use stable sorting.\ncomparator!: (T, T) -> Ordering - (T, T) -> Ordering 类型。\nfunc toArray()\npublic func toArray(): Array<T>\nFunction: Returns an array of all the elements in this list in the correct order.\n\nReturn value:\n\nArray<T> - Array of type T."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass ArrayList<T>\n\noperator func [](Int64)\npublic operator func [](index: Int64): T\nFunction: Operator overload - get.\n\nParameter:\n\nindex: Int64 - Represents the index of the get interface.\nReturn value:\n\nT - The value of the element at the index position.\nAbnormal:\n\nIndexOutOfBoundsException - An exception is thrown when the index is out of range.\noperator func [](Int64, T)\npublic operator func [](index: Int64, value!: T): Unit\nFunction: Operator Overload - set, which replaces the element at the specified position in this list with the specified element with the subscript operator.\n\nParameter:\n\nindex: Int64—The index value to set.\nvalue!: T—The value of type T to set.\nAbnormal:\n\nIndexOutOfBoundsException - An exception is thrown when the index is out of range.\noperator func [](Range<Int64>)\npublic operator func [](range: Range<Int64>): ArrayList<T>\nFunction: Operator overload - slicing.\n\nnote\nIf the parameter range is an instance of Range constructed using the Range constructor, it has the following behavior:\n\nThe value of start is the value passed in by the constructor itself, and is not affected by the value of hasStart passed in at construction time.\nWhen hasEnd is false, the end value does not take effect, and is not affected by the value of isClosed passed in during construction, and the array slice is taken to the last element of the original array.\nThe ArrayList returned by the slicing operation is a new object and has no reference relationship with the original ArrayList.\n\nParameter:\n\nrange: Range<Int64> - The range of the slices that are delivered.\nReturn value:\n\nArrayList<T> - The array of the slices.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when range.step is not equal to 1.\nIndexOutOfBoundsException - Throws an exception when range is invalid.\nextend<T> ArrayList<T> <: Equatable<ArrayList<T>> where T <: Equatable<T>\nextend<T> ArrayList<T> <: Equatable<ArrayList<T>> where T <: Equatable<T>\nFunction: Extend the Equatable<ArrayList<T>> interface for the ArrayList<T> type, and support judgment operations.\n\nParent Type:\n\nEquatable<ArrayList<T>>\noperator func ==(ArrayList<T>)\n\npublic operator func ==(that: ArrayList<T>): Bool\nFunction: Check whether the current instance is equal to the ArrayList instance pointed to by the parameter.\n\nThe equality of two arrays means that the elements in their respective positions are equal.\n\nParameter:\n\nthat: ArrayList - The object being compared.\nReturn value:\n\nBool - Returns true if equal, false otherwise.\noperator func !=(ArrayList<T>)\n\npublic operator func !=(that: ArrayList<T>): Bool\nFunction: Check whether the current instance is different from the ArrayList instance pointed to by the parameter.\n\nParameter:\n\nthat: ArrayList - The object being compared.\nReturn value:\n\nBool - Returns true if it doesn't wait, false otherwise.\nfunc contains(T)\n\npublic func contains(element: T): Bool\nFunction: Check whether the current array contains the specified element element.\n\nParameter:\n\nelement: T - The element to be found.\nReturn value:\n\nBool - Returns true if the array contains the specified element, false otherwise.\nextend<T> ArrayList<T> <: SortExtension where T <: Comparable<T>\nextend<T> ArrayList<T> <: SortExtension where T <: Comparable<T>\nFunction: Extend the SortExtension interface for ArrayList<T> and support array sorting.\n\nParent Type:\n\nSortExtension\nfunc spell(Bool)\n\npublic func sort(stable!: Bool = false): Unit\nFunction: Sorts the elements in the current array in ascending order.\n\nParameter:\n\nstable!: Bool - Whether to use stable sorting.\nfunc sortDescending(Bool)\n\npublic func sortDescending(stable!: Bool = false): Unit\nFunction: Sorts the elements in the current array in descending order.\n\nParameter:\n\nstable!: Bool - Whether to use stable sorting.\nextend<T> ArrayList<T> <: ToString where T <: ToString\nextend<T> ArrayList<T> <: ToString where T <: ToString\nFunction: Extend the ToString interface for ArrayList<T> to support conversion to strings.\n\nParent Type:\n\nToString\nfunc toString()\n\npublic func toString(): String\nFunction: Convert the current array to a string.\n\nThe string contains a string representation for each element in the array, like this: \"[elem1, elem2, elem3]\".\n\nReturn value:\n\nString - The resulting string."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass ArrayListIterator<T>\npublic class ArrayListIterator<T> <: Iterator<T> {\n    public init(data: ArrayList<T>)\n}\nFunction: This class mainly implements the iterator function of ArrayList.\n\nParent Type:\n\nIterator<T>\ninit(ArrayList<T>)\npublic init(data: ArrayList<T>)\nFunction: Create an ArrayListIterator<T> instance.\n\nParameter:\n\ndate: Passing in an ArrayList<T>.\nfunc next()\npublic func next(): Option<T>\nFunction: Returns to the next element in the iteration.\n\nReturn value:\n\nT - The next element in the iterator, encapsulated with Option.\nAbnormal:\n\nConcurrentModificationException - An exception is thrown when the function detects an out-of-sync concurrent modification.\nfunc iterator()\npublic func iterator(): Iterator<T>\nFunction: Returns to the iterator itself.\n\nReturn value:\n\nIterator<T> - The iterator itself."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass HashMapIterator<K, V> where K <: Hashable & Equatable<K>\npublic class HashMapIterator<K, V> <: Iterator<(K, V)> where K <: Hashable & Equatable<K> {\n    public init(map: HashMap<K, V>)\n}\nFunction: This class mainly implements the iterator function of HashMap.\n\nParent Type:\n\nIterator<(K, V)>\ninit(HashMap<K, V>)\npublic init(map: HashMap<K, V>)\nFunction: Create a HashMapIterator<K, V> instance.\n\nParameter:\n\nmap: HashMap<K, V> - Pass in HashMap<K, V>.\nfunc iterator()\npublic func iterator(): Iterator<(K, V)>\nFeature: Returns the iterator instance itself.\n\nReturn value:\n\nIterator <(K, V) > - The Iterator instance itself.\nfunc next()\npublic func next(): ?(K, V)\nFunction: Return to the next element in the iterator.\n\nReturn value:\n\n(K, V)—The next element in the iterator, encapsulated with Option.\nAbnormal:\n\nConcurrentModificationException - An exception is thrown when the function detects an out-of-sync concurrent modification.\nfunc remove()\npublic func remove(): Option<(K, V)>\nFunction: Removes the element returned by the next function of this HashMap iteratator, which can only be called once when the next function is called.\n\nReturn value:\n\nOption <(K, V) > - Returns deleted elements.\nAbnormal:\n\nConcurrentModificationException - An exception is thrown when the function detects an out-of-sync concurrent modification."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass HashMap<K, V> where K <: Hashable & Equatable<K>\npublic class HashMap<K, V> <: Map<K, V> where K <: Hashable & Equatable<K> {\n    public init()\n    public init(elements: Collection<(K, V)>)\n    public init(elements: Array<(K, V)>)\n    public init(capacity: Int64)\n    public init(size: Int64, initElement: (Int64) -> (K, V))\n}\nFeature: Hash table implementation of the Map interface.\n\nA hash table is a commonly used data structure that can be used to quickly find, insert, and delete data. The basic principle of a hash table is to map data into an array, which is called a hash table. Each data element has a corresponding hash value, which can be used to determine the position of the element in the hash table.\n\nHash tables are characterized by fast search, insert, and delete operations, and the time complexity is usually O(1). Because the array size at the bottom of the hash table is dynamic, the hash table cannot guarantee that the order of the elements is immutable.\n\nParent Type:\n\nMap<K, V>\nprop size\npublic prop size: Int64\nFunction: Returns the number of key-value pairs.\n\nType: Int64\n\ninit()\npublic init()\nFunction: Construct a HashMap with a default initial capacity of 16 and a default load factor of null.\n\ninit(Array<(K, V)>)\npublic init(elements: Array<(K, V)>)\nFunction: Construct a HashMap from an array of key-value pairs passed in.\n\nThe constructor sets the capacity of the HashMap based on the size of the incoming array. Since the HashMap does not allow duplicate keys, when there are duplicate keys in the Array, the following key-value pairs will overwrite the previous key-value pairs in the iterator order.\n\nParameter:\n\nelements: Array<(K, V)> - Initializes an array of key-value pairs for that HashMap.\ninit(Collection<(K, V)>)\npublic init(elements: Collection<(K, V)>)\nFunction: Construct a HashMap from a collection of key-value pairs passed in.\n\nThe constructor sets the capacity of the HashMap based on the size of the collection elements passed in. Since the HashMap does not allow duplicate keys, when there are duplicate keys in the Array, the following key-value pairs will overwrite the previous key-value pairs in the iterator order.\n\nParameter:\n\nelements: Collection<(K, V)> - Initializes the collection of key-value pairs for the HashMap.\ninit(Int64)\npublic init(capacity: Int64)\nFunction: Construct a HashMap with the size of the incoming capacity.\n\nParameter:\n\ncapacity: Int64 - Initializes the capacity size.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown if the capacity is less than 0.\ninit(Int64, (Int64) ->(K, V))\npublic init(size: Int64, initElement: (Int64) -> (K, V))\nFunction: Construct a HashMap by passing in the number of elements size and function rules.\n\nThe capacity of the constructed HashMap is affected by the size of the HashMap. Since key duplication is not allowed inside the HashMap, when the function initElement generates the same key, the later constructed key-value pair will overwrite the previous key-value pair.\n\nParameter:\n\nsize: Int64 - Initializes the function rule for the HashMap.\ninitElement: (Int64) ->(K, V) - Initializes the function rule for the HashMap.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown if the size is less than 0.\nfunc capacity()\npublic func capacity(): Int64\nFunction: Returns the capacity of the HashMap.\n\nReturn value:\n\nInt64 - The capacity of the HashMap.\nfunc clear()\npublic func clear(): Unit\nFunction: Clear all key-value pairs.\n\nExample:\n\nSee HashMap's putAll/remove/clear function for an example.\n\nfunc clone()\npublic func clone(): HashMap<K, V>\nFeature: Clone HashMap.\n\nReturn value:\n\nHashMap < K, V > - Returns a HashMap.\nfunc contains(K)\npublic func contains(key: K): Bool\nFunction: Determines whether to include a mapping of a specified key.\n\nParameter:\n\nkey: K - Pass the key to be judged.\nReturn value:\n\nBool - Returns true if present; Otherwise, false is returned.\nExample:\n\nSee the get/put/contains function of the hashmap for an example.\n\nfunc containsAll(Collection<K>)\npublic func containsAll(keys: Collection<K>): Bool\nFunction: Determines whether to contain the mapping of all keys in the specified collection.\n\nParameter:\n\nkeys: Collection<K> - The keys pass the keys to be determined.\nReturn value:\n\nBool - Returns true if they are all included; Otherwise, false is returned.\nfunc entryView(K)\npublic func entryView(key: K): EntryView<K, V>\nFunction: Returns an empty reference view if it does not contain a specific key. If a specific key is included, a reference view of the element corresponding to that key is returned.\n\nFor more information about how to use EntryView, see EntryView.\n\nParameter:\n\nkey: K - The key of the key-value pair to be added.\nReturn value:\n\nEntryView < K, V > - A reference view.\nfunc get(K)\npublic func get(key: K): Option<V>\nFunction: Returns the value mapped to by the specified key, or Option<V> if the HashMap does not contain the mapping of the specified key. None。\n\nParameter:\n\nkey: K - The key passed in.\nReturn value:\n\nOption<V> - The value of the key. Encapsulated with Option.\nExample:\n\nSee the get/put/contains function of the hashmap for an example.\n\nfunc isEmpty()\npublic func isEmpty(): Bool\nFunction: Determine whether the HashMap is empty, if so, return true; Otherwise, false is returned.\n\nReturn value:\n\nBool - Whether the HashMap is empty.\nfunc iterator()\npublic func iterator(): HashMapIterator<K, V>\nFeature: Iterator that returns a hashmap.\n\nReturn value:\n\nHashMapIterator < K, V > - The iterator that returns a HashMap.\nfunc keys()\npublic func keys(): EquatableCollection<K>\nFunction: Returns all keys in the HashMap and stores all keys in a key container.\n\nReturn value:\n\nEquatableCollection<K> - Holds all returned keys.\nfunc put(K, V)\npublic func put(key: K, value: V): Option<V>\nFunction: Put key-value pairs into a HashMap.\n\nFor a key that is already in the HashMap, the value of that key is replaced with the new value and the old value is returned.\n\nParameter:\n\nkey: K - The key to be placed.\nvalue: V—The value to be assigned.\nReturn value:\n\nOption<V> - If the key exists before the assignment, the old value is encapsulated with Option; Otherwise, Option<V> is returned. None。\nExample:\n\nSee the get/put/contains function of the hashmap for an example.\n\nfunc putAll(Collection<(K, V)>)\npublic func putAll(elements: Collection<(K, V)>): Unit\nFunction: Put a new collection of key-value pairs into a HashMap in the iterator order of the elements.\n\nFor a key that is already in the HashMap, the value of that key will be replaced with the new value.\n\nParameter:\n\nelements: Collection<(K, V)> - A collection of key-value pairs that need to be added to the HashMap.\nExample:\n\nSee HashMap's putAll/remove/clear function for an example.\n\nfunc putIfAbsent(K, V)\npublic func putIfAbsent(key: K, value: V): Bool\nFunction: Inserts key, value pairs into the HashMap when no key exists in the HashMap.\n\nParameter:\n\nkey: K - The key to be placed.\nvalue: V—The value to be assigned.\nReturn value:\n\nBool - Returns false if the key exists before the assignment, true otherwise.\nfunc remove(K)\npublic func remove(key: K): Option<V>\nFunction: Removes the mapping of the specified key from this HashMap, if it exists.\n\nParameter:\n\nkey: K - Pass in the key you want to delete.\nReturn value:\n\nOption<V> - The value of the key that was removed from the HashMap, encapsulated with Option, and returned None if the key is not stored in the HashMap.\nExample:\n\nSee HashMap's putAll/remove/clear function for an example.\n\nfunc removeAll(Collection<K>)\npublic func removeAll(keys: Collection<K>): Unit\nFunction: Removes the mapping of the keys in the specified collection from this HashMap, if one exists.\n\nParameter:\n\nkeys: Collection<K> - Pass in the collection of keys to be deleted.\nfunc removeIf((K, V) -> Bool)\npublic func removeIf(predicate: (K, V) -> Bool): Unit\nFunction: Pass in a lambda expression, and if the condition is met, delete the corresponding key-value pair.\n\nThe function traverses the entire HashMap, so key-value pairs that satisfy predicate(K, V) == true are removed.\n\nParameter:\n\npredicate: (K, V) ->Bool - Pass a lambda expression to judge.\nAbnormal:\n\nConcurrentModificationException - An exception is thrown when key-value pairs in the predicate are added or deleted, or when key-value pairs in the HashMap are modified.\nfunc reserve(Int64)\npublic func reserve(additional: Int64): Unit\nFunction: Expand the current HashMap.\n\nExpand the HashMap by additional sizeWhen additional is less than or equal to zero, the additional will not be expanded. When the remaining capacity of the HashMap is greater than or equal to addition, the capacity expansion does not occur. If the remaining capacity of the HashMap is less than addition, the maximum value of (1.5 times the original capacity is rounded down) and (additional + used capacity) is used to scale the scale.\n\nParameter:\n\nadditional: Int64 - The size to be scaled up.\nAbnormal:\n\nOverflowException - An exception is thrown when additional + used capacity exceeds Int64.Max.\nfunc toArray()\npublic func toArray(): Array<(K, V)>\nFunction: Construct an array containing key-value pairs in the HashMap and return it.\n\nReturn value:\n\nArray <(K, V) > - An array containing all key-value pairs within the container.\nfunc values()\npublic func values(): Collection<V>\nFunction: Returns the values contained in the HashMap and stores all values in a Values container.\n\nReturn value:\n\nCollection<V> - Holds all returned values.\noperator func [](K, V)\npublic operator func [](key: K, value!: V): Unit\nFunction: The operator overrides the put method, if the key exists, the new value overwrites the old value, and if the key does not exist, adds this key-value pair.\n\nParameter:\n\nkey: K - Pass the value for judgment.\nvalue!: V - Pass the value to be set.\noperator func [](K)\n\npublic operator func [](key: K): V\nFunction: The operator overloads the get method and returns the value corresponding to the key if it exists.\n\nParameter:\n\nkey: K - Pass the value for judgment.\nReturn value:\n\nV - The value corresponding to the key.\nAbnormal:\n\nNoneValueException - Throws this exception if the key does not exist for the HashMap.\nextend<K, V> HashMap<K, V> <: Equatable<HashMap<K, V>> where V <: Equatable<V>\nextend<K, V> HashMap<K, V> <: Equatable<HashMap<K, V>> where V <: Equatable<V>\nFunction: Extend the Equatable<HashMap<K, V>> APIs for HashMap<K and V> types, and support judgment and other operations.\n\nParent Type:\n\nEquatable<HashMap<K, V>>\noperator func ==(HashMap<K, V>)\n\npublic operator func ==(right: HashMap<K, V>): Bool\nFunction: Check whether the current instance is equal to the HashMap instance pointed to by the parameter.\n\nThe equality of two HashMaps means that the key-value pairs contained within them are exactly equal.\n\nParameter:\n\nright: HashMap - The object being compared.\nReturn value:\n\nBool - Returns true if equal, false otherwise.\noperator func !=(HashMap<K, V>)\n\npublic operator func !=(right: HashMap<K, V>): Bool\nFunction: Check whether the current instance is different from the HashMap instance pointed to by the parameter.\n\nParameter:\n\nright: HashMap - The object being compared.\nReturn value:\n\nBool - Returns true if it doesn't wait, false otherwise.\nextend<K, V> HashMap<K, V> <: ToString where V <: ToString, K <: ToString\nextend<K, V> HashMap<K, V> <: ToString where V <: ToString, K <: ToString\nFunction: Extend the ToString interface for HashMap<K and V> to support conversion to strings.\n\nParent Type:\n\nToString\nfunc toString()\n\npublic func toString(): String\nFunction: Converts the current HashMap instance to a string.\n\nThe string contains a string representation for each key-value pair in the HashMap, like this: \"[(k1, v1), (k2, v2), (k3, v3)]\".\n\nReturn value:\n\nString - The resulting string."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass HashSet<T> where T <: Hashable & Equatable<T>\npublic class HashSet<T> <: Set<T> where T <: Hashable & Equatable<T> {\n    public init()\n    public init(elements: Collection<T>)\n    public init(elements: Array<T>)\n    public init(capacity: Int64)\n    public init(size: Int64, initElement: (Int64) -> T)\n}\nFunction: An instance of the Set interface implemented based on HashMap.\n\nThe elements in the HashSet are unordered and no duplicate elements are allowed. When we add an element to a HashSet, the HashSet determines the position of the element in the hash table based on the hash value of the element.\n\nPrompt:\n\nHashSets are implemented based on HashMaps, so the capacity, memory layout, and time performance of HashSets are the same as those of HashMaps.\n\nParent Type:\n\nSet<T>\nprop size\npublic prop size: Int64\nFunction: Returns the number of elements in this HashSet.\n\nType: Int64\n\ninit(Int64, Int64 -> T)\npublic init(size: Int64, initElement: (Int64) -> T)\nFunction: Construct a HashSet based on the number of function elements passed in size, and the function rules. The capacity of the constructed HashSet is affected by the size of the HashSet.\n\nParameter:\n\nsize: Int64 - The number of elements in the initialization function.\ninitElement: (Int64) ->T - Initialize the function rule.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown if size is less than 0.\ninit()\npublic init()\nFunction: Construct an empty HashSet with an initial capacity of 16.\n\ninit(Array<T>)\npublic init(elements: Array<T>)\nFunction: Construct a HashSet using the incoming array. The constructor sets the capacity of the HashSet based on the size of the elements passed in.\n\nParameter:\n\nelements: Array<T> - Initializes an array of HashSets.\ninit(Collection<T>)\npublic init(elements: Collection<T>)\nFunction: Construct a HashSet using the collection passed in. The constructor sets the capacity of the HashSet based on the size of the collection elements passed in.\n\nParameter:\n\nelements: Collection<T> - Initializes the collection of HashSets.\ninit(Int64)\npublic init(capacity: Int64)\nFunction: Construct a HashSet using the incoming capacity.\n\nParameter:\n\ncapacity: Int64 - Initializes the capacity size.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown if the capacity is less than 0.\nfunc capacity()\npublic func capacity(): Int64\nFunction: Returns the size of the internal array capacity of this HashSet.\n\nnote\nThe capacity size is not necessarily equal to the size of the HashSet.\n\nReturn value:\n\nInt64 - Returns the size of the internal array of this HashSet.\nfunc clear()\npublic func clear(): Unit\nFeature: Removes all elements from this HashSet.\n\nfunc clone()\npublic func clone(): HashSet<T>\nFeature: Clone a HashSet.\n\nReturn value:\n\nHashSet<T> - Returns the cloned HashSet.\nfunc contains(T)\npublic func contains(element: T): Bool\nFunction: Determine whether a HashSet contains a specified element.\n\nParameter:\n\nelement: T—The specified element.\nReturn value:\n\nBool - Returns true if the specified element is included; Otherwise, false is returned.\nfunc containsAll(Collection<T>)\npublic func containsAll(elements: Collection<T>): Bool\nFunction: Determines whether the HashSet contains all elements in the specified Collection.\n\nParameter:\n\nelements: Collection<T> - The specified set of elements.\nReturn value:\n\nBool - Returns true if this HashSet contains all elements in the Collection; Otherwise, false is returned.\nfunc isEmpty()\npublic func isEmpty(): Bool\nFunction: Determine whether the HashSet is empty.\n\nReturn value:\n\nBool - returns true if empty; Otherwise, false is returned.\nfunc iterator()\npublic func iterator(): Iterator<T>\nFeature: An iterator that returns this HashSet.\n\nReturn value:\n\nIterator<T> - The iterator that returns this HashSet.\nExample:\n\nSee the put/iterator/remove function of the HashSet for an example.\n\nfunc put(T)\npublic func put(element: T): Bool\nFunction: Add the specified element to the HashSet, if the added element exists in the HashSet, the addition fails.\n\nParameter:\n\nelement: T—The specified element.\nReturn value:\n\nBool - Returns true if added successfully; Otherwise, false is returned.\nExample:\n\nSee the put/iterator/remove function of the HashSet for an example.\n\nfunc putAll(Collection<T>)\npublic func putAll(elements: Collection<T>): Unit\nFunction: Add all elements in the Collection to this HashSet, and if the element exists, don't add it.\n\nParameter:\n\nelements: Collection<T> - A collection of elements that need to be added.\nfunc remove(T)\npublic func remove(element: T): Bool\nFunction: If the specified element exists in this HashSet, it is removed.\n\nParameter:\n\nelement: T - The element that needs to be removed.\nReturn value:\n\nBool - true, indicating that the removal was successful; false, the removal fails.\nExample:\n\nSee the put/iterator/remove function of the HashSet for an example.\n\nfunc removeAll(Collection<T>)\npublic func removeAll(elements: Collection<T>): Unit\nFunction: Removes all elements of this HashSet that are also contained in the specified Collection.\n\nParameter:\n\nelements: Collection<T> - A collection of elements that need to be removed from this HashSet.\nfunc removeIf((T) -> Bool)\npublic func removeIf(predicate: (T) -> Bool): Unit\nFunction: Pass in a lambda expression, and if the true condition is met, delete the corresponding element.\n\nParameter:\n\npredicate: (T) ->Bool - The condition for determining whether to delete an element.\nAbnormal:\n\nConcurrentModificationException - An exception is thrown when a key-value pair in a HashSet is added or deleted from the predicate, or when a key-value pair in the HashSet is modified.\nfunc reserve(Int64)\npublic func reserve(additional: Int64): Unit\nFunction: Expand the additional size of the HashSet, and when the additional is less than or equal to zero, the additional will not be expanded. When the remaining capacity of a HashSet is greater than or equal to addition, the capacity expansion does not occur. When the remaining capacity of a HashSet is less than addition, the maximum value of (1.5 times the original capacity is rounded down) and (additional + used capacity) is used to scale out the scale.\n\nParameter:\n\nadditional: Int64 - The size to be scaled up.\nAbnormal:\n\nOverflowException - An exception is thrown when additional + used capacity exceeds Int64.Max.\nfunc retainAll(Set<T>)\npublic func retainAll(elements: Set<T>): Unit\nFeature: Retain elements in this HashSet from this HashSet.\n\nParameter:\n\nelements: Set<T> - Sets that need to be kept.\nfunc subsetOf(Set<T>)\npublic func subsetOf(other: Set<T>): Bool\nFunction: Check if the collection is a subset of other Sets.\n\nParameter:\n\nother: Set<T> - Pass in a collection, this function will determine if the current set is a subset of other.\nReturn value:\n\nBool - Returns true if the Set is a subset of the specified Set; Otherwise, it returns false.\nfunc toArray()\npublic func toArray(): Array<T>\nFunction: Returns an array containing all the elements inside the container.\n\nReturn value:\n\nArray<T> - Array of type T.\nextend<T> HashSet<T> <: Equatable<HashSet<T>>\nextend<T> HashSet<T> <: Equatable<HashSet<T>>\nFunction: Extend the Equatable<HashSet<T>> interface for the HashSet<T> type to support judgment and other operations.\n\nParent Type:\n\nEquatable<HashSet<T>>\noperator func ==(HashSet<T>)\n\npublic operator func ==(that: HashSet<T>): Bool\nFunction: Check whether the current instance is equal to the HashSet instance pointed to by the parameter.\n\nEquality of two HashSets means that the elements contained in them are exactly equal.\n\nParameter:\n\nthat: HashSet - The object being compared.\nReturn value:\n\nBool - Returns true if equal, false otherwise.\noperator func !=(HashSet<T>)\n\npublic operator func !=(that: HashSet<T>): Bool\nFunction: Check whether the current instance is different from the HashSet instance pointed to by the parameter.\n\nParameter:\n\nthat: HashSet - The object being compared.\nReturn value:\n\nBool - Returns true if it doesn't wait, false otherwise.\nextend<T> HashSet<T> <: ToString where T <: ToString\nextend<T> HashSet<T> <: ToString where T <: ToString\nFunction: Extend the ToString interface for HashSet<T> and support conversion to strings.\n\nParent Type:\n\nToString\nfunc toString()\n\npublic func toString(): String\nFunction: Converts the current HashSet instance to a string.\n\nThe string contains a string representation of each element in the HashSet, like this: \"[elem1, elem2, elem3]\".\n\nReturn value:\n\nString - The resulting string."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass LinkedListNode<T>\npublic class LinkedListNode<T>\nFeature: LinkedListNode is a node on LinkedList.\n\nLinkedList can be traversed forward to backward through the LinkedListNode, and the value of the element can also be accessed and modified.\n\nLinkedListNode can only be obtained through the corresponding LinkedList 'nodeAt', 'firstNode', 'lastNode', when LinkedList deletes the corresponding node, it will cause a dangling node, and any operation on the dangling node will throw an 'IllegalStateException' exception.\n\nprop next\npublic prop next: Option<LinkedListNode<T>>\nFunction: Get the next node of the current node, and return None if not.\n\n类型：Option<LinkedListNode<T>>\n\nAbnormal:\n\nIllegalStateException - This exception is thrown if the node does not belong to any linked list instance.\nprop prev\npublic prop prev: Option<LinkedListNode<T>>\nFunction: Get the previous node of the current node, and return None if not.\n\n类型：Option<LinkedListNode<T>>\n\nAbnormal:\n\nIllegalStateException - This exception is thrown if the node does not belong to any linked list instance.\nprop value\npublic mut prop value: T\nFunction: Get or modify the value of an element.\n\nType: T\n\nAbnormal:\n\nIllegalStateException - This exception is thrown if the node does not belong to any linked list instance.\nfunc backward()\npublic func backward(): Iterator<T>\nFunction: Get an iterator for all elements starting from the current node to the tail node of the corresponding linked list.\n\nReturn value:\n\nIterator<T> - The iterator of the corresponding element.\nAbnormal:\n\nIllegalStateException - This exception is thrown if the node does not belong to any linked list instance.\nfunc forward()\npublic func forward(): Iterator<T>\nFunction: Get an iterator for all elements starting from the current node to the head node of the corresponding linked list.\n\nReturn value:\n\nIterator<T> - The iterator of the corresponding element.\nAbnormal:\n\nIllegalStateException - This exception is thrown if the node does not belong to any linked list instance."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass LinkedList<T>\npublic class LinkedList<T> <: Collection<T> {\n    public init()\n    public init(elements: Collection<T>)\n    public init(elements: Array<T>)\n    public init(size: Int64, initElement: (Int64)-> T)\n}\nFunction: Implement the data structure of doubly linked lists.\n\nA doubly linked list is a common data structure that consists of a series of nodes, each containing two pointers, one to the previous node and the other to the next node. This structure allows for bidirectional traversal on any node, i.e. you can traverse backwards from the beginning node or forward from the tail node.\n\nLinkedList does not support concurrent operations, and modifications to elements in a collection do not invalidate the iterator, only when adding and removing elements.\n\nParent Type:\n\nCollection<T>\nprop first\npublic prop first: ?T\nFunction: The value of the first element in a linked list, which returns None if it is an empty linked list.\n\nType:? T\n\nprop last\npublic prop last: ?T\nFunction: The value of the last element in the linked list, or None if it is an empty linked list.\n\nType:? T\n\nprop size\npublic prop size: Int64\nFunction: The number of elements in a linked list.\n\nType: Int64\n\ninit\npublic init()\nFunction: Construct an empty linked list.\n\ninit(Array<T>)\npublic init(elements: Array<T>)\nFunction: Construct a LinkedList instance containing the specified collection elements in the order in which the array is traversed.\n\nParameter:\n\nelements: Array<T> - An array of elements to be placed in this linked list.\ninit(Collection<T>)\npublic init(elements: Collection<T>)\nFunction: Construct a linked list containing the specified collection elements in the order in which the collection iterator returns the elements.\n\nParameter:\n\nelements: Collection<T> - A collection of elements that will be placed in this linked list.\ninit(Int64, (Int64)-> T)\npublic init(size: Int64, initElement: (Int64)-> T)\nFunction: Create a linked list with size elements and the nth element satisfies the (Int64)-> T condition.\n\nParameter:\n\nsize: Int64—The number of linked list elements to be created.\ninitElement: (Int64) ->T - element's initialization parameter.\nAbnormal:\n\nIllegalArgumentException - This exception is thrown if the specified linked list length is less than 0.\nfunc append(T)\npublic func append(element: T): LinkedListNode<T>\nFunction: Add an element at the end of the linked list and return the node of that element.\n\nParameter:\n\nelement: T - The element to be added to the linked list.\nReturn value:\n\nLinkedListNode<T> - The node that points to that element.\nfunc clear()\npublic func clear(): Unit\nFunction: Remove all elements in a linked list.\n\nfunc firstNode()\npublic func firstNode(): Option<LinkedListNode<T>>\nFunction: Get the node of the first element in the linked list.\n\nReturn value:\n\nOption < LinkedListNode<T>> - Node of the first element, returns None if the linked list is empty.\nfunc insertAfter(LinkedListNode<T>,T)\npublic func insertAfter(node: LinkedListNode<T>, element: T): LinkedListNode<T>\nFunction: Inserts an element after a specified node in a linked list, and returns the node of that element.\n\nParameter:\n\nnode: LinkedListNode<T> - 指定的节点。\nelement: T - The element to be added to the linked list.\nReturn value:\n\nLinkedListNode<T> - Refers to the node into which the element was inserted.\nAbnormal:\n\nIllegalArgumentException - This exception is thrown if the specified node does not belong to the linked list.\nfunc insertBefore(<T>LinkedListNode,T)\npublic func insertBefore(node: LinkedListNode<T>, element: T): LinkedListNode<T>\nFunction: Inserts an element in front of a specified node in a linked list, and returns the node of that element.\n\nParameter:\n\nnode: LinkedListNode<T> - 指定的节点。\nelement: T - The element to be added to the linked list.\nReturn value:\n\nLinkedListNode<T> - Refers to the node into which the element was inserted.\nAbnormal:\n\nIllegalArgumentException - This exception is thrown if the specified node does not belong to the linked list.\nfunc isEmpty()\npublic func isEmpty(): Bool\nFunction: Returns the judgment of whether the linked list is an empty linked list.\n\nReturn value:\n\nBool - Returns true if there are no elements in this linked list.\nfunc iterator()\npublic func iterator(): Iterator<T>\nFunction: Returns an iterator of the elements in the current set, in order from the first node of the linked list to the last node of the linked list.\n\nReturn value:\n\nIterator<T> - Iterator of the elements in the current collection.\nfunc lastNode()\npublic func lastNode(): Option<LinkedListNode<T>>\nFunction: Get the node of the last element in the linked list.\n\nReturn value:\n\nOption < LinkedListNode<T>> - Node of the last element, returns None if the linked list is empty.\nfunc nodeAt(Int64)\npublic func nodeAt(index: Int64): Option<LinkedListNode<T>>\nFunction: Get the nodes of the index element in the linked list, numbered from 0.\n\nThe time complexity of this function is O(n).\n\nParameter:\n\nindex: Int64 - Specifies the node to get the index element.\nReturn value:\n\nOption < LinkedListNode<T>> - Node numbered index, if not returned, None.\nfunc popFirst()\npublic func popFirst() : ?T\nFunction: Removes the first element of the linked list and returns the value of that element.\n\nReturn value:\n\n? T - The value of the element that was deleted, or None if the linked list is empty.\nfunc popLast()\npublic func popLast() : ?T\nFunction: Removes the last element of the linked list and returns the value of that element.\n\nReturn value:\n\n? T - The value of the element that was deleted, or None if the linked list is empty.\nfunc prepend(T)\npublic func prepend(element: T): LinkedListNode<T>\nFunction: Inserts an element at the head of the linked list and returns the node of that element.\n\nParameter:\n\nelement: T - The element to be added to the linked list.\nReturn value:\n\nLinkedListNode<T> - The node that points to that element.\nfunc remove(LinkedListNode<T>)\npublic func remove(node: LinkedListNode<T>): T\nFunction: Deletes a specified node in a linked list.\n\nParameter:\n\nnode: LinkedListNode<T> - 要被删除的节点。\nReturn value:\n\nT—The value of the node that was deleted.\nAbnormal:\n\nIllegalArgumentException - This exception is thrown if the specified node does not belong to the linked list.\nfunc removeIf((T)-> Bool)\npublic func removeIf(predicate: (T)-> Bool): Unit\nFunction: Removes all elements in this linked list that satisfy a given lambda expression or function.\n\nParameter:\n\npredicate: (T) ->Bool - Returns true for the element to be removed.\nfunc reverse()\npublic func reverse(): Unit\nFunction: Invert the order of the elements in this linked list.\n\nfunc splitOff(LinkedListNode<T>)\npublic func splitOff(node: LinkedListNode<T>): LinkedList<T>\nFunction: Start from the specified node, split the linked list into two linked lists, if the split is successful, the node is not in the current linked list, but exists in the new linked list as the first node.\n\nParameter:\n\nnode: LinkedListNode<T> - 要分割的位置。\nReturn value:\n\nLinkedList<T> - A newly generated linked list after the original linked list has been split.\nAbnormal:\n\nIllegalArgumentException - This exception is thrown if the specified node does not belong to the linked list.\nfunc toArray()\npublic func toArray(): Array<T>\nFunction: Returns an array containing all the elements in that linked list, and in the same order as the linked list.\n\nReturn value:\n\nArray<T> - Array of type T.\n<T> extend LinkedList<T> <: Equatable<LinkedList<T>> where T <: Equatable<T>\nextend<T> LinkedList<T> <: Equatable<LinkedList<T>> where T <: Equatable<T>\nFunction: Extend the Equatable<LinkedList<T>> interface for LinkedList<T>> to support judgment and other operations.\n\nParent Type:\n\nEquatable<LinkedList<T>>\noperator func ==(LinkedList<T>)\n\npublic operator func ==(right: LinkedList<T>): Bool\nFunction: Check whether the current instance is equal to the LinkedList instance pointed to by the parameter.\n\nTwo LinkedLists are equal when the elements contained in them are exactly equal.\n\nParameter:\n\nright: HashSet - The object being compared.\nReturn value:\n\nBool - Returns true if equal, false otherwise.\noperator func !=(LinkedList<T>)\n\npublic operator func !=(right: LinkedList<T>): Bool\nFunction: Check whether the current instance is not equal to the LinkedList instance pointed to by the parameter.\n\nParameter:\n\nright: LinkedList - The object being compared.\nReturn value:\n\nBool - Returns true if it doesn't wait, false otherwise.\nextend<T> LinkedList<T> <: ToString where T <: ToString\nextend<T> LinkedList<T> <: ToString where T <: ToString\nFunction: Extend the ToString interface for LinkedList<T> to support conversion to strings.\n\nParent Type:\n\nToString\nfunc toString()\n\npublic func toString(): String\nFeature: Converts the current LinkedList instance to a string.\n\nThe string contains a string representation of each element within the LinkedList, like this: \"[elem1, elem2, elem3]\".\n\nReturn value:\n\nString - The resulting string."}
{"text": "Cangjie programming language syntax:\nstd.collection package\n\nclass TreeMap<K, V> where K <: Comparable<K>\npublic class TreeMap<K, V> <: Map<K, V> where K <: Comparable<K> {\n    public init()\n    public init(elements: Collection<(K, V)>)\n    public init(elements: Array<(K,V)>)\n    public init(size: Int64, initElement: (Int64) -> (K, V))\n}\nFunction: An instance of the Map interface implemented based on a balanced binary search tree.\n\nThe main purpose of this class is to provide an ordered key-value storage structure that can be used to quickly insert, delete, and find elements.\n\nTreeMap can be used in any scenario that requires ordered key-value pair storage, such as databases, caches, lookup tables, etc.\n\nParent Type:\n\nMap<K, V>\nprop size\npublic prop size: Int64\nFunction: Returns the number of keys.\n\nType: Int64\n\ninit()\npublic init()\nFunction: Construct an empty TreeMap.\n\ninit(Array<(K,V)>)\npublic init(elements: Array<(K,V)>)\nFunction: Construct a TreeMap from an array of key-value pairs passed in.\n\nInsert elements into the TreeMap in the order of the elements, since the same key is not allowed in the TreeMap, if there is the same key in the elements, the later key-value pair will overwrite the first-appearing key-value pair.\n\nParameter:\n\nelements: Array<(K, V)> - Initializes the array of key-value pairs for the TreeMap.\ninit(Collection<(K, V)>)\npublic init(elements: Collection<(K, V)>)\nFunction: Construct a TreeMap from a collection of key-value pairs passed in.\n\nInsert elements into the TreeMap in the iterator order of the elements, and since the same keys are not allowed in the TreeMap, if the same key is in the elements, the key-value pair that appears later (in the iterator order) will overwrite the key-value pair that occurs first.\n\nParameter:\n\nelements: Collection<(K, V)> - Initializes the collection of key-value pairs for the TreeMap.\ninit(Int64, (Int64) ->(K, V))\npublic init(size: Int64, initElement: (Int64) -> (K, V))\nFunction: Construct a TreeMap based on the number of elements passed in size, and function rules.\n\nParameter:\n\nsize: Int64 - Number of elements passed in.\ninitElement: (Int64) ->(K, V) - Initializes the function rule for the TreeMap.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown if the size is less than 0.\nfunc clear()\npublic func clear(): Unit\nFunction: Clear all key-value pairs.\n\nfunc clone()\npublic func clone(): TreeMap<K, V>\nFeature: Clone TreeMap.\n\nReturn value:\n\nTreeMap < K, V > - Returns a TreeMap instance.\nfunc contains(K)\npublic func contains(key: K): Bool\nFunction: Determines whether to include a mapping of a specified key.\n\nParameter:\n\nkey: K - Pass the key to be judged.\nReturn value:\n\nBool - Returns true if present; Otherwise, false is returned.\nfunc containsAll(Collection<K>)\npublic func containsAll(keys: Collection<K>): Bool\nFunction: Determines whether to contain a mapping of a specified collection key.\n\nParameter:\n\nkeys: Collection<K> - A collection of keys.\nReturn value:\n\nBool - Returns true if present; Otherwise, false is returned.\nfunc findLower(K, Bool)\npublic func findLower(bound: K, inclusive!: Bool = false): Option<TreeMapNode<K, V>>\nFunction: Returns the largest element smaller than the key passed in.\n\nParameter:\n\nbound: K - The key passed in.\ninclusive!: Bool - Whether or not to include the key passed in itself, defaults to false, i.e. does not contain.\nReturn value:\n\nOption < TreeMapNode < K, V >> - If such an element exists, encapsulate the element with Option<TreeMapNode<K, V>> and return; Otherwise, return Option<TreeMapNode<K, V>>. None。\nfunc findUpper(K, Bool)\npublic func findUpper(bound: K, inclusive!: Bool = false): Option<TreeMapNode<K, V>>\nFunction: Returns the smallest element larger than the key passed in.\n\nParameter:\n\nbound: K - The key passed in.\ninclusive!: Bool - Whether or not to include the key passed in itself, defaults to false, i.e. does not contain.\nReturn value:\n\nOption < TreeMapNode < K, V >> - If such an element exists, encapsulate the element with Option<TreeMapNode<K, V>> and return; Otherwise, return Option<TreeMapNode<K, V>>. None。\nfunc firstEntry()\npublic func firstEntry(): Option<(K, V)>\nFunction: Get the first element of the TreeMap.\n\nReturn value:\n\nOption <(K, V) > - if the first element exists, encapsulate it with Option and return; Otherwise, return Option<(K, V)>. None。\nfunc get(K)\npublic func get(key: K): Option<V>\nFunction: Returns the value of the specified key mapping.\n\nParameter:\n\nkey: K - The key specified.\nReturn value:\n\nOption<V> - If such a value exists, encapsulate the value with Option and return; Otherwise, Option<V> is returned. None。\nfunc isEmpty()\npublic func isEmpty(): Bool\nFunction: Determine whether the TreeMap is empty.\n\nReturn value:\n\nBool - Returns true if empty, false otherwise.\nfunc iterator()\npublic func iterator(): Iterator<(K, V)>\nFunction: Returns the iterator of the TreeMap, and the iterator iterates in order from the smallest to the largest key value.\n\nReturn value:\n\nIterator <(K, V) > - Iterator for TreeMap.\nfunc keys()\npublic func keys(): EquatableCollection<K>\nFunction: Returns all keys in the TreeMap and stores all keys in a container.\n\nReturn value:\n\nEquatableCollection<K> - A collection that contains all keys.\nfunc lastEntry()\npublic func lastEntry(): Option<(K, V)>\nFunction: Get the last element of the TreeMap.\n\nReturn value:\n\nOption <(K, V) > - if the last element exists, encapsulate the element with Option and return; Otherwise, return Option<(K, V)>. None。\nfunc popFirstEntry()\npublic func popFirstEntry(): Option<(K, V)>\nFunction: Remove the first element of the TreeMap.\n\nReturn value:\n\nOption <(K, V) > - If the first element exists, delete it, encapsulate it with Option and return; Otherwise, return Option<(K, V)>. None。\nfunc popLastEntry()\npublic func popLastEntry(): Option<(K, V)>\nFeature: Remove the last element of the TreeMap.\n\nReturn value:\n\nOption <(K, V) > - If the last element exists, delete it, encapsulate it with Option and return; Otherwise, return Option<(K, V)>. None。\nfunc put(K, V)\npublic func put(key: K, value: V): Option<V>\nFunction: Put new key-value pairs into TreeMap. For a key that is already in the TreeMap, the value of that key is replaced with the new value.\n\nParameter:\n\nkey: K - The key to be placed.\nvalue: V—The value to be assigned.\nReturn value:\n\nOption<V> - If the key exists before the assignment, the old value is encapsulated with Option and returned; Otherwise, Option<V> is returned. None。\nfunc putAll(Collection<K, V>)\npublic func putAll(elements: Collection<(K, V)>): Unit\nFunction: Put a new collection of key-value pairs into a TreeMap. For a key that is already in the TreeMap, the value of that key is replaced with the new value.\n\nParameter:\n\nelements: Collection<(K, V)> - A collection of key-value pairs that need to be added to the TreeMap.\nfunc remove(K)\npublic func remove(key: K): Option<V>\nFunction: Removes the mapping of the specified key from this mapping, if it exists.\n\nParameter:\n\nkey: K - Pass in the key you want to delete.\nReturn value:\n\nOption<V> - The value of the removed map is encapsulated with Option, which returns None if the specified key is not present in the TreeMap.\nfunc removeAll(Collection<K>)\npublic func removeAll(keys: Collection<K>): Unit\nFunction: Removes the mapping of the specified collection from this mapping, if it exists.\n\nParameter:\n\nkeys: Collection<K> - Pass in the collection of keys to be deleted.\nfunc removeIf((K, V) -> Bool)\npublic func removeIf(predicate: (K, V) -> Bool): Unit\nFunction: Pass in a lambda expression, and if the condition is met, delete the corresponding key value.\n\nParameter:\n\npredicate: (K, V) ->Bool - Pass a lambda expression to judge.\nfunc values()\npublic func values(): Collection<V>\nFunction: Returns the values contained in the TreeMap and stores all the values in a container.\n\nReturn value:\n\nCollection<V> - A collection that contains all values.\noperator func [](K, V)\npublic operator func [](key: K, value!: V): Unit\nFunction: The operator overloads the collection, if the key exists, the new value overwrites the old value, and if the key does not exist, adds this key-value pair.\n\nParameter:\n\nkey: K - Pass the value for judgment.\nvalue!: V - Pass the value to be set.\noperator func [](K)\npublic operator func [](key: K): V\nFunction: The operator overloads the collection and returns the value corresponding to the key if the key exists.\n\nParameter:\n\nkey: K - Pass the value for judgment.\nReturn value:\n\nV - The value corresponding to the key.\nAbnormal:\n\nNoneValueException - Throws an exception if the key does not exist for the HashMap.\nextend<K, V> TreeMap<K, V> <: Equatable<TreeMap<K, V>> where V <: Equatable<V>\nextend<K, V> TreeMap<K, V> <: Equatable<TreeMap<K, V>> where V <: Equatable<V>\nFunction: Extend the Equatable<TreeMap<K and V> interfaces for TreeMap<K and V> types, and support judgment and other operations.\n\nParent Type:\n\nEquatable<TreeMap<K, V>>\noperator func ==(TreeMap<K, V>)\n\npublic operator func ==(right: TreeMap<K, V>): Bool\nFunction: Check whether the current instance is equal to the TreeMap instance pointed to by the parameter.\n\nThe equality of two TreeMaps means that the key-value pairs contained within them are exactly equal.\n\nParameter:\n\nright: TreeMap - The object being compared.\nReturn value:\n\nBool - Returns true if equal, false otherwise.\noperator func !=(TreeMap<K, V>)\n\npublic operator func !=(right: TreeMap<K, V>): Bool\nFunction: Check whether the current instance is different from the TreeMap instance pointed to by the parameter.\n\nParameter:\n\nright: TreeMap - The object being compared.\nReturn value:\n\nBool - Returns true if it doesn't wait, false otherwise.\nextend<K, V> TreeMap<K, V> <: ToString where V <: ToString, K <: ToString & Comparable<K>\nextend<K, V> TreeMap<K, V> <: ToString where V <: ToString, K <: ToString & Comparable<K>\nFunction: Extend the ToString interface for TreeMap<K and V> to support string conversion operations.\n\nParent Type:\n\nToString\nfunc toString()\n\npublic func toString(): String\nFunction: Converts the current TreeMap instance to a string.\n\nThe string contains a string representation for each key-value pair in the TreeMap, like this: \"[(k1, v1), (k2, v2), (k3, v3)]\".\n\nReturn value:\n\nString - The resulting string."}
{"text": "Cangjie programming language syntax:\nHere's how to add an element to an ArrayList:import std.collection.*\n\nmain() {\n    var list: ArrayList<Int64> = ArrayList<Int64>(10) //Create an ArrayList with a capacity of 10\n    var arr: Array<Int64> = [1, 2, 3]\n    list.appendAll(arr) // list: [1, 2, 3]\n    list.set(1, 120) // list: [1, 120, 3]\n    var b = list.get(2)\n    print(\"b=${b.getOrThrow()},\")\n    list.insert(1, 12) // list: [1, 12, 120, 3]\n    var c = list.get(2)\n    print(\"c=${c.getOrThrow()},\")\n    var arr1: Array<Int64> = [1,2,3]\n    list.insertAll(1, arr1) // list: [1, 1, 2, 3, 12, 120, 3]\n    var d = list.get(2)\n    print(\"d=${d.getOrThrow()}\")\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nThis use case shows how to use the get method to get the value of the corresponding index in ArrayList, and to modify the value using the set method.\n\nHere's the code:import std.collection.*\nmain() {\n    var list = ArrayList<Int64>([97, 100]) // list: [97, 100]\n    list.set(1, 120) // list: [97, 120]\n    var b = list.get(1)\n    print(\"b=${b.getOrThrow()}\")\n    return 0\n}\n\n//The result is as follows:b=120"}
{"text": "Cangjie programming language syntax:\nThis use case shows how to use ArrayList's remove/clear/slice function.\n\nHere's the code:import std.collection.*\nmain() {\n    var list: ArrayList<Int64> = ArrayList<Int64>(97, 100, 99) // Function call syntactic sugar of variable-length\n    list.remove(1) // list: [97, 99]\n    var b = list.get(1)\n    print(\"b=${b.getOrThrow()},\")\n    list.clear()\n    list.append(11) // list: [97, 99, 11]\n    var arr: Array<Int64> = [1, 2, 3]\n    list.insertAll(0, arr) // list: [1, 2, 3, 97, 99]\n    var g = list.get(0)\n    print(\"g=${g.getOrThrow()},\")\n    let r: Range<Int64> = 1..=2 : 1\n    var sublist: ArrayList<Int64> = list.slice(r) // sublist: [2, 3]\n    var m = sublist.get(0)\n    print(\"m=${m.getOrThrow()}\")\n    return 0\n}\n\n//The result is as follows:b=99,g=1,m=2"}
{"text": "Cangjie programming language syntax:\nThis use case shows the basics of how to use HashMap.\n\nHere's the code:import std.collection.*\nmain() {\n    var map: HashMap<String, Int64> = HashMap<String, Int64>()\n    map.put(\"a\", 99) // map : [(\"a\", 99)]\n    map.put(\"b\", 100) // map : [(\"a\", 99), (\"b\", 100)]\n    var a = map.get(\"a\")\n    var bool = map.contains(\"a\")\n    print(\"a=${a.getOrThrow()} \")\n    print(\"bool=${bool.toString()}\")\n    return 0\n}\n\n//The result is as follows:a=99 bool=true"}
{"text": "Cangjie programming language syntax:\nThis use case shows the basics of how to use HashMap.\n\nHere's the code:import std.collection.*\nmain() {\n    var map: HashMap<String, Int64> = HashMap<String, Int64>()\n    var arr: Array<(String, Int64)> = [(\"d\", 11), (\"e\", 12)]\n    map.putAll(arr) // map : [(\"d\", 11), (\"e\", 12)]\n    var d = map.get(\"d\")\n    print(\"d=${d.getOrThrow()} \")\n    map.remove(\"d\") // map : [(\"e\", 12)]\n    var bool = map.contains(\"d\")\n    print(\"bool=${bool.toString()} \")\n    map.clear() // map: []\n    var bool1 = map.contains(\"e\")\n    print(\"bool1=${bool1.toString()}\")\n    return 0\n}\n\n//The result is as follows:d=11 bool=false bool1=false"}
{"text": "Cangjie programming language syntax:\nThis use case shows the basic usage of a HashSet.\n\nHere's the code:import std.collection.*\n/* test */\nmain() {\n    var set: HashSet<String> = HashSet<String>() // set: []\n    set.put(\"apple\") // set: [\"apple\"]\n    set.put(\"banana\") // set: [\"apple\", \"banana\"], not in order\n    set.put(\"orange\") // set: [\"apple\", \"banana\", \"orange\"], not in order\n    set.put(\"peach\") // set: [\"apple\", \"banana\", \"orange\", \"peach\"], not in order\n    var itset = set.iterator()\n    while(true) {\n        var value = itset.next()\n        match(value) {\n            case Some(v) =>\n                if (!set.contains(v)) {\n                    print(\"Operation failed\")\n                    return 1\n                } else { println(v) }\n            case None => break\n        }\n    }\n    set.remove(\"apple\") // set: [\"banana\", \"orange\", \"peach\"], not in order\n    println(set)\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nThis use case shows how an iterator manipulation function can be used in conjunction with a pipeline expression.\n\nHere's the code:import std.collection.*\n\n\nmain() {\n    let arr = [-1, 2, 3, 4, 5, 6, 7, 8, 9]\n    arr |> filter{a: Int64 => a > 0} |> // filter -1\n        step<Int64>(2) |> // [2, 4, 6, 8]\n        skip<Int64>(2) |> // [6, 8]\n        forEach<Int64>(println)\n\n\n    let str = arr |> filter{a: Int64 => a % 2 == 1} |> collectString<Int64>(delimiter: \">\")\n    println(str)\n    println(arr |> contains(6_i64))\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nconcurrentHashMap usage example:import std.collection.*\nimport std.collection.concurrent.*\nimport std.sync.*\n\n\nmain() {\n    let threads = 8\n    let M = 1024\n\n\n    let cmap = ConcurrentHashMap<Int64, Int64>(concurrencyLevel: 64)\n    let jobs = Array<Future<Unit>>(threads, item: unsafe { zeroValue<Future<Unit>>() })\n    for (t in 0..threads) {\n        jobs[t] = spawn {\n            for (i in t..M : threads) {\n                cmap.put(i, i + 3)\n            }\n        }\n    }\n\n\n    for (t in 0..threads) {\n        jobs[t].get()\n    }\n\n\n    println(\"Size after put: ${cmap.size}\")\n\n\n    for (t in 0..threads) {\n        jobs[t] = spawn {\n            for (i in t..M : threads) {\n                cmap.remove(i, {v => v % 2 == 0})\n            }\n        }\n    }\n\n\n    for (t in 0..threads) {\n        jobs[t].get()\n    }\n\n\n    println(\"Size after remove first: ${cmap.size}\")\n\n\n    for (t in 0..threads) {\n        jobs[t] = spawn {\n            for (i in t..M : threads) {\n                cmap.remove(i)\n            }\n        }\n    }\n\n\n    for (t in 0..threads) {\n        jobs[t].get()\n    }\n\n\n    println(\"Size after remove second: ${cmap.size}\")\n}\n\n//Here are the results:\nSize after put: 1024\nSize after remove first: 512\nSize after remove second: 0"}
{"text": "Cangjie programming language syntax:\nNonBlockingQueue usage example:import std.collection.*\nimport std.collection.concurrent.*\nimport std.sync.*\n\n\nmain() {\n    let threads = 8\n    let total: Int64 = 128\n    let bq = NonBlockingQueue<Int64>(Array<Int64>(total, {i => i}))\n    println(\"Total ${bq.size} after init\")\n    let jobs = Array<Future<Unit>>(threads, item: unsafe { zeroValue<Future<Unit>>() })\n    for (t in 0..threads) {\n        jobs[t] = spawn {\n            for (i in t..total : threads) {\n                bq.dequeue()\n            }\n        }\n    }\n\n\n    for (t in 0..threads) {\n        jobs[t].get()\n    }\n    println(\"Total ${bq.size} after dequeue\")\n}\n\n//Here are the results:\n\nTotal 128 after init\nTotal 0 after dequeue"}
{"text": "Cangjie programming language syntax:\nHere's an example of the Console that receives two pieces of information from the user and returns them to the user as is via standard output.import std.console.*\n\n\nmain() {\n    Console.stdOut.write(\"请输入信息1：\")\n    var c = Console.stdIn.readln() // input：你好，请问今天星期几？\n    var r = c.getOrThrow()\n    Console.stdOut.writeln(\"输入的信息1为：\" + r)\n\n\n    Console.stdOut.write(\"请输入信息2：\")\n    c = Console.stdIn.readln() // output：你好，请问今天几号？\n    r = c.getOrThrow()\n    Console.stdOut.writeln(\"输入的信息2为：\" + r)\n\n\n    return\n}"}
{"text": "Cangjie programming language syntax:\nConvert usage example:import std.convert.*\n\n\nmain():Int64 {\n    var strBool_parse : String = \"true\"\n    var strBool_tryParse : String = \"false\"\n    var strChar_parse : String = \"'a'\"\n    var strChar_tryParse : String = \"'\\\\u{00e2}'\"\n    var strInt8_parse : String = \"-128\"\n    var strInt8_tryParse : String = \"127\"\n    var strInt16_parse : String = \"-32768\"\n    var strInt16_tryParse : String = \"32767\"\n    var strInt32_parse : String = \"-2147483648\"\n    var strInt32_tryParse : String = \"2147483647\"\n    var strInt64_parse : String = \"-9223372036854775808\"\n    var strInt64_tryParse : String = \"9223372036854775807\"\n    var strFloat16_parse : String = \"-65504.0\"\n    var strFloat16_tryParse : String = \"65504.0\"\n    var strFloat32_parse : String = \"-3.14159\"\n    var strFloat32_tryParse : String = \"3.14159\"\n    var strFloat64_parse : String = \"-3.1415926\"\n    var strFloat64_tryParse : String = \"3.1415926\"\n    var strUInt8_parse : String = \"255\"\n    var strUInt8_tryParse : String = \"255\"\n    var strUInt16_parse : String = \"65535\"\n    var strUInt16_tryParse : String = \"65535\"\n    var strUInt32_parse : String = \"4294967295\"\n    var strUInt32_tryParse : String = \"4294967295\"\n    var strUInt64_parse : String = \"18446744073709551615\"\n    var strUInt64_tryParse : String = \"18446744073709551615\"\n\n\n    println(\"After the conversion of parse, \\\"true\\\" became ${Bool.parse(strBool_parse)}\")\n    println(\"After the conversion of tryParse, \\\"false\\\" became ${Bool.tryParse(strBool_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"'a'\\\" became ${Rune.parse(strChar_parse)}\")\n    println(\"After the conversion of tryParse, \\\"'\\\\u{00e2}'\\\" became ${Rune.tryParse(strChar_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"-128\\\" became ${Int8.parse(strInt8_parse)}\")\n    println(\"After the conversion of tryParse, \\\"127\\\" became ${Int8.tryParse(strInt8_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"-32768\\\" became ${Int16.parse(strInt16_parse)}\")\n    println(\"After the conversion of tryParse, \\\"32767\\\" became ${Int16.tryParse(strInt16_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"-2147483648\\\" became ${Int32.parse(strInt32_parse)}\")\n    println(\"After the conversion of tryParse, \\\"2147483647\\\" became ${Int32.tryParse(strInt32_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"-9223372036854775808\\\" became ${Int64.parse(strInt64_parse)}\")\n    println(\"After the conversion of tryParse, \\\"9223372036854775807\\\" became ${Int64.tryParse(strInt64_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"-65504.0\\\" became ${Float16.parse(strFloat16_parse)}\")\n    println(\"After the conversion of tryParse, \\\"65504.0\\\" became ${Float16.tryParse(strFloat16_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"-3.14159\\\" became ${Float32.parse(strFloat32_parse)}\")\n    println(\"After the conversion of tryParse, \\\"3.14159\\\" became ${Float32.tryParse(strFloat32_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"-3.1415926\\\" became ${Float64.parse(strFloat64_parse)}\")\n    println(\"After the conversion of tryParse, \\\"3.1415926\\\" became ${Float64.tryParse(strFloat64_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"255\\\" became ${UInt8.parse(strUInt8_parse)}\")\n    println(\"After the conversion of tryParse, \\\"255\\\" became ${UInt8.tryParse(strUInt8_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"65535\\\" became ${UInt16.parse(strUInt16_parse)}\")\n    println(\"After the conversion of tryParse, \\\"65535\\\" became ${UInt16.tryParse(strUInt16_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"4294967295\\\" became ${UInt32.parse(strUInt32_parse)}\")\n    println(\"After the conversion of tryParse, \\\"4294967295\\\" became ${UInt32.tryParse(strUInt32_tryParse)}\")\n\n\n    println(\"After the conversion of parse, \\\"18446744073709551615\\\" became ${UInt64.parse(strUInt64_parse)}\")\n    println(\"After the conversion of tryParse, \\\"18446744073709551615\\\" became ${UInt64.tryParse(strUInt64_tryParse)}\")\n    return 0\n}\n\n//The result is as follows:\n\nAfter the conversion of parse, \"true\" became true\nAfter the conversion of tryParse, \"false\" became Some(false)\nAfter the conversion of parse, \"'a'\" became a\nAfter the conversion of tryParse, \"'\\u{00e2}'\" became Some(â)\nAfter the conversion of parse, \"-128\" became -128\nAfter the conversion of tryParse, \"127\" became Some(127)\nAfter the conversion of parse, \"-32768\" became -32768\nAfter the conversion of tryParse, \"32767\" became Some(32767)\nAfter the conversion of parse, \"-2147483648\" became -2147483648\nAfter the conversion of tryParse, \"2147483647\" became Some(2147483647)\nAfter the conversion of parse, \"-9223372036854775808\" became -9223372036854775808\nAfter the conversion of tryParse, \"9223372036854775807\" became Some(9223372036854775807)\nAfter the conversion of parse, \"-65504.0\" became -65504.000000\nAfter the conversion of tryParse, \"65504.0\" became Some(65504.000000)\nAfter the conversion of parse, \"-3.14159\" became -3.141590\nAfter the conversion of tryParse, \"3.14159\" became Some(3.141590)\nAfter the conversion of parse, \"-3.1415926\" became -3.141593\nAfter the conversion of tryParse, \"3.1415926\" became Some(3.141593)\nAfter the conversion of parse, \"255\" became 255\nAfter the conversion of tryParse, \"255\" became Some(255)\nAfter the conversion of parse, \"65535\" became 65535\nAfter the conversion of tryParse, \"65535\" became Some(65535)\nAfter the conversion of parse, \"4294967295\" became 4294967295\nAfter the conversion of tryParse, \"4294967295\" became Some(4294967295)\nAfter the conversion of parse, \"18446744073709551615\" became 18446744073709551615\nAfter the conversion of tryParse, \"18446744073709551615\" became Some(18446744073709551615)"}
{"text": "Cangjie programming language syntax:\nFormat the integer\nHere's an example of formatting an integer.\n\nHere's the code:import std.format.*\n\n\nmain(): Int64 {\n    var a: Int32 = -20\n    var res1 = a.format(\"-10\")\n    var res2 = a.format(\"+10\")\n    var res3 = (-20).format(\"10\")\n    var res4 = a.format(\"-\")\n    println(\"\\\"${res1}\\\"\")\n    println(\"\\\"${res2}\\\"\")\n    println(\"\\\"${res3}\\\"\")\n    println(\"\\\"${res4}\\\"\")\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nFormat floating-point type\nHere's an example of formatting a floating-point type.\n\nHere's the code:import std.format.*\n\n\n/* flags '-' */\nmain(): Int64 {\n    var a: Float16 = -0.34\n    var b: Float32 = .34\n    var c: Float64 = 3_0.3__4_\n    var d: Float64 = 20.00\n    /* left  align */\n    var res1 = a.format(\"-20\")\n    /* right align */\n    var res2 = b.format(\"+20\")\n    /* left  align */\n    var res3 = c.format(\"10\")\n    /* left  align */\n    var res4 = d.format(\"-10\")\n    /* left  align */\n    var res5 = d.format(\"-\")\n    println(\"\\\"${res1}\\\"\")\n    println(\"\\\"${res2}\\\"\")\n    println(\"\\\"${res3}\\\"\")\n    println(\"\\\"${res4}\\\"\")\n    println(\"\\\"${res5}\\\"\")\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nFormat the character type\nThe following is an example of formatting a character.\n\nHere's the code:import std.format.*\n\n\nmain(): Int64 {\n    var a: Rune = 'a'\n    var b: Rune = '-'\n    /* left  align */\n    var res1 = a.format(\"-10\")\n    /* right  align */\n    var res2 = b.format(\"-10\")\n    /* left  align */\n    var res3 = a.format(\"10\")\n    /* left  align */\n    var res4 = b.format(\"10\")\n    println(\"\\\"${res1}\\\"\")\n    println(\"\\\"${res2}\\\"\")\n    println(\"\\\"${res3}\\\"\")\n    println(\"\\\"${res4}\\\"\")\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nDirectory some basic operations demonstrated\nHere's the code:import std.fs.*\n\n\nmain() {\n    let testDirPath: Path = Path(\"./testDir\")\n    let subDirPath: Path = Path(\"./testDir/subDir\")\n    if (Directory.exists(testDirPath)) {\n        Directory.delete(testDirPath, recursive: true)\n    }\n\n\n    /* 递归创建目录 和 \"./testDir/subDir\" */\n    let subDir: Directory = Directory.create(subDirPath, recursive: true)\n    if (Directory.exists(subDirPath)) {\n        println(\"The directory './testDir/subDir' is successfully created recursively in current directory.\")\n    }\n\n\n    /* 在 \"./testDir/subDir\" 下创建子目录 \"dir1\" */\n    subDir.createSubDirectory(\"dir1\")\n    if (Directory.exists(\"./testDir/subDir/dir1\")) {\n        println(\"The directory 'dir1' is created successfully in directory './testDir/subDir'.\")\n    }\n\n\n    /* 在 \"./testDir/subDir\" 下创建子文件 \"file1\" */\n    subDir.createFile(\"file1\")\n    if (File.exists(\"./testDir/subDir/file1\")) {\n        println(\"The file 'file1' is created successfully in directory './testDir/subDir'.\")\n    }\n\n\n    /* 在 \"./testDir\" 下创建临时目录 */\n    let tempDir: Directory = Directory.createTemp(testDirPath)\n    let tempDirPath: Path = tempDir.info.path\n    if (Directory.exists(tempDirPath)) {\n        println(\"The temporary directory is created successfully in directory './testDir'.\")\n    }\n\n\n    /* 将 \"subDir\" 移动到临时目录下并重命名为 \"subDir_new\" */\n    let newSubDirPath: Path = tempDirPath.join(\"subDir_new\")\n    Directory.move(subDirPath, newSubDirPath, false)\n    if (Directory.exists(newSubDirPath) && !Directory.exists(subDirPath)) {\n        println(\"The directory './testDir/subDir' is moved successfully to the temporary directory and renamed 'subDir_new'.\")\n    }\n\n\n    /* 将 \"subDir_new\" 拷贝到 \"./testDir\" 下并重命名为 \"subDir\" */\n    Directory.copy(newSubDirPath, subDirPath, false)\n    if (Directory.exists(subDirPath) && Directory.exists(newSubDirPath)) {\n        println(\"The directory 'subDir_new' is copied successfully to directory './testDir' and renamed 'subDir'.\")\n    }\n\n\n    Directory.delete(testDirPath, recursive: true)\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nFile General operations: create, delete, read/write, close\nHere's the code:import std.fs.*\nimport std.io.SeekPosition\n\n\nmain() {\n    let filePath: Path = Path(\"./tempFile.txt\")\n    if (File.exists(filePath)) {\n        File.delete(filePath)\n    }\n\n\n    /*Create a new file 'tempFile. txt' in write only mode in the current directory, write '123456789' three times and close the file*/\n    var file: File = File(filePath, OpenOption.Create(false))\n    if (File.exists(filePath)) {\n        println(\"The file 'tempFile.txt' is created successfully in current directory.\\n\")\n    }\n    let bytes: Array<Byte> = \"123456789\\n\".toArray()\n    for (_ in 0..3) {\n        file.write(bytes)\n    }\n    file.close()\n\n\n    /*Open file in append mode /tempFile.txt'， Write 'abcdefghi \\ n' and close the file*/\n    file = File(filePath, OpenOption.Append)\n    file.write(\"abcdefghi\\n\".toArray())\n    file.close()\n\n\n    /*Open the file in read-only mode /tempFile.txt'， Read the data as required and close the file*/\n    file = File(filePath, OpenOption.Open(true, false))\n    let bytesBuf: Array<Byte> = Array<Byte>(10, item: 0)\n    //Read the data of the last 10 bytes of the file\n    file.seek(SeekPosition.Begin(10))\n    file.read(bytesBuf)\n    println(\"Data of the 10th byte after the 10th byte: ${String.fromUtf8(bytesBuf)}\")\n    //Read the data of the last 10 bytes of the file\n    file.seek(SeekPosition.End(-10))\n    file.read(bytesBuf)\n    println(\"Data of the last 10 bytes: ${String.fromUtf8(bytesBuf)}\")\n    file.close()\n\n\n   /*Open file in truncation mode /tempFile.txt'， Write 'The file was truncated to an empty file!' and close the file*/\n    file = File(filePath, OpenOption.Truncate(true))\n    file.write(\"The file was truncated to an empty file!\".toArray())\n    file.seek(SeekPosition.Begin(0))\n    let allBytes: Array<Byte> = file.readToEnd()\n    file.close()\n    println(\"Data written newly: ${String.fromUtf8(allBytes)}\")\n\n\n    File.delete(filePath)\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nFileInfo demonstrates some basic operations\nHere's the code:import std.fs.*\nimport std.time.DateTime\n\n\nmain() {\n    //Create a temporary file in the current directory for the FileInfo demonstration below\n    let curDirPath: Path = Path(\"./\").toCanonical()\n    let file: File =  File.createTemp(curDirPath)\n    file.write(\"123456789\\n\".toArray())\n    let fileInfo: FileInfo = file.info\n\n\n    file.close()\n\n\n    /*Obtain FileInfo for the parent directory of this file, which is the current directory*/\n    let parentDirectory: Option<FileInfo> = fileInfo.parentDirectory\n    checkResult(parentDirectory == Some(FileInfo(curDirPath)), \"The 'parentFileInfo' is obtained successfully.\")\n\n\n    /*Obtain the path to this file*/\n    /*\n    let filePath: Path = fileInfo.path\n    */\n\n\n   /*If the file is a soft link, obtain the path of its linked file. The file here is not a soft link, so it is Option<Path>. None*/\n    let symbolicLinkTarget: Option<Path> = fileInfo.symbolicLinkTarget\n    checkResult(symbolicLinkTarget == None, \"It's not a symbolic link, there's no `symbolicLinkTarget`.\")\n\n\n    /*Get the creation time, last access time, and last modification time of this file*/\n    /*\n    let creationTime: DateTime = fileInfo.creationTime\n    let lastAccessTime: DateTime = fileInfo.lastAccessTime\n    let lastModificationTime: DateTime = fileInfo.lastModificationTime\n    */\n\n\n    /*\n     *Get the length of this file\n    *If it is a file, it represents the size of disk space occupied by this file\n    *If it is a directory, it represents the size of disk space occupied by all files in this directory (excluding subdirectories)\n     */\n    /*\n    let length: Int64 = fileInfo.length\n    */\n\n\n    /*Determine whether this file is a soft link, regular file, or directory*/\n    checkResult(fileInfo.isSymbolicLink(), \"The file is a symbolic link.\")\n    checkResult(fileInfo.isFile(), \"The file is a common file.\")\n    checkResult(fileInfo.isDirectory(), \"The file is a directory.\")\n\n\n   /*Determine whether this file is read-only, hidden, executable, readable, and writable for the current user*/\n    checkResult(fileInfo.isReadOnly(), \"This file is read-only.\")\n    checkResult(fileInfo.isHidden(), \"The file is hidden.\")\n    checkResult(fileInfo.canExecute(), \"The file is executable.\")\n    checkResult(fileInfo.canRead(), \"The file is readable.\")\n    checkResult(fileInfo.canWrite(), \"The file is writable.\")\n\n\n    /*Modify the current user's permissions for this file, setting it as read-only for the current user*/\n    checkResult(fileInfo.setExecutable(false), \"The file was successfully set to executable.\")\n    checkResult(fileInfo.setReadable(true), \"The file was successfully set to readable.\")\n    checkResult(fileInfo.setWritable(false), \"The file was successfully set to writable.\")\n    checkResult(fileInfo.isReadOnly(), \"This file is now read-only.\")\n\n\n    return 0\n}\n\n\nfunc checkResult(result: Bool, message: String): Unit {\n    if (result) {\n        println(message)\n    }\n}"}
{"text": "Cangjie programming language syntax:\nThe attributes of different path instances are displayed\nPrint the directory portion of the Path instance, the full name of the file (with extension), the extension, and the file name (without the extension), and determine whether the Path instance is an absolute or relative path\n\nHere's the code:import std.fs.Path\n\n\nmain() {\n    let pathStrArr: Array<String> = [\n        // 绝对路径\n        \"/a/b/c\",\n        \"/a/b/\",\n        \"/a/b/c.cj\",\n        \"/a\",\n        \"/\",\n        // 相对路径\n        \"./a/b/c\",\n        \"./a/b/\",\n        \"./a/b/c.cj\",\n        \"./\",\n        \".\",\n        \"123.\"\n    ]\n\n\n    for (i in 0..pathStrArr.size) {\n        let path: Path = Path(pathStrArr[i])\n        // 打印 path 的整个路径字符串\n        println(\"Path${i}: ${path.toString()}\")\n        // 打印 path 的目录路径\n        println(\"Path.directoryName: ${path.directoryName}\")\n        // 打印 path 的文件全名（有扩展名）\n        println(\"Path.fileName: ${path.fileName}\")\n        // 打印 path 的扩展名\n        println(\"Path.extensionName: ${path.extensionName}\")\n        // 打印 path 的文件名（无扩展名）\n        println(\"Path.fileNameWithoutExtension: ${path.fileNameWithoutExtension}\")\n        // 打印 path 的拆分成的目录路径和文件全名\n        var (directoryName, fileName): (Option<Path>, Option<String>) = path.split()\n        println(\"Path.split: (${directoryName}, ${fileName})\")\n        // 打印 path 是否是绝对路径、相对路径\n        println(\"Path.isAbsolute: ${path.isAbsolute()}; Path.isRelative: ${path.isRelative()}\")\n        println()\n    }\n\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nFunction introduction\nThe math package provides common mathematical operations, constant definitions, floating-point number processing, and more.\n\nThe following capabilities are included:\n\nDefinition of scientific constants and type constants;\nJudgment of floating-point numbers, regularization;\ncommonly used bit operations;\nGeneral mathematical functions such as absolute values, trigonometric functions, exponentials, logarithmic calculations;\nThe greatest common divisor and the least common multiple.\nList of APIs\nfunction\n函数名\tfunction\nabs(Float16)\tFind the absolute value of a half-precision floating-point number.\nabs(Float32)\tFind the absolute value of a single-precision floating-point number.\nabs(Float64)\tFind the absolute value of a double-precision floating-point number.\nabs(Int8)\tFind the absolute value of an 8-bit signed integer.\nabs(Int16)\tFind the absolute value of a 16-bit signed integer.\nabs(Int32)\tFind the absolute value of a 32-bit signed integer.\nabs(Int64)\tFind the absolute value of a 64-bit signed integer.\nacos(Float16)\tCalculates the value of the inverse cosine function of a half-precision floating-point number in radians.\nacos(Float32)\tCalculates the inverse cosine function value of a single-precision floating-point number in radians.\nacos(Float64)\tCalculates the value of the inverse cosine function of a double-precision floating-point number in radians.\nacosh(Float16)\tCalculate the value of the inverse hyperbolic cosine function for half-precision floating-point numbers.\nacosh(Float32)\tCalculate the value of the inverse hyperbolic cosine function for single-precision floating-point numbers.\nacosh(Float64)\tCalculates the value of the inverse hyperbolic cosine function of a double-precision floating-point number.\nasin(Float16)\tCalculate the arcsine value of a half-precision floating-point number, in radians.\nasin(Float32)\tCalculate the arcsine value of a single-precision floating-point number in radians.\nasin(Float64)\tCalculate the arcsine value of a double-precision floating-point number, in radians.\nasinh(Float16)\tCalculate the value of the inverse hyperbolic sine function for half-precision floating-point numbers.\nasinh(Float32)\tCalculate the value of the inverse hyperbolic sine function for single-precision floating-point numbers.\nasinh(Float64)\tCalculates the value of the inverse hyperbolic sine function for double-precision floating-point numbers.\natan(Float16)\tCalculate the value of the arctangent function for half-precision floating-point numbers, in radians.\natan(Float32)\tCalculate the arctangent function value of a single-precision floating-point number in radians.\natan(Float64)\tCalculate the arctangent function value of a double-precision floating-point number in radians.\natanh(Float16)\tCalculate the value of the inverse hyperbolic tangent function for half-precision floating-point numbers.\natanh(Float32)\tCalculates the value of the inverse hyperbolic tangent function for single-precision floating-point numbers.\natanh(Float64)\tCalculate the value of the inverse hyperbolic tangent function for double-precision floating-point numbers.\ncbrt(Float16)\tFind the cube root of a half-precision floating-point number.\ncbrt(Float32)\tFind the cube root of a single-precision floating-point number.\ncbrt(Float64)\tFind the cube root of a double-precision floating-point number.\nceil(Float16)\tRounding up for a half-precision floating-point number.\nceil(Float32)\tRounding up the value of a single-precision floating-point number.\nceil(Float64)\tFind the round-up value of a double-precision floating-point number.\ncheckedAbs(Int8)\tCheck and find the absolute value of an 8-bit signed integer. If the input argument is the minimum value of an 8-bit signed integer, the function returns None; Otherwise, Some(abs(x)) is returned.\ncheckedAbs(Int16)\tCheck and find the absolute value of a 16-bit signed integer. If the input argument is the minimum value of a 16-bit signed integer, the function returns None; Otherwise, Some(abs(x)) is returned.\ncheckedAbs(Int32)\tCheck and find the absolute value of a 32-bit signed integer. If the input argument is the minimum value of a 32-bit signed integer, the function returns None; Otherwise, Some(abs(x)) is returned.\ncheckedAbs(Int64)\tCheck and find the absolute value of a 64-bit signed integer. If the input argument is the minimum value of a 64-bit signed integer, the function returns None; Otherwise, Some(abs(x)) is returned.\nclamp(Float16, Float16, Float16)\tFind the number of range intervals for floating-point numbers. If the floating-point number is in the range, the floating-point number is returned; If this floating-point number is less than this range range, the minimum value of the range interval is returned; If the floating-point number is greater than this range, the maximum value of the range interval is returned; If it is NaN, NaN is returned.\nclamp(Float32, Float32, Float32)\tFind the number of range intervals for floating-point numbers. If the floating-point number is in the range, the floating-point number is returned; If this floating-point number is less than this range range, the minimum value of the range interval is returned; If the floating-point number is greater than this range, the maximum value of the range interval is returned; If it is NaN, NaN is returned.\nclamp(Float64, Float64, Float64)\tFind the number of range intervals for floating-point numbers. If the floating-point number is in the range, the floating-point number is returned; If this floating-point number is less than this range range, the minimum value of the range interval is returned; If the floating-point number is greater than this range, the maximum value of the range interval is returned; If it is NaN, NaN is returned.\ncos(Float16)\tThe cosine function value of the half-precision floating-point number is calculated, and the unit of the input parameter is radians.\ncos(Float32)\tThe cosine function value of a single-precision floating-point number is calculated, and the unit of input parameter is radians.\ncos(Float64)\tThe cosine function value of the double-precision floating-point number is calculated, and the unit of input parameter is radians.\ncosh(Float16)\tCalculates the value of the hyperbolic cosine function for half-precision floating-point numbers.\ncosh(Float32)\tCalculate the value of the hyperbolic cosine function for single-precision floating-point numbers.\ncosh(Float64)\tCalculates the value of the hyperbolic cosine function for a double-precision floating-point number.\ncountOne(Int8)\tFind the number of bits of 1 in the binary expression of an 8-bit integer.\ncountOne(Int16)\tFind the number of bits of 1 in the binary expression of a 16-bit integer.\ncountOne(Int32)\tFind the number of bits of 1 in the binary expression of a 32-bit integer.\ncountOne(Int64)\tFind the number of bits of 1 in the binary expression of a 64-bit integer.\ncountOne(UInt8)\tFind the number of bits of 1 in the binary expression of an 8-bit unsigned integer.\ncountOne(UInt16)\tFind the number of bits of 1 in a binary expression of a 16-bit unsigned integer.\ncountOne(UInt32)\tFind the number of bits of 1 in a binary expression of a 32-bit unsigned integer.\ncountOne(UInt64)\tFind the number of bits of 1 in a binary expression of a 64-bit unsigned integer.\nerf(Float16)\tFind the error value of a half-precision floating-point number.\nerf(Float32)\tFind the error value of a single-precision floating-point number.\nerf(Float64)\tFind the error value of a double-precision floating-point number.\nexp(Float16)\tFind the power of x of the natural constant e.\nexp(Float32)\tFind the power of x of the natural constant e.\nexp(Float64)\tFind the power of x of the natural constant e.\nexp2(Float16)\tFind the power of 2 to the power of x.\nexp2(Float32)\tFind the power of 2 to the power of x.\nexp2(Float64)\tFind the power of 2 to the power of x.\nfloor(Float16)\tRounding down the floating-point number.\nfloor(Float32)\tRounding down the floating-point number.\nfloor(Float64)\tRounding down the floating-point number.\ngamma(Float16)\tFind the gamma value of the floating-point number.\ngamma(Float32)\tFind the gamma value of the floating-point number.\ngamma(Float64)\tFind the gamma value of the floating-point number.\ngcd(Int8, Int8)\tFind the greatest common divisor of two 8-bit signed integers.\ngcd(Int16, Int16)\tFind the greatest common divisor of two 16-bit signed integers.\ngcd(Int32, Int32)\tFind the greatest common divisor of two 32-bit signed integers.\ngcd(Int64, Int64)\tFind the greatest common divisor of two 64-bit signed integers.\ngcd(UInt16, UInt16)\tFind the greatest common divisor of two 16-bit unsigned integers.\ngcd(UInt32, UInt32)\tFind the greatest common divisor of two 32-bit unsigned integers.\ngcd(UInt64, UInt64)\tFind the greatest common divisor of two 64-bit unsigned integers.\ngcd(UInt8, UInt8)\tFind the greatest common divisor of two 8-bit unsigned integers.\nlcm(Int8, Int8)\tFind the least, non-negative common multiple of two 8-bit signed integers, and return 0 when the input argument has 0.\nlcm(Int16, Int16)\tFind the smallest non-negative common multiple of two 16-bit signed integers, and return 0 when the input argument has 0.\nlcm(Int32, Int32)\tFind the smallest non-negative common multiple of two 32-bit signed integers, and return 0 when the input argument has 0.\nlcm(Int64, Int64)\tFind the smallest non-negative common multiple of two 64-bit signed integers, and return 0 when the input argument has 0.\nlcm(UInt8, UInt8)\tFind the smallest non-negative common multiple of two 8-bit unsigned integers, and return 0 when the input argument has 0.\nlcm(UInt16, UInt16)\tFind the smallest non-negative common multiple of two 16-bit unsigned integers, and return 0 when the input argument has 0.\nlcm(UInt32, UInt32)\tFind the smallest non-negative common multiple of two 32-bit unsigned integers, and return 0 when the input argument has 0.\nlcm(UInt64, UInt64)\tFind the smallest non-negative common multiple of two 64-bit unsigned integers, and return 0 when the input argument has 0.\nleadingZeros(Int8)\tFind the number of consecutive digits of 0 in the binary expression of an 8-bit signed integer, including the signed bit, from the highest digit. If the highest bit is not 0, 0 is returned.\nleadingZeros(Int16)\tFind the number of consecutive digits of 0 in the binary expression of a 16-bit signed integer, starting from the highest digit. If the highest bit is not 0, 0 is returned.\nleadingZeros(Int32)\tFind the number of consecutive digits of 0 in the binary expression of a 32-bit signed integer, starting from the highest digit. If the highest bit is not 0, 0 is returned.\nleadingZeros(Int64)\tFind the number of consecutive digits of 0 in the binary expression of a 64-bit signed integer, starting from the highest digit. If the highest bit is not 0, 0 is returned.\nleadingZeros(UInt8)\tFind the number of consecutive digits of 0 in the binary expression of an 8-bit unsigned integer, starting from the highest digit.\nleadingZeros(UInt16)\tFind the number of consecutive digits of 0 in the binary expression of a 16-bit unsigned integer, starting from the highest digit.\nleadingZeros(UInt32)\tFind the number of consecutive digits with 0 in the binary representation of a 32-bit unsigned integer, starting from the highest digit.\nleadingZeros(UInt64)\tFind the number of consecutive digits of 0 in the binary expression of a 64-bit unsigned integer, starting from the highest digit.\nlog(Float16)\tFind the logarithm of x with e as the base.\nlog(Float32)\tFind the logarithm of x with e as the base.\nlog(Float64)\tFind the logarithm of x with e as the base.\nlog10(Float16)\tFind the logarithm of x with a base of 10.\nlog10(Float32)\tFind the logarithm of x with a base of 10.\nlog10(Float64)\tFind the logarithm of x with a base of 10.\nlog2(Float16)\tFind the logarithm of x with 2 as the base.\nlog2(Float32)\tFind the logarithm of x with 2 as the base.\nlog2(Float64)\tFind the logarithm of x with 2 as the base.\nlogBase(Float16, Float16)\tFind the logarithm of base x.\nlogBase(Float32, Float32)\tFind the logarithm of base x.\nlogBase(Float64, Float64)\tFind the logarithm of base x.\nmax(Float16, Float16)\tFind the maximum value of two numbers.\nmax(Float32, Float32)\tFind the maximum value of two numbers.\nmax(Float64, Float64)\tFind the maximum value of two numbers.\nmax(Int8, Int8)\tFind the maximum value of two numbers.\nmax(Int16, Int16)\tFind the maximum value of two numbers.\nmax(Int32, Int32)\tFind the maximum value of two numbers.\nmax(Int64, Int64)\tFind the maximum value of two numbers.\nmax(UInt8, UInt8)\tFind the maximum value of two numbers.\nmax(UInt16, UInt16)\tFind the maximum value of two numbers.\nmax(UInt32, UInt32)\tFind the maximum value of two numbers.\nmax(UInt64, UInt64)\tFind the maximum value of two numbers.\nmaxNaN(Float16, Float16)\tFind the maximum value of two numbers.\nmaxNaN(Float32, Float32)\tFind the maximum value of two numbers.\nmaxNaN(Float64, Float64)\tFind the maximum value of two numbers.\nmin(Float16, Float16)\tFind the minimum value of two numbers.\nmin(Float32, Float32)\tFind the minimum value of two numbers.\nmin(Float64, Float64)\tFind the minimum value of two numbers.\nmin(Int8, Int8)\tFind the minimum value of two numbers.\nmin(Int16, Int16)\tFind the minimum value of two numbers.\nmin(Int32, Int32)\tFind the minimum value of two numbers.\nmin(Int64, Int64)\tFind the minimum value of two numbers.\nmin(UInt8, UInt8)\tFind the minimum value of two numbers.\nmin(UInt16, UInt16)\tFind the minimum value of two numbers.\nmin(UInt32, UInt32)\tFind the minimum value of two numbers.\nmin(UInt64, UInt64)\tFind the minimum value of two numbers.\nminNaN(Float16, Float16)\tFind the minimum value of two numbers.\nminNaN(Float32, Float32)\tFind the minimum value of two numbers.\nminNaN(Float64, Float64)\tFind the minimum value of two numbers.\npow(Float32, Float32)\tFind the exponent power of the floating-point base.\npow(Float32, Int32)\tFind the exponent power of the floating-point base.\npow(Float64, Float64)\tFind the exponent power of the floating-point base.\npow(Float64, Int64)\tFind the exponent power of the floating-point base.\nreverse(UInt8)\tFind the number of unsigned integers after bitwise reversal.\nreverse(UInt16)\tFind the number of unsigned integers after bitwise reversal.\nreverse(UInt32)\tFind the number of unsigned integers after bitwise reversal.\nreverse(UInt64)\tFind the number of unsigned integers after bitwise reversal.\nrotate(Int16, Int8)\tFind the result of bitwise rotation of an integer.\nrotate(Int32, Int8)\tFind the result of bitwise rotation of an integer.\nrotate(Int64, Int8)\tFind the result of bitwise rotation of an integer.\nrotate(Int8, Int8)\tFind the result of bitwise rotation of an integer.\nrotate(UInt16, Int8)\tFind the result of bitwise rotation of an integer.\nrotate(UInt32, Int8)\tFind the result of bitwise rotation of an integer.\nrotate(UInt64, Int8)\tFind the result of bitwise rotation of an integer.\nrotate(UInt8, Int8)\tFind the result of bitwise rotation of an integer.\nround(Float16)\tThis function uses IEEE-754's rounding rule to calculate the rounding value of floating-point numbers.\nround(Float32)\tThis function uses IEEE-754's rounding rule to calculate the rounding value of floating-point numbers.\nround(Float64)\tThis function uses IEEE-754's rounding rule to calculate the rounding value of floating-point numbers.\nsin(Float16)\tThe value of the sinusoidal function of the half-precision floating-point number is calculated, and the unit of the input parameter is radians.\nsin(Float32)\tThe value of the sinusoidal function of a single-precision floating-point number is calculated, and the unit of input parameter is radians.\nsin(Float64)\tThe value of the sinusoidal function of the double-precision floating-point number is calculated, and the input parameter is in radians.\nsinh(Float16)\tCalculates the value of the hyperbolic sine function for half-precision floating-point numbers.\nsinh(Float32)\tCalculates the value of the hyperbolic sine function for single-precision floating-point numbers.\nsinh(Float64)\tCalculates the value of the hyperbolic sine function for double-precision floating-point numbers.\nsqrt(Float16)\tFind the arithmetic square root of a floating-point number.\nsqrt(Float32)\tFind the arithmetic square root of a floating-point number.\nsqrt(Float64)\tFind the arithmetic square root of a floating-point number.\ntan(Float16)\tThe tangent function value of the half-precision floating-point number is calculated, and the unit of the input parameter is radians.\ntan(Float32)\tThe tangent function value of a single-precision floating-point number is calculated, and the unit of input parameter is radians.\ntan(Float64)\tThe tangent function value of the double-precision floating-point number is calculated, and the input parameter is in radians.\ntanh(Float16)\tCalculates the value of the hyperbolic tangent function for half-precision floating-point numbers.\ntanh(Float32)\tCalculates the value of the hyperbolic tangent function for single-precision floating-point numbers.\ntanh(Float64)\tCalculates the value of the hyperbolic tangent function for a double-precision floating-point number.\nthrowIllegalArgumentException()\tThis function is used to throw an illegal parameter exception.\ntrailingZeros(Int8)\tFind the number of consecutive digits of 0 in the binary expression of a 16-bit signed integer, starting from the lowest bit. If the lowest bit is not 0, 0 is returned.\ntrailingZeros(Int16)\tFind the number of consecutive digits of 0 in the binary expression of a 16-bit signed integer, starting from the lowest bit. If the lowest bit is not 0, 0 is returned.\ntrailingZeros(Int32)\tFind the number of consecutive digits of 0 in the binary expression of a 32-bit signed integer, starting from the lowest bit. If the lowest bit is not 0, 0 is returned.\ntrailingZeros(Int64)\tFind the number of consecutive digits of 0 from the lowest digit in the binary representation of a 64-bit signed integer. If the lowest bit is not 0, 0 is returned.\ntrailingZeros(UInt8)\tFind the number of consecutive digits of 0 in the binary expression of an 8-bit unsigned integer, starting from the lowest bit. If the lowest bit is not 0, 0 is returned.\ntrailingZeros(UInt16)\tFind the number of consecutive digits of 0 in the binary expression of a 16-bit unsigned integer, starting from the lowest bit. If the lowest bit is not 0, 0 is returned.\ntrailingZeros(UInt32)\tFind the number of consecutive digits of 0 in the binary expression of a 32-bit unsigned integer, starting from the lowest digit. If the lowest bit is not 0, 0 is returned.\ntrailingZeros(UInt64)\tFind the number of consecutive digits of 0 in the binary representation of a 64-bit unsigned integer, starting from the lowest digit. If the lowest bit is not 0, 0 is returned.\ntrunc(Float16)\tFind the truncated integer value of the floating-point number.\ntrunc(Float32)\tFind the truncated integer value of the floating-point number.\ntrunc(Float64)\tFind the truncated integer value of the floating-point number."}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc abs(Float16)\npublic func abs(x: Float16): Float16\nFunction: Find the absolute value of a half-precision floating-point number.\n\nParameter:\n\nx: Float16 - Incoming half-precision floating-point number.\nReturn value:\n\nFloat16 - Returns the absolute value of the incoming parameter.\nExample:import std.math.abs\nmain() {\n    let n: Float16 = -23.0\n    let abs = abs(n)\n    println(abs)\n}\n\n//Results:23.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc abs(Float32)\npublic func abs(x: Float32): Float32\nFunction: Find the absolute value of a single-precision floating-point number.\n\nParameter:\n\nx: Float32—Incoming single-precision floating-point number.\nReturn value:\n\nFloat32 - Returns the absolute value of the incoming parameter.\nExample:import std.math.abs\nmain() {\n    let n: Float32 = -23.0\n    let abs = abs(n)\n    println(abs)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc abs(Int64)\npublic func abs(x: Int64): Int64\nFunction: Find the absolute value of a 64-bit signed integer.\n\nParameter:\n\nx: Int64—A 64-bit signed integer passed in.\nReturn value:\n\nInt64—Returns the absolute value of the incoming parameter.\nAbnormal:\n\nOverflowException - Throws an exception when the input parameter is the minimum value of a signed integer.\nExample:import std.math.abs\nmain() {\n    let n: Int64 = -23\n    let abs = abs(n)\n    println(abs)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc acos(Float32)\npublic func acos(x: Float32): Float32\nFunction: Calculates the value of the inverse cosine function of a single-precision floating-point number.\n\nParameter:\n\nx: Float32—Incoming single-precision floating-point number. -1.0 <= x <= 1.0。\nReturn value:\n\nFloat32—Returns the value of the inverse cosine function of the incoming parameter, in radians.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when parameter x is greater than 1.0 or less than -1.0.\nExample:import std.math.acos\n\nmain() {\n    let n: Float32 = 1.0\n    let acos = acos(n)\n    println(acos)\n}\n\n//Results:0.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc acosh(Float64)\npublic func acosh(x: Float64): Float64\nFunction: Calculates the value of the inverse hyperbolic cosine function of a double-precision floating-point number.\n\nParameter:\n\nx: Float64—Incoming double-precision floating-point number. x >= 1.0。\nReturn value:\n\nFloat64—Returns the value of the inverse hyperbolic cosine function for the incoming parameter.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when parameter x is less than 1.0.\nExample:import std.math.acosh\n\n\nmain() {\n    let n: Float64 = 1.0\n    let acosh = acosh(n)\n    println(acosh)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc asin(Float64)\npublic func asin(x: Float64): Float64\nFunction: Calculates arcsine function values for double-precision floating-point numbers.\n\nParameter:\n\nx: Float64—Incoming double-precision floating-point number. -1.0 <= x <= 1.0。\nReturn value:\n\nFloat64—Returns the arcsine function value of the incoming parameter, in radians.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when parameter x is greater than 1.0 or less than -1.0.\nExample:import std.math.asin\nmain() {\n    let n: Float64 = 0.0\n    let asin = asin(n)\n    println(asin)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc asinh(Float16)\npublic func asinh(x: Float16): Float16\nFunction: Calculates the value of the inverse hyperbolic sine function of a half-precision floating-point number.\n\nParameter:\n\nx: Float16 - Incoming half-precision floating-point number.\nReturn value:\n\nFloat16—Returns the value of the inverse hyperbolic sinusoidal function for the incoming parameter.\nExample:import std.math.asinh\nmain() {\n    let n: Float16 = 0.0\n    let asinh = asinh(n)\n    println(asinh)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc atan(Float32)\npublic func atan(x: Float32): Float32\nFunction: Calculates the value of the arctangent function of a single-precision floating-point number.\n\nParameter:\n\nx: Float32—Incoming single-precision floating-point number.\nReturn value:\n\nFloat32 - Returns the arctangent function value of the incoming parameter in radians.\nExample:import std.math.atan\nmain() {\n    let n: Float32 = 0.0\n    let atan = atan(n)\n    println(atan)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc atanh(Float32)\npublic func atanh(x: Float32): Float32\nFunction: Calculate the value of the inverse hyperbolic tangent function of a single-precision floating-point number.\n\nParameter:\n\nx: Float32—Incoming single-precision floating-point number. -1.0 < x < 1.0。\nReturn value:\n\nFloat32—Returns the value of the inverse hyperbolic tangent function for the incoming parameter.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when parameter x is greater than or equal to 1.0 or less than or equal to -1.0.\nExample:import std.math.atanh\nmain() {\n    let n: Float32 = 0.0\n    let atanh = atanh(n)\n    println(atanh)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc cbrt(Float32)\npublic func cbrt(x: Float32): Float32\nFunction: Find the cube root of a single-precision floating-point number.\n\nParameter:\n\nx: Float32—Incoming single-precision floating-point number.\nReturn value:\n\nFloat32 - Returns the cube root of the incoming parameter.\nExample:import std.math.cbrt\nmain() {\n    let n: Float32 = -1000.0\n    let cbrt = cbrt(n)\n    println(cbrt)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc ceil(Float32)\npublic func ceil(x: Float32): Float32\nFunction: Find the rounded up value of a single-precision floating-point number.\n\nParameter:\n\nx: Float32—Incoming single-precision floating-point number.\nReturn value:\n\nFloat32 - Returns the rounded up value of the incoming parameter.\nExample:import std.math.ceil\nmain() {\n    let n: Float32 = 0.7\n    let ceil = ceil(n)\n    println(ceil)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc checkedAbs(Int64)\npublic func checkedAbs(x: Int64): Option<Int64>\nFunction: Find the absolute value of a 64-bit signed integer. If the input argument is the minimum value of a 64-bit signed integer, the function returns None; Otherwise, Some(abs(x)) is returned.\n\nParameter:\n\nx: Int64—A 64-bit signed integer passed in.\nReturn value:\n\nOption<Int64> - Option type that returns the absolute value of the incoming parameter.\nExample:import std.math.checkedAbs\n\nmain() {\n    let n: Int64 = -23\n    let checkedAbs = checkedAbs(n)\n    println(checkedAbs)\n}\n\n//Results:Some(23)"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc checkedAbs(Int8)\npublic func checkedAbs(x: Int8): Option<Int8>\nFunction: Find the absolute value of an 8-bit signed integer. If the input argument is the minimum value of an 8-bit signed integer, the function returns None; Otherwise, Some(abs(x)) is returned.\n\nParameter:\n\nx: Int8—An 8-bit signed integer passed in.\nReturn value:\n\nOption<Int8> - Option type that returns the absolute value of the incoming parameter.\nExample:import std.math.checkedAbs\n\nmain() {\n    let n: Int8 = -23\n    let checkedAbs = checkedAbs(n)\n    println(checkedAbs)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc clamp(Float16, Float16, Float16)\npublic func clamp(v: Float16, min: Float16, max: Float16): Float16\nFunction: Find the number of range intervals for floating-point numbers. If the floating-point number is in the range, the floating-point number is returned; If this floating-point number is less than this range range, the minimum value of the range interval is returned; If the floating-point number is greater than this range, the maximum value of the range interval is returned; If it is NaN, NaN is returned.\n\nParameter:\n\nv: Float16 - Pass in a floating-point number.\nmin: Float16—The minimum value specified.\nmax: Float16—The maximum value specified.\nReturn value:\n\nFloat16 - Returns v if v is between min and max; If v is less than or equal to min, min is returned; If v is greater than or equal to max, max is returned; If it is NaN, NaN is returned.\nExample:import std.math.clamp\nmain() {\n    let n: Float16 = -23.0\n    let clamp = clamp(n, -100.0, 100.0)\n    println(clamp)\n}\n//Results:-23.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc clamp(Float32, Float32, Float32)\npublic func clamp(v: Float32, min: Float32, max: Float32): Float32\nFunction: Find the number of range intervals for floating-point numbers. If the floating-point number is in the range, the floating-point number is returned; If this floating-point number is less than this range range, the minimum value of the range interval is returned; If the floating-point number is greater than this range, the maximum value of the range interval is returned; If it is NaN, NaN is returned.\n\nParameter:\n\nv: Float32 - Pass in a floating-point number.\nmin: Float32—The minimum value specified.\nmax: Float32—The maximum value specified.\nReturn value:\n\nFloat32 - Returns v if v is between min and max; If v is less than or equal to min, min is returned; If v is greater than or equal to max, max is returned; If it is NaN, NaN is returned.\nExample:import std.math.clamp\n\nmain() {\n    let n: Float32 = -23.0\n    let clamp = clamp(n, -100.0, 100.0)\n    println(clamp)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc cos(Float64)\npublic func cos(x: Float64): Float64\nFunction: Calculate the cosine function value of a double floating-point number.\n\nParameter:\n\nx: Float64 - Incoming double-precision floating-point number in radians.\nReturn value:\n\nFloat64—Returns the value of the cosine function for the incoming parameter.\nExample:import std.math.cos\nmain() {\n    let n: Float64 = 3.14159265\n    let cos = cos(n)\n    println(cos)\n}\n//Results:-1.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc cosh(Float32)\npublic func cosh(x: Float32): Float32\nFunction: Calculates the value of the hyperbolic cosine function of a single-precision floating-point number.\n\nParameter:\n\nx: Float32—Incoming single-precision floating-point number.\nReturn value:\n\nFloat32—Returns the value of the hyperbolic cosine function for the incoming parameter.\nExample:import std.math.cosh\nmain() {\n    let n: Float32 = 0.0\n    let cosh = cosh(n)\n    println(cosh)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc countOne(Int32)\npublic func countOne(x: Int32): Int8\nFunction: Find the number of 1s in the binary expression of a 32-bit integer.\n\nParameter:\n\nx: Int32—A 32-bit signed integer passed in.\nReturn value:\n\nInt8 - Returns the number of bits of 1 in the binary expression of the incoming parameter.\nExample:import std.math.countOne\nmain() {\n    let n: Int32 = 15\n    let countOne = countOne(n)\n    println(countOne)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc countOne(UInt32)\npublic func countOne(x: UInt32): Int8\nFunction: Find the number of bits of 1 in a binary expression of a 32-bit unsigned integer.\n\nParameter:\n\nx: UInt32 - 32-bit unsigned integer passed in.\nReturn value:\n\nInt8 - Returns the number of bits of 1 in the binary expression of the incoming parameter.\nExample:import std.math.countOne\n\nmain() {\n    let n: UInt32 = 15\n    let countOne = countOne(n)\n    println(countOne)\n}\n//Results:4"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc erf(Float32)\npublic func erf(x: Float32): Float32\nFunction: Find the error value of a single-precision floating-point number. \nParameter:\nx: Float32—Incoming single-precision floating-point number.\nReturn value:\n\nFloat32—Returns the error value of the single-precision floating-point number of the incoming parameter.\nExample:import std.math.erf\n\nmain() {\n    let n: Float32 = 5.0\n    let erf = erf(n)\n    println(erf)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc exp(Float64)\npublic func exp(x: Float64): Float64\nFunction: Find the power of x of the natural constant e.\n\nParameter:\n\nx: Float64—Incoming double-precision floating-point number exponent.\nReturn value:\n\nFloat64 - Returns the x-power of the natural constant e.\nExample:import std.math.exp\n\n\nmain() {\n    let n: Float64 = 1.0\n    let exp = exp(n)\n    println(exp)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc exp2(Float32)\npublic func exp2(x: Float32): Float32\nFunction: Find 2 to the power of x.\n\nParameter:\n\nx: Float32—Incoming single-precision floating-point index.\nReturn value:\n\nFloat32 - Returns 2 to the power of x.\nExample:import std.math.exp2\nmain() {\n    let n: Float32 = 10.0\n    let exp2 = exp2(n)\n    println(exp2)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc floor(Float16)\npublic func floor(x: Float16): Float16\nFunction: Rounding down the floating-point number.\n\nParameter:\n\nx: Float16 - Incoming half-precision floating-point number that needs to be rounded down.\nReturn value:\n\nFloat16 - Returns the rounded down value of the incoming floating-point number.\nExample:import std.math.floor\n\n\nmain() {\n    let n: Float16 = 10.5\n    let floor = floor(n)\n    println(floor)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nGamma Func(Float16)\npublic func gamma(x: Float16): Float16\nFunction: Find the gamma function value of a floating-point number, which is a generalization of the concept of factorial on real numbers.\n\nParameter:\n\nx: Float16 - Half-precision floating-point numbers that need to be used to find gamma function values.\nReturn value:\n\nFloat16—Returns the value of the gamma function passed in to the floating-point number.\nExample:import std.math.gamma\nmain() {\n    let n: Float16 = -1.1\n    let gamma = gamma(n)\n    println(gamma)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc gamma(Float64)\npublic func gamma(x: Float64): Float64\nFunction: Find the gamma function value of a floating-point number, which is a generalization of the concept of factorial on real numbers.\n\nParameter:\n\nx: Float64 - The incoming double-precision floating-point number that needs to be calculated for the gamma function value.\nReturn value:\n\nFloat64—Returns the value of the gamma function passed in for the floating-point number.\nExample:import std.math.gamma\n\n\nmain() {\n    let n: Float64 = -1.1\n    let gamma = gamma(n)\n    println(gamma)\n}\n\n//Results:9.714806"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc gcd(Int32, Int32)\npublic func gcd(x: Int32, y: Int32): Int32\nFunction: Find the greatest common divisor of two 32-bit signed integers.\n\nParameter:\n\nx: Int32 - The first integer that needs to be used to calculate the greatest common divisor.\ny: Int32 - The second integer that needs to be used to calculate the greatest common divisor.\nReturn value:\n\nInt32—Returns the greatest common divisor of two integers.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when both parameters are the minimum value of a signed integer, or when one parameter is the minimum value of a signed integer and the other parameter is 0.\nExample:import std.math.gcd\nmain() {\n    let x: Int32 = 15\n    let y: Int32 = 9\n    let gcd = gcd(x, y)\n    println(gcd)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc gcd(Int8, Int8)\npublic func gcd(x: Int8, y: Int8): Int8\nFunction: Find the greatest common divisor of two 8-bit signed integers.\n\nParameter:\n\nx: Int8 - The first integer passed in to calculate the greatest common divisor.\ny: Int8 - The second integer that needs to be used to calculate the greatest common divisor.\nReturn value:\n\nInt8 - Returns the greatest common divisor of two integers.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when both parameters are the minimum value of a signed integer, or when one parameter is the minimum value of a signed integer and the other parameter is 0.\nExample:import std.math.gcd\nmain() {\n    let x: Int8 = 15\n    let y: Int8= 9\n    let gcd = gcd(x, y)\n    println(gcd)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc gcd(UInt32, UInt32)\npublic func gcd(x: UInt32, y: UInt32): UInt32\nFunction: Find the greatest common divisor of two 32-bit unsigned integers.\n\nParameter:\n\nx: UInt32 - The first integer that needs to be passed in to calculate the greatest common divisor.\ny: UInt32 - The second integer that needs to be used to calculate the greatest common divisor.\nReturn value:\n\nUInt32 - Returns the greatest common divisor of two integers.\nExample:import std.math.gcd\nmain() {\n    let x: UInt32 = 15\n    let y: UInt32 = 9\n    let gcd = gcd(x, y)\n    println(gcd)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc gcd(UInt8, UInt8)\npublic func gcd(x: UInt8, y: UInt8): UInt8\nFunction: Find the greatest common divisor of two 8-bit unsigned integers.\n\nParameter:\n\nx: UInt8 - The first integer that needs to be used to calculate the greatest common divisor.\ny: UInt8 - the second integer that needs to be passed in to calculate the greatest common divisor.\nReturn value:\n\nUInt8 - Returns the greatest common divisor of two integers.\nExample:import std.math.gcd\nmain() {\n    let x: UInt8 = 15\n    let y: UInt8= 9\n    let gcd = gcd(x, y)\n    println(gcd)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc lcm(Int64, Int64)\npublic func lcm(x: Int64, y: Int64): Int64\nFunction: Find the smallest non-negative common multiple of two 64-bit signed integers, and return 0 when the input argument has 0.\n\nParameter:\n\nx: Int64—The first integer passed in that needs to be computed to a least common multiple.\ny: Int64 - The second integer that needs to be computed to the least common multiple.\nReturn value:\n\nInt64 - Returns the smallest non-negative common multiple of two integers, and returns 0 when the input argument has 0.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the return value exceeds the maximum value of a 64-bit signed integer.\nExample:import std.math.lcm\nmain() {\n    let x: Int64 = 15\n    let y: Int64 = 9\n    let lcm = lcm(x, y)\n    println(lcm)\n}\n\n//Results:45"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc lcm(UInt16, UInt16)\npublic func lcm(x: UInt16, y: UInt16): UInt16\nFunction: Find the smallest non-negative common multiple of two 16-bit unsigned integers, and return 0 when the input argument has 0.\n\nParameter:\n\nx: UInt16 - The first integer that needs to be computed to the least common multiple of the incoming value.\ny: UInt16 - The second integer that needs to be computed to the least common multiple is passed in.\nReturn value:\n\nUInt16 - Returns the smallest non-negative common multiple of two integers, and returns 0 when the input argument has 0.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the return value exceeds the maximum value of a 16-bit unsigned integer.\nExample:import std.math.lcm\nmain() {\n    let x: UInt16 = 15\n    let y: UInt16 = 9\n    let lcm = lcm(x, y)\n    println(lcm)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc leadingZeros(Int16)\npublic func leadingZeros(x: Int16): Int8\nFunction: Find the number of consecutive digits of 0 in the binary expression of a 16-bit signed integer, counting from the highest digit. If the highest bit is not 0, 0 is returned.\n\nParameter:\n\nx: Int16 - An integer with a leading 0 needs to be found.\nReturn value:\n\nInt8—Returns the number of digits leading 0.\nExample:import std.math.leadingZeros\nmain() {\n    let x: Int16 = 512\n    let leadingZeros = leadingZeros(x)\n    println(leadingZeros)\n}\n//Results:6"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc leadingZeros(UInt16)\npublic func leadingZeros(x: UInt16): Int8\nFunction: Find the number of consecutive digits of 0 in the binary expression of 16-bit unsigned integers, starting from the highest digit. If the highest bit is not 0, 0 is returned.\n\nParameter:\n\nx: UInt16 - An integer with a leading 0 needs to be retrieved.\nReturn value:\n\nInt8—Returns the number of digits leading 0.\nExample:import std.math.leadingZeros\nmain() {\n    let x: UInt16 = 512\n    let leadingZeros = leadingZeros(x)\n    println(leadingZeros)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc log(Float16)\npublic func log(x: Float16): Float16\nFunction: Find the logarithm of x with e as the base.\n\nParameter:\n\nx: Float16 - Exact number.\nReturn value:\n\nFloat16—Returns the logarithm of x with e as the base.\nillustrate\nThe return value can be used in the following scenarios:\n\nIf the incoming x is less than 0 or NaN, NaN is returned.\nIf x is equal to 0, -inf is returned.\nIf x is an INF is passed, an INF is returned.\nExample:import std.math.log\nmain() {\n    let x: Float16 = 2.718282\n    let log = log(x)\n    println(log)\n}\n\n//Results:1.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc log10(Float16)\npublic func log10(x: Float16): Float16\nFunction: Find the logarithm of x with a base of 10.\n\nParameter:\n\nx: Float16 - Exact number.\nReturn value:\n\nFloat16 - Returns the logarithm of x with a base of 10.\nillustrate\nThe return value can be used in the following scenarios:\n\nIf the incoming x is less than 0 or NaN, NaN is returned.\nIf x is equal to 0, -inf is returned.\nIf x is an INF is passed, an INF is returned.\nExample:import std.math.log10\nmain() {\n    let x: Float16 = 1000.0\n    let log10 = log10(x)\n    println(log10)\n}\n\n//Results:3.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc log10(Float32)\npublic func log10(x: Float32): Float32\nFunction: Find the logarithm of x with a base of 10.\n\nParameter:\n\nx: Float32 - True number.\nReturn value:\n\nFloat32 - Returns the logarithm of x with a base of 10.\nillustrate\nThe return value can be used in the following scenarios:\n\nIf the incoming x is less than 0 or NaN, NaN is returned.\nIf x is equal to 0, -inf is returned.\nIf x is an INF is passed, an INF is returned.\nExample:import std.math.log10\n\n\nmain() {\n    let x: Float32 = 1000.0\n    let log10 = log10(x)\n    println(log10)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc log2(Float64)\npublic func log2(x: Float64): Float64\nFunction: Find the logarithm of x with 2 as the base.\n\nParameter:\n\nx: Float64 - Exact number.\nReturn value:\n\nFloat64 - Returns the logarithm of x with a base of 2.\nillustrate\nThe return value can be used in the following scenarios:\n\nIf the incoming x is less than 0 or NaN, NaN is returned.\nIf x is equal to 0, -inf is returned.\nIf x is an INF is passed, an INF is returned.\nExample:import std.math.log2\n\nmain() {\n    let x: Float64 = 1024.0\n    let log2 = log2(x)\n    println(log2)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc logBase(Float64, Float64)\npublic func logBase(x: Float64, base: Float64): Float64\nFunction: Find the logarithm of base x.\n\nParameter:\n\nx: Float64 - True number. True numbers need to be greater than 0.\nbase: Float64 - base. The base needs to be greater than 0 and cannot be 1.\nReturn value:\n\nFloat64—Returns the logarithm of base x.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the true number or base is not positive, or when the base number is 1.\nExample:import std.math.logBase\nmain() {\n    let x: Float64 = 1024.0\n    let base: Float64 = 2.0\n    let logBase = logBase(x, base)\n    println(logBase)\n}\n\n//Results:10.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc max(Float16, Float16)\npublic func max(a: Float16, b: Float16): Float16\nFunction: Find the maximum value of two numbers. If the input argument has NaN, NaN is returned.\n\nParameter:\n\na: Float16 - The first number that needs to be compared in size.\nb: Float16 - The second number that needs to be compared in size.\nReturn value:\n\nFloat16 - Returns the maximum of two numbers. If the input argument has NaN, NaN is returned.\nExample:import std.math.max\nmain() {\n    let a: Float16 = 1.0\n    let b: Float16 = 2.0\n    let max = max(a, b)\n    println(max)\n}\n//Results:2.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc max(Int32, Int32)\npublic func max(a: Int32, b: Int32): Int32\nFunction: Find the maximum value of two numbers.\n\nParameter:\n\na: Int32 - The first number of sizes needs to be compared.\nb: Int32 - The second number that needs to be compared in size.\nReturn value:\n\nInt32—Returns the maximum of two numbers.\nExample:import std.math.max\nmain() {\n    let a: Int32 = -1\n    let b: Int32 = 2\n    let max = max(a, b)\n    println(max)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc max(UInt16, UInt16)\npublic func max(a: UInt16, b: UInt16): UInt16\nFunction: Find the maximum value of two numbers.\n\nParameter:\n\na: UInt16 - The first number of sizes needs to be compared.\nb: UInt16 - The second number that needs to be compared in size.\nReturn value:\n\nUInt16 - Returns the maximum of two numbers.\nExample:import std.math.max\nmain() {\n    let a: UInt16 = 1\n    let b: UInt16 = 2\n    let max = max(a, b)\n    println(max)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc maxNaN(Float16, Float16)\npublic func maxNaN(a: Float16, b: Float16): Float16\nFunction: Find the maximum value of two numbers. maxNaN only supports floating-point numbers, and returns NaN if the input parameter has NaN.\n\nParameter:\n\na: Float16 - The first number that needs to be compared in size.\nb: Float16 - The second number that needs to be compared in size.\nReturn value:\n\nFloat16 - Returns the maximum of two numbers. If the input argument has NaN, NaN is returned.\nExample:import std.math.maxNaN\nmain() {\n    let a: Float16 = 1.0\n    let b: Float16 = 2.0\n    let maxNaN = maxNaN(a, b)\n    println(maxNaN)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\n\nfunc min(Float32, Float32)\npublic func min(a: Float32, b: Float32): Float32\nFunction: Find the minimum value of two numbers. If the input argument has NaN, NaN is returned.\n\nParameter:\n\na: Float32 - The first number of sizes needs to be compared.\nb: Float32 - The second number that needs to be compared in size.\nReturn value:\n\nFloat32 - Returns the minimum value of two numbers. If the input argument has NaN, NaN is returned.\nExample:import std.math.min\nmain() {\n    let a: Float32 = 1.0\n    let b: Float32 = 2.0\n    let min = min(a, b)\n    println(min)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc min(Int32, Int32)\npublic func min(a: Int32, b: Int32): Int32\nFunction: Find the minimum value of two numbers.\n\nParameter:\n\na: Int32 - The first number of sizes needs to be compared.\nb: Int32 - The first number of sizes needs to be compared.\nReturn value:\n\nInt32 - Returns the minimum of two numbers.\nExample:import std.math.min\nmain() {\n    let a: Int32 = -1\n    let b: Int32 = 2\n    let min = min(a, b)\n    println(min)\n}\n//Results:-1"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc min(Int64, Int64)\npublic func min(a: Int64, b: Int64): Int64\nFunction: Find the minimum value of two numbers.\n\nParameter:\n\na: Int64 - The first number of the size needs to be compared.\nb: Int64 - The first number of sizes needs to be compared.\nReturn value:\n\nInt64—Returns the minimum of two numbers.\nExample:import std.math.min\n\nmain() {\n    let a: Int64 = -1\n    let b: Int64 = 2\n    let min = min(a, b)\n    println(min)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc min(UInt16, UInt16)\npublic func min(a: UInt16, b: UInt16): UInt16\nFunction: Find the minimum value of two numbers.\n\nParameter:\n\na: UInt16 - The first number of sizes needs to be compared.\nb: UInt16 - The first number of sizes needs to be compared.\nReturn value:\n\nUInt16 - Returns the minimum of two numbers.\nExample:import std.math.min\n\nmain() {\n    let a: UInt16 = 1\n    let b: UInt16 = 2\n    let min = min(a, b)\n    println(min)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc min(UInt64, UInt64)\npublic func min(a: UInt64, b: UInt64): UInt64\nFunction: Find the minimum value of two numbers.\n\nParameter:\n\na: UInt64 - The first number of sizes needs to be compared.\nb: UInt64 - The first number of sizes needs to be compared.\nReturn value:\n\nUInt64 - Returns the minimum of two numbers.\nExample:import std.math.min\nmain() {\n    let a: UInt64 = 1\n    let b: UInt64 = 2\n    let min = min(a, b)\n    println(min)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc minNaN(Float32, Float32)\npublic func minNaN(a: Float32, b: Float32): Float32\nFunction: Find the minimum value of two numbers. minNaN only supports floating-point numbers, and if the input parameter has NaN, NaN is returned.\n\nParameter:\n\na: Float32 - The first number of sizes needs to be compared.\nb: Float32 - The second number that needs to be compared in size.\nReturn value:\n\nFloat32 - Returns the minimum value of two numbers. If the input argument has NaN, NaN is returned.\nExample:import std.math.minNaN\n\nmain() {\n    let a: Float32 = 1.0\n    let b: Float32 = 2.0\n    let minNaN = minNaN(a, b)\n    println(minNaN)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc pow(Float32, Float32)\npublic func pow(base: Float32, exponent: Float32): Float32\nFunction: Find the exponent power of the floating-point base.\n\nParameter:\n\nbase: Float32 - base number\nexponent: Float32 - index number\nReturn value:\n\nFloat32—Returns the exponent power of the incoming floating-point base. If the value does not exist, NAN is returned.\nExample:import std.math.pow\n\n\nmain() {\n    let base: Float32 = -1.0\n    let exponent: Float32 = 0.5\n    let pow = pow(base, exponent)\n    println(pow)\n}\n//Results:nan"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc pow(Float64, Float64)\npublic func pow(base: Float64, exponent: Float64): Float64\nFunction: Find the exponent power of the floating-point base.\n\nParameter:\n\nbase: Float64 - Base number.\nexponent: Float64 - Exponent.\nReturn value:\n\nFloat64—Returns the exponent power of the base of the floating-point number passed in. If the value does not exist, NAN is returned.\nExample:import std.math.pow\n\nmain() {\n    let base: Float64 = -1.0\n    let exponent: Float64 = 0.5\n    let pow = pow(base, exponent)\n    println(pow)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc reverse(UInt16)\npublic func reverse(x: UInt16): UInt16\nFunction: Find the number of unsigned integers after bitwise reversal.\n\nParameter:\n\nx: UInt16 - An unsigned integer that needs to be reversed.\nReturn value:\n\nUInt16 - Returns the unsigned number after the reversal.\nExample:import std.math.reverse\n\nmain() {\n    let n: UInt16 = 0x8000\n    let reverse = reverse(n)\n    println(reverse)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc rotate(Int16, Int8)\npublic func rotate(num: Int16, d: Int8): Int16\nFunction: Find the result of bitwise rotation of an integer.\n\nParameter:\n\nnum: Int16 - Pass in an integer.\nd: Int8 - Number of rotational digits, negative numbers shifted to the right, positive numbers shifted to the left.\nReturn value:\n\nInt16—Returns the rotated integer.\nExample:import std.math.rotate\n\nmain() {\n    let n: Int16 = 1\n    let rotate = rotate(n, 2)\n    println(rotate)\n}\n\n//Results:4"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc rotate(UInt16, Int8)\npublic func rotate(num: UInt16, d: Int8): UInt16\nFunction: Find the result of bitwise rotation of an integer.\n\nParameter:\n\nnum: UInt16 - Pass in an integer.\nd: Int8 - Number of rotational digits, negative numbers shifted to the right, positive numbers shifted to the left.\nReturn value:\n\nUInt16 - Returns an integer after rotation.\nExample:import std.math.rotate\n\n\nmain() {\n    let n: UInt16 = 1\n    let rotate = rotate(n, 2)\n    println(rotate)\n}\n//Results:4"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc rotate(UInt32, Int8)\npublic func rotate(num: UInt32, d: Int8): UInt32\nFunction: Find the result of bitwise rotation of an integer.\n\nParameter:\n\nnum: UInt32 - Pass in an integer.\nd: Int8 - Number of rotational digits, negative numbers shifted to the right, positive numbers shifted to the left.\nReturn value:\n\nUInt32 - Returns an integer after the rotation.\nExample:import std.math.rotate\n\n\nmain() {\n    let n: UInt32 = 1\n    let rotate = rotate(n, 2)\n    println(rotate)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc rotate(UInt64, Int8)\npublic func rotate(num: UInt64, d: Int8): UInt64\nFunction: Find the result of bitwise rotation of an integer.\n\nParameter:\n\nnum: UInt64 - Pass in an integer.\nd: Int8 - Number of rotational digits, negative numbers shifted to the right, positive numbers shifted to the left.\nReturn value:\n\nUInt64 - Returns a rotated integer.\nExample:import std.math.rotate\nmain() {\n    let n: UInt64 = 1\n    let rotate = rotate(n, 2)\n    println(rotate)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc rotate(UInt8, Int8)\npublic func rotate(num: UInt8, d: Int8): UInt8\nFunction: Find the result of bitwise rotation of an integer.\n\nParameter:\n\nnum: UInt8 - Pass in an integer.\nd: Int8 - Number of rotational digits, negative numbers shifted to the right, positive numbers shifted to the left.\nReturn value:\n\nUInt8 - Returns a rotated integer.\nExample:import std.math.rotate\n\n\nmain() {\n    let n: UInt8 = 1\n    let rotate = rotate(n, 2)\n    println(rotate)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc round(Float32)\npublic func round(x: Float32): Float32\nFunction: This function uses IEEE-754's nearest rounding rule to calculate the rounding value of floating-point numbers. If the floating-point number has two nearest integers, it is rounded to even.\n\nParameter:\n\nx: Float32 - The number of floats that need to be rounded up.\nReturn value:\n\nFloat32—Returns the rounding value of the floating-point number in the direction of the nearest integer. If the floating-point number has two nearest integers, the value rounded to the even number is returned.\nExample:import std.math.round\n\nmain() {\n    let n: Float32 = 1.5\n    let round = round(n)\n    println(round)\n}\n//Results:2.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc sin(Float32)\npublic func sin(x: Float32): Float32\nFunction: Calculates the value of the sinusoidal function of a single-precision floating-point number.\n\nParameter:\n\nx: Float32—The number of single-precision floating-point points incoming in radians as an input parameter.\nReturn value:\n\nFloat32—Returns the value of the sinusoidal function of the incoming parameter.\nExample:import std.math.sin\n\nmain() {\n    let n: Float32 = 3.1415926/2.0\n    let sin = sin(n)\n    println(sin)\n}\n\n//Results:1.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc sinh(Float64)\npublic func sinh(x: Float64): Float64\nFunction: Calculates the value of the hyperbolic sinusoidal function of a double-precision floating-point number.\n\nParameter:\n\nx: Float64—Incoming double-precision floating-point number.\nReturn value:\n\nFloat64—Returns the value of the hyperbolic sine function for the incoming parameter.\nExample:import std.math.sinh\n\nmain() {\n    let n: Float64 = 0.0\n    let sinh = sinh(n)\n    println(sinh)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc sqrt(Float16)\npublic func sqrt(x: Float16): Float16\nFunction: Find the arithmetic square root of a floating-point number.\n\nParameter:\n\nx: Float16 - The floating-point number that needs to be calculated as the square root of the arithmetic. x needs to be greater than or equal to 0.\nReturn value:\n\nFloat16 - Returns the arithmetic square root of the incoming floating-point number.\nAbnormal:\n\nIllegalArgumentException - An exception is thrown when the argument is negative.\nExample:import std.math.sqrt\nmain() {\n    let n: Float16 = 16.0\n    let sqrt = sqrt(n)\n    println(sqrt)\n}\n\n//Results:4.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc tan(Float16)\npublic func tan(x: Float16): Float16\nFunction: Calculates the tangent function value of a half-precision floating-point number.\n\nParameter:\n\nx: Float16—The incoming half-precision floating-point number, the input parameter in radians.\nReturn value:\n\nFloat16—Returns the tangent function value of the incoming parameter.\nExample:import std.math.tan\n\nmain() {\n    let n: Float16 = 0.0\n    let tan = tan(n)\n    println(tan)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc tanh(Float32)\npublic func tanh(x: Float32): Float32\nFunction: Calculates the value of the hyperbolic tangent function for single-precision floating-point numbers.\n\nParameter:\n\nx: Float32—Incoming single-precision floating-point number.\nReturn value:\n\nFloat32—Returns the value of the hyperbolic tangent function for the incoming parameter.\nExample:import std.math.tanh\n\n\nmain() {\n    let n: Float32 = 0.0\n    let tanh = tanh(n)\n    println(tanh)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc throwIllegalArgumentException()\npublic func throwIllegalArgumentException(): Int64\nFunction: This function is used to throw an illegal parameter exception.\n\nReturn value:\n\nInt64 - return 0.\nAbnormal:\n\nIllegalArgumentException - Throws an exception when the function is called."}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trailingZeros(Int16)\npublic func trailingZeros(x: Int16): Int8\nFunction: Find the number of consecutive digits of 0 in the binary expression of a 16-bit signed integer, starting from the lowest bit. If the lowest bit is not 0, 0 is returned.\n\nParameter:\n\nx: Int16 - A post-0 integer is required.\nReturn value:\n\nInt8—The number of digits in the posterior 0.\nExample:import std.math.trailingZeros\n\n\nmain() {\n    let x: Int16 = 512\n    let trailingZeros = trailingZeros(x)\n    println(trailingZeros)\n}\n\n//Results:9"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trailingZeros(Int32)\npublic func trailingZeros(x: Int32): Int8\nFunction: Find the number of consecutive digits of 0 in the binary expression of a 32-bit signed integer, counting from the lowest bit. If the lowest bit is not 0, 0 is returned.\n\nParameter:\n\nx: Int32 - An integer with 0 to be found.\nReturn value:\n\nInt8—The number of digits in the posterior 0.\nExample:import std.math.trailingZeros\n\nmain() {\n    let x: Int32 = 512\n    let trailingZeros = trailingZeros(x)\n    println(trailingZeros)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trailingZeros(Int8)\npublic func trailingZeros(x: Int8): Int8\nFunction: Find the number of consecutive digits of 0 in the binary expression of a 16-bit signed integer, starting from the lowest bit. If the lowest bit is not 0, 0 is returned.\n\nParameter:\n\nx: Int8 - An integer with a postposition of 0 is required.\nReturn value:\n\nInt8—The number of digits in the posterior 0.\nExample:import std.math.trailingZeros\n\n\nmain() {\n    let x: Int8 = 64\n    let trailingZeros = trailingZeros(x)\n    println(trailingZeros)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trailingZeros(UInt16)\npublic func trailingZeros(x: UInt16): Int8\nFunction: Find the number of consecutive digits of 0 in the binary expression of 16-bit unsigned integers, counting from the lowest bit. If the lowest bit is not 0, 0 is returned.\n\nParameter:\n\nx: UInt16 - Requires an integer with a post-0.\nReturn value:\n\nInt8—The number of digits in the posterior 0.\nExample:import std.math.trailingZeros\n\n\nmain() {\n    let x: UInt16 = 512\n    let trailingZeros = trailingZeros(x)\n    println(trailingZeros)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trailingZeros(UInt32)\npublic func trailingZeros(x: UInt32): Int8\nFunction: Find the number of consecutive digits of 0 in the binary expression of a 32-bit unsigned integer, counting from the lowest bit. If the lowest bit is not 0, 0 is returned.\n\nParameter:\n\nx: UInt32 - Requires an integer with a postpadded 0.\nReturn value:\n\nInt8—The number of digits in the posterior 0.\nExample:import std.math.trailingZeros\n\nmain() {\n    let x: UInt32 = 512\n    let trailingZeros = trailingZeros(x)\n    println(trailingZeros)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trailingZeros(UInt64)\npublic func trailingZeros(x: UInt64): Int8\nFunction: Find the number of consecutive digits of 0 in the binary expression of a 64-bit unsigned integer, counting from the lowest bit. If the lowest bit is not 0, 0 is returned.\n\nParameter:\n\nx: UInt64 - An integer with a postpadded 0 needs to be quelled.\nReturn value:\n\nInt8—The number of digits in the posterior 0.\nExample:import std.math.trailingZeros\n\nmain() {\n    let x: UInt64 = 512\n    let trailingZeros = trailingZeros(x)\n    println(trailingZeros)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trailingZeros(UInt8)\npublic func trailingZeros(x: UInt8): Int8\nFunction: Find the number of consecutive digits of 0 in the binary expression of 8-bit unsigned integers, counting from the lowest digit. If the lowest bit is not 0, 0 is returned.\n\nParameter:\n\nx: UInt8 - An integer with 0 to be retrieved.\nReturn value:\n\nInt8—The number of digits in the posterior 0.\nExample:import std.math.trailingZeros\n\n\nmain() {\n    let x: UInt8 = 64\n    let trailingZeros = trailingZeros(x)\n    println(trailingZeros)\n}\n\n//Results:6"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trunc(Float16)\npublic func trunc(x: Float16): Float16\nFunction: Find the truncated integer value of the floating-point number.\n\nParameter:\n\nx: Float16 - The number of floats that need to be truncated to round up.\nReturn value:\n\nFloat16—Returns the truncated integer value of the incoming floating-point number.\nExample:import std.math.trunc\n\nmain() {\n    let x: Float16 = 64.555566\n    let trunc = trunc(x)\n    println(trunc)\n}\n//Results:64.000000"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trunc(Float32)\npublic func trunc(x: Float32): Float32\nFunction: Find the truncated integer value of the floating-point number.\n\nParameter:\n\nx: Float32 - The number of floats that need to be truncated to round up.\nReturn value:\n\nFloat32—Returns the truncated integer value of the incoming floating-point number.\nExample:import std.math.trunc\n\nmain() {\n    let x: Float32 = 64.555566\n    let trunc = trunc(x)\n    println(trunc)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\nfunc trunc(Float64)\npublic func trunc(x: Float64): Float64\nFunction: Find the truncated integer value of the floating-point number.\n\nParameter:\n\nx: Float64 - The number of floats that need to be truncated to round up.\nReturn value:\n\nFloat64—Returns the truncated integer value of the incoming floating-point number.\nExample:import std.math.trunc\n\n\nmain() {\n    let x: Float64 = 64.555566\n    let trunc = trunc(x)\n    println(trunc)\n}"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\nextend Float16 <: MathExtension\nextend Float16 <: MathExtension\nFunction: Extend half-precision floating-point numbers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop E\n\npublic static prop E: Float16\nFunction: Obtain the natural constant of a half-precision floating-point number.\n\nType: Float16\n\nstatic prop Inf\n\npublic static prop Inf: Float16\nFunction: Get an infinite number of half-precision floating-point numbers.\n\nType: Float16\n\nstatic prop Max\n\npublic static prop Max: Float16\nFunction: Get the maximum value of a half-precision floating-point number.\n\nType: Float16\n\nstatic prop Min\n\npublic static prop Min: Float16\nFunction: Get the minimum value of half-precision floating-point numbers.\n\nType: Float16\n\nstatic prop MinDenormal\n\npublic static prop MinDenormal: Float16\nFunction: Obtain the least subnormal number of half-precision floating-point numbers. The least positive sub-regular number is the smallest positive number expressed in the IEEE double-precision format.\n\nType: Float16\n\nstatic prop MinNormal\n\npublic static prop MinNormal: Float16\nFunction: Gets the minimum normal number of half-precision floating-point numbers.\n\nType: Float16\n\nstatic prop NaN\n\npublic static prop NaN: Float16\nFunction: Get a non-number of half-precision floating-point numbers.\n\nType: Float16\n\nstatic prop PI\n\npublic static prop PI: Float16\nFunction: Get the pi constant of a half-precision floating-point number.\n\nType: Float16\n\nfunc isInf()\n\npublic func isInf(): Bool\nFunction: Determine whether a float16 is an infinite value.\n\nReturn value:\n\nBool - Returns true if the value of Float16 is positive or negative infinity; Otherwise, false is returned.\nfunc isNaN()\n\npublic func isNaN(): Bool\nFunction: Determine whether a floating-point number Float16 is a non-numeric value.\n\nReturn value:\n\nBool - Returns true if the value of Float16 is non-numeric; Otherwise, false is returned.\nfunc isNormal()\n\npublic func isNormal(): Bool\nFunction: Determine whether a floating-point number Float16 is a regular value.\n\nReturn value:\n\nBool - Returns true if the value of Float16 is a normal floating-point number; Otherwise, false is returned."}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend Float32 <: MathExtension\nextend Float32 <: MathExtension\nFunction: Extend single-precision floating-point numbers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop E\n\npublic static prop E: Float32\nFunction: Obtain the natural constant of a single-precision floating-point number.\n\nType: Float32\n\nstatic prop Inf\n\npublic static prop Inf: Float32\nFunction: Get an infinite number of single-precision floating-point numbers.\n\nType: Float32\n\nstatic prop Max\n\npublic static prop Max: Float32\nFunction: Get the maximum value of a single-precision floating-point number.\n\nType: Float32\n\nstatic prop Min\n\npublic static prop Min: Float32\nFunction: Get the minimum value of a single-precision floating-point number.\n\nType: Float32\n\nstatic prop MinDenormal\n\npublic static prop MinDenormal: Float32\nFunction: Obtain the minimum subnormal number of a single-precision floating-point number.\n\nType: Float32\n\nstatic prop MinNormal\n\npublic static prop MinNormal: Float32\nFunction: Obtain the minimum regular number of a single-precision floating-point number.\n\nType: Float32\n\nstatic prop NaN\n\npublic static prop NaN: Float32\nFunction: Get non-numbers of single-precision floating-point numbers.\n\nType: Float32\n\nstatic prop PI\n\npublic static prop PI: Float32\nFunction: Get the pi constant of a single-precision floating-point number.\n\nType: Float32\n\nfunc isInf()\n\npublic func isInf(): Bool\nFunction: Determine whether a float32 is an infinite value.\n\nReturn value:\n\nBool - Returns true if the value of Float32 is positive or negative infinity; Otherwise, false is returned.\nfunc isNaN()\n\npublic func isNaN(): Bool\nFunction: Determine whether a float32 is a non-numeric value.\n\nReturn value:\n\nBool - Returns true if the value of Float32 is non-numeric; Otherwise, false is returned.\nfunc isNormal()\n\npublic func isNormal(): Bool\nFunction: Determine whether a float32 is a regular value.\n\nReturn value:\n\nBool - Returns true if the value of Float32 is a normal floating-point number; Otherwise, false is returned."}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend Float64 <: MathExtension\nextend Float64 <: MathExtension\nFunction: Extend double-precision floating-point numbers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop E\n\npublic static prop E: Float64\nFunction: Get the natural constant of a double-precision floating-point number.\n\nType: Float64\n\nstatic prop Inf\n\npublic static prop Inf: Float64\nFunction: Get an infinite number of double-precision floating-point numbers.\n\nType: Float64\n\nstatic prop Max\n\npublic static prop Max: Float64\nFunction: Get the maximum value of the double-precision floating-point number.\n\nType: Float64\n\nstatic prop Min\n\npublic static prop Min: Float64\nFunction: Get the minimum value of the double-precision floating-point number.\n\nType: Float64\n\nstatic prop MinDenormal\n\npublic static prop MinDenormal: Float64\nFunction: Obtain the minimum subnormal number of a double-precision floating-point number.\n\nType: Float64\n\nstatic prop MinNormal\n\npublic static prop MinNormal: Float64\nFunction: Obtain the minimum regular number of a double-precision floating-point number.\n\nType: Float64\n\nstatic prop NaN\n\npublic static prop NaN: Float64\nFunction: Get the non-number of double-precision floating-point numbers.\n\nType: Float64\n\nstatic prop PI\n\npublic static prop PI: Float64\nFunction: Get the pi constant of a double-precision floating-point number.\n\nType: Float64\n\nfunc isInf()\n\npublic func isInf(): Bool\nFunction: Determine whether a float64 is an infinite value.\n\nReturn value:\n\nBool - Returns true if the value of Float64 is positive or negative infinity; Otherwise, false is returned.\nfunc isNaN()\n\npublic func isNaN(): Bool\nFunction: Determine whether a float64 is a non-numeric value.\n\nReturn value:\n\nBool - Returns true if the value of Float64 is non-numeric; Otherwise, false is returned.\nfunc isNormal()\n\npublic func isNormal(): Bool\nFunction: Determine whether a float64 is a regular value.\n\nReturn value:\n\nBool - Returns true if the value of Float64 is a normal floating-point number; Otherwise, false is returned."}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend Int16 <: MathExtension\nextend Int16 <: MathExtension\nFunction: Extend 16-bit signed integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: Int16\nFunction: Get the maximum value of a 16-bit signed integer.\n\nType: Int16\n\nstatic prop Min\n\npublic static prop Min: Int16\nFunction: Get the minimum value of a 16-bit signed integer.\n\nType: Int16"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend Int32 <: MathExtension\nextend Int32 <: MathExtension\nFunction: Extend 32-bit signed integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: Int32\nFunction: Get the maximum value of a 32-bit signed integer.\n\nType: Int32\n\nstatic prop Min\n\npublic static prop Min: Int32\nFunction: Get the minimum value of a 32-bit signed integer.\n\nType: Int32"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend Int64 <: MathExtension\nextend Int64 <: MathExtension\nFeature: Extend 64-bit signed integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: Int64\nFunction: Get the maximum value of a 64-bit signed integer.\n\nType: Int64\n\nstatic prop Min\n\npublic static prop Min: Int64\nFunction: Get the minimum value of a 64-bit signed integer.\n\nType: Int64"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend Int8 <: MathExtension\nextend Int8 <: MathExtension\nFunction: Extend 8-bit signed integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: Int8\nFunction: Get the maximum value of an 8-bit signed integer.\n\nType: Int8\n\nstatic prop Min\n\npublic static prop Min: Int8\nFunction: Get the minimum value of an 8-bit signed integer.\n\nType: Int8"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend IntNative <: MathExtension\nextend IntNative <: MathExtension\nFunction: Extend the platform-related signed integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: IntNative\nFunction: Get the maximum value of a signed integer related to the platform.\n\nType: IntNative\n\nstatic prop Min\n\npublic static prop Min: IntNative\nFunction: Get the minimum value of the platform-related signed integer.\n\nType: IntNative"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend UInt16 <: MathExtension\nextend UInt16 <: MathExtension\nFeature: Extend 16-bit unsigned integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: UInt16\nFunction: Get the maximum value of a 16-bit unsigned integer.\n\nType: UInt16\n\nstatic prop Min\n\npublic static prop Min: UInt16\nFunction: Get the minimum value of a 16-bit unsigned integer.\n\nType: UInt16"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend UInt32 <: MathExtension\nextend UInt32 <: MathExtension\nFunction: Extend 32-bit unsigned integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: UInt32\nFunction: Get the maximum value of a 32-bit unsigned integer.\n\nType: UInt32\n\nstatic prop Min\n\npublic static prop Min: UInt32\nFunction: Get the minimum value of a 32-bit unsigned integer.\n\nType: UInt32"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend UInt64 <: MathExtension\nextend UInt64 <: MathExtension\nFunction: Extend 64-bit unsigned integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: UInt64\nFunction: Get the maximum value of a 64-bit unsigned integer.\n\nType: UInt64\n\nstatic prop Min\n\npublic static prop Min: UInt64\nFunction: Get the minimum value of a 64-bit unsigned integer.\n\nType: UInt64"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend UInt8 <: MathExtension\nextend UInt8 <: MathExtension\nFunction: Extend 8-bit unsigned integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: UInt8\nFunction: Get the maximum value of an 8-bit unsigned integer.\n\nType: UInt8\n\nstatic prop Min\n\npublic static prop Min: UInt8\nFunction: Get the minimum value of an 8-bit unsigned integer.\n\nType: UInt8"}
{"text": "Cangjie programming language syntax:\nstd.math package\ninterface MathExtension\npublic interface MathExtension\nFunction: Auxiliary interface for exporting props, auxiliary export of Max, Min attributes, additional export of NaN, Inf, PI, E, MinDenormal, MinNormal properties and isInf, isNaN, isNormal interfaces. The auxiliary interface is empty internally.\n\nextend UIntNative <: MathExtension\nextend UIntNative <: MathExtension\nFunction: Extend platform-related unsigned integers to support some mathematical constants.\n\nParent Type:\n\nMathExtension\nstatic prop Max\n\npublic static prop Max: UIntNative\nFunction: Get the maximum value of the platform-related unsigned integer.\n\nType: UIntNative\n\nstatic prop Min\n\npublic static prop Min: UIntNative\nFunction: Get the minimum value of the platform-related unsigned integer.\n\nType: UIntNative"}
{"text": "Cangjie programming language syntax:\nstd.math package\nenum RoundingMode\npublic enum RoundingMode {\n    | CEILING\n    | DOWN\n    | FLOOR\n    | HALF_EVEN\n    | HALF_UP\n    | UP\n}\nThe rounding rules enumerate class, which contains a total of 6 rounding rules. In addition to the 5 rounding rules that include IEEE 754 floating-point regulations, the more commonly used \"rounding\" rounding rules are available.\n\nDecimal numbers\tUP\tDOWN\tCEILING\tFLOOR\tHALF_UP\tHALF_EVEN\n7.5\t8\t7\t8\t7\t8\t8\n4.5\t5\t4\t5\t4\t5\t4\n-1.1\t-2\t-1\t-1\t-2\t-1\t-1\n-4.5\t-5\t-4\t-4\t-5\t-5\t-4\n-7.5\t-8\t-7\t-7\t-8\t-8\t-8\nCEILING\nCEILING\nFunction: Rounding in the direction of positive infinity.\n\nDOWN\nDOWN\nFunction: Round in the direction closer to zero.\n\nFLOOR\nFLOOR\nFunction: Round in the direction of negative infinity.\n\nHALF_EVEN\nHALF_EVEN\nFunction: Rounding up to five, also known as \"banker rounding\".\n\nHALF_UP\nHALF_UP\nFunction: Rounding.\n\nUP\nUP\nFunction: Rounds away from zero."}
{"text": "Cangjie programming language syntax:\nstd.math package\nExamples of basic math operations:import std.math.clamp\nimport std.math.gcd\nimport std.math.lcm\nimport std.math.rotate\n\n//Range truncation example\nfunc clampTest() {\n    let min: Float16 = -0.123\n    let max: Float16 = 0.123\n    let v: Float16 = 0.121\n    let c = clamp(v, min, max)\n    println(\"${c==v}\")\n    let min2: Float16 = -0.999\n    let max2: Float16 = 10.123\n    let v2: Float16 = 11.121\n    let c2 = clamp(v2, min2, max2)\n    println(\"${c2==max2}\")\n    let min3: Float16 = -0.999\n    let max3: Float16 = 10.123\n    let v3: Float16 = -1.121\n    let c3 = clamp(v3, min3, max3)\n    println(\"${c3==min3}\")\n}\n\n//Find the greatest common divisor of two numbers\nfunc gcdTest() {\n    let c2 = gcd(0, -60)\n    println(\"c2=${c2}\")\n    let c4 = gcd(-33, 27)\n    println(\"c4=${c4}\")\n}\n\n\n//Find the least common multiple of two numbers\nfunc lcmTest() {\n    let a: Int8 = lcm(Int8(-3), Int8(5))\n    println(\"a=${a}\")\n}\n\n//Integer is flipped back and forth according to a certain bit of binary\nfunc rotateTest() {\n    let a: Int8 = rotate(Int8(92), Int8(4))\n    println(\"a=${a}\")\n\n\n    let b: Int32 = rotate(Int32(1), Int8(4))\n    println(\"b=${b}\")\n}\n\n\nmain(): Unit {\n    println(\"/***********************    clampTest    **********************/\")\n    clampTest()\n    println(\"/***********************    gcdTest    ************************/\")\n    gcdTest()\n    println(\"/***********************    lcmTest    ************************/\")\n    lcmTest()\n    println(\"/***********************    rotateTest    *********************/\")\n    rotateTest()\n}"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\n\nFunction introduction\nThe math.numeric package provides extensibility beyond the expressible range of the base type.\n\nFor example:\n\nSupport for large integers (BigInt);\nSupport high-precision decimal number (Decimal) type;\nProvide common mathematical computing capabilities, including high-precision operation rules.\nList of APIs\nfunction\nfunction name\tfunction\nabs(BigInt)\tFind the absolute value of a BigInt.\nabs(Decimal)\tFind the absolute value of a Decimal.\nsqrt(BigInt)\tFind the arithmetic square root of BigInt, rounded down.\nsqrt(Decimal)\tFind the arithmetic square root of Decimal. If the result is an infinitesimal scenario, IEEE 754-2019 decimal128 is used to round the result by default.\ngcd(BigInt, BigInt)\tFind the greatest common divisor of two BigInts. Always returns a non-negative number (equivalent to the greatest common divisor of the absolute value).\nlcm(BigInt, BigInt)\tFind the least common multiple of two BigInts. Except for 0, which returns 0 when the input argument has 0, a positive number is always returned (equivalent to the least common multiple of the absolute value).\nmax(BigInt, BigInt)\tCalculates and returns the larger of the two BigInts.\nmin(BigInt, BigInt)\tCalculates and returns the smaller of the two BigInts.\ncountOne(BigInt)\tCalculates and returns the number of 1s in the binary complement of the input parameter BigInt.\nround(Decimal, RoundingMode)\tCalculates the rounding value for Decimal, rounding to adjacent integers based on how they are rounded.\n\nenumeration\nenumeration\tfunction\nOverflowStrategy\tThe overflow policy enumeration class contains a total of 3 overflow policies. When the BigInt type and Decimal type are converted to an integer type, different overflow handling policies are allowed.\n\nStructure\nStructure\tfunction\nBigInt\tBigInt is defined as a signed integer of arbitrary precision (binary). Cangjie's struct BigInt is used for arithmetic calculations of arbitrary-precision signed integers, type conversions, and more.\nDecimal\tDecimal is used to represent a signed decimal number of arbitrary precision. Allows the operation process to specify the context, specify the result precision, and the rounding rules. It provides the ability to convert basic types (Int, UInt, String, Float, etc.) to BigInt types, supports the query of basic properties of Decimal objects, supports basic mathematical operations, and provides basic capabilities such as object comparison, hash, and string printing."}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\n\nfunc abs(BigInt)\npublic func abs(i: BigInt): BigInt\nFunction: Find the absolute value of a BigInt.\n\nParameter:\n\ni: BigInt—BigInt that needs to be computed for absolute values.\nReturn value:\n\nBigInt - Returns the absolute value of the input parameter BigInt.\nExample:import std.math.numeric.*\n\n\nmain() {\n    let n: BigInt = BigInt(-23)\n    let abs = abs(n)\n    println(abs)\n}\n\n//Results:23"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\n\nfunc abs(Decimal)\npublic func abs(d: Decimal): Decimal\nFunction: Find the absolute value of a Decimal.\n\nParameter:\n\nd: Decimal—Decimal, which needs to be calculated as an absolute value.\nReturn value:\n\nDecimal - Returns the absolute value of the input parameter Decimal.\nExample:import std.math.numeric.*\n\nmain() {\n    let d: Decimal = Decimal(\"-1.23\")\n    let abs = abs(d)\n    println(abs)\n}\n//Results:1.23"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nfunc countOne(BigInt)\npublic func countOne(i: BigInt): Int64\nFunction: Calculates and returns the number of 1s in the binary complement of the input parameter BigInt.\n\nParameter:\n\ni: BigInt - A BigInt that needs to be counted as the number of 1s in the complement of the binary.\nReturn value:\n\nInt64 - Returns the number of 1s in the binary complement of the input parameter BigInt.\nExample:import std.math.numeric.*\n\nmain() {\n    let i: BigInt = BigInt(255)\n    let countOne = countOne(i)\n    println(countOne)\n}\n//Results:8"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nfunc gcd(BigInt, BigInt)\npublic func gcd(i1: BigInt, i2: BigInt): BigInt\nFunction: Find the greatest common divisor of two BigInts. Always returns a non-negative number (equivalent to the greatest common divisor of the absolute value).\n\nParameter:\n\ni1: BigInt - the first input argument to be calculated for the greatest common divisor.\ni2: BigInt - The second input argument that needs to be calculated for the greatest common divisor.\nReturn value:\n\nBigInt - Returns the greatest common divisor of i1 and i2, always returning a non-negative number.\nExample:import std.math.numeric.*\n\nmain() {\n    let i1: BigInt = BigInt(-36)\n    let i2: BigInt = BigInt(48)\n    let gcd = gcd(i1, i2)\n    println(gcd)\n}\n//Results:12"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nfunc lcm(BigInt, BigInt)\npublic func lcm(i1: BigInt, i2: BigInt): BigInt\nFunction: Find the least common multiple of two BigInts. Except for 0, which returns 0 when the input argument has 0, a positive number is always returned (equivalent to the least common multiple of the absolute value).\n\nParameter:\n\ni1: BigInt - the first input argument that needs to be calculated for the least common multiple.\ni2: BigInt - The second input argument that needs to be calculated for the least common multiple.\nReturn value:\n\nBigInt—Returns the least common multiple of i1 and i2, 0 when the input argument has 0, and a positive number in the rest of the cases.\nExample:import std.math.numeric.*\n\nmain() {\n    let i1: BigInt = BigInt(-36)\n    let i2: BigInt = BigInt(48)\n    let lcm = lcm(i1, i2)\n    println(lcm)\n}\n//Results:144"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nfunc max(BigInt, BigInt)\npublic func max(i1: BigInt, i2: BigInt): BigInt\nFunction: Calculates and returns the larger of the two BigInts.\n\nParameter:\n\ni1: BigInt - The BigInt that needs to be compared.\ni2: BigInt - The BigInt that needs to be compared.\nReturn value:\n\nBigInt - Returns the larger BigInt in i1,i2.\nExample:import std.math.numeric.*\n\nmain() {\n    let i1: BigInt = BigInt(-36)\n    let i2: BigInt = BigInt(48)\n    let max = max(i1, i2)\n    println(max)\n}\n//Results:48"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nfunc min(BigInt, BigInt)\npublic func min(i1: BigInt, i2: BigInt): BigInt\nFunction: Calculates and returns the smaller of the two BigInts.\n\nParameter:\n\ni1: BigInt - The BigInt that needs to be compared.\ni2: BigInt - The BigInt that needs to be compared.\nReturn value:\n\nBigInt - Returns the smaller BigInt in i1,i2.\nExample:import std.math.numeric.*\n\nmain() {\n    let i1: BigInt = BigInt(-36)\n    let i2: BigInt = BigInt(48)\n    let min = min(i1, i2)\n    println(min)\n}\n\n//Results:-36"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nfunc round(Decimal, RoundingMode)\npublic func round(d: Decimal, roundingMode!: RoundingMode = HALF_EVEN): Decimal\nFunction: Calculates the rounding value of Decimal, rounding to adjacent integers according to the rounding method.\n\nParameter:\n\nd: Decimal—Decimal, which needs to calculate the rounding value.\nroundingMode!: RoundingMode - 舍入规则。\nReturn value:\n\nDecimal - A new Decimal object resulting from the rounding operation.\nAbnormal:\n\nOverflowException—This exception is thrown when the scale value of the rounding operation result is overflowing."}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nfunc sqrt(BigInt)\npublic func sqrt(i: BigInt): BigInt\nFunction: Find the arithmetic square root of BigInt, round down.\n\nParameter:\n\ni: BigInt - BigInt which needs to be computed as the square root of the arithmetic, and the input argument needs to be non-negative.\nReturn value:\n\nBigInt—Returns the arithmetic square root of the input parameter BigInt, rounded down.\nAbnormal:\n\nIllegalArgumentException - This exception is thrown if the input argument is negative.import std.math.numeric.*\n\nmain() {\n    let n: BigInt = BigInt(23)\n    let sqrt = sqrt(n)\n    println(sqrt)\n}\n//Results:4"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nfunc sqrt(Decimal)\npublic func sqrt(d: Decimal): Decimal\nFunction: Find the arithmetic square root of Decimal. If the result is an infinitesimal scenario, IEEE 754-2019 decimal128 is used to round the result by default.\n\nParameter:\n\nd: Decimal - Decimal, which needs to be calculated as the square root of the arithmetic, and the arguments need to be non-negative.\nReturn value:\n\nDecimal - Returns the arithmetic square root of the input parameter Decimal.\nAbnormal:\n\nIllegalArgumentException - This exception is thrown if the input argument is negative.\nOverflowException - This exception is thrown when the scale value of the result of the calculated square root operation is overflowing.import std.math.numeric.*\n\nmain() {\n    let n: Decimal = Decimal(\"36\")\n    let sqrt = sqrt(n)\n    println(sqrt)\n}\n//Results:6"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nExample of basic BigInt math operations\nHere's an example of how to initialize a BigInt object with different constructors and perform basic math:import std.math.numeric.*\n\nmain() {\n    let int1: BigInt = BigInt(\"123456789\")\n    let int2: BigInt = BigInt(\"987654321\")\n\n\n    println(\"${int1} + ${int2} = ${int1 + int2}\")\n    println(\"${int1} - ${int2} = ${int1 - int2}\")\n    println(\"${int1} * ${int2} = ${int1 * int2}\")\n    println(\"${int1} / ${int2} = ${int1 / int2}\")\n    let (quo, mod) = int1.divAndMod(int2)\n    println(\"${int1} / ${int2} = ${quo} .. ${mod}\")\n\n\n    return 0\n}\n\n//Results:\n123456789 + 987654321 = 1111111110\n123456789 - 987654321 = -864197532\n123456789 * 987654321 = 121932631112635269\n123456789 / 987654321 = 0\n123456789 / 987654321 = 0 .. 123456789"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nExample of a BigInt basic property.\nHere's an example of initializing a BigInt object and querying the object's basic properties:import std.math.numeric.*\n\n\nmain() {\n    let int = BigInt(\"-123456\")\n    println(\"BigInt: ${int}\")\n    println(\"BigInt sign: ${int.sign}\")\n    println(\"BigInt bitLen: ${int.bitLen}\")\n    return 0\n}\n\n//Results:\n\nBigInt: -123456\nBigInt sign: -1\nBigInt bitLen: 18"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nBigInt size comparison example.\nHere's an example of initializing multiple BigInt objects and comparing their sizes:import std.math.numeric.*\n\n\nmain() {\n    let int1 = BigInt(\"123456789\")\n    let int2 = BigInt(\"987654321\")\n    println(\"${int1} > ${int2} = ${int1 > int2}\")\n    println(\"${int1} < ${int2} = ${int1 < int2}\")\n    println(\"${int1} == ${int2} = ${int1 == int2}\")\n    println(\"${int1} != ${int2} = ${int1 != int2}\")\n    println(\"${int1} <= ${int2} = ${int1 <= int2}\")\n    println(\"${int1} >= ${int2} = ${int1 >= int2}\")\n    println(\"${int1}.compare(${int2}) = ${int1.compare(int2)}\")\n    return 0\n}\n//Results:\n\n123456789 > 987654321 = false\n123456789 < 987654321 = true\n123456789 == 987654321 = false\n123456789 != 987654321 = true\n123456789 <= 987654321 = true\n123456789 >= 987654321 = false\n123456789.compare(987654321) = Ordering.LT"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nExamples of basic Decimal math operations:\nHere's an example of how to initialize a Decimal object with different constructors and perform basic math:import std.math.*\nimport std.math.numeric.*\n\n\nmain() {\n    let decimal1: Decimal = Decimal(\"12345.6789\")\n    let decimal2: Decimal = Decimal(BigInt(\"987654321\"), 6)\n    println(\"${decimal1} + ${decimal2} = ${decimal1 + decimal2}\")\n    println(\"${decimal1} - ${decimal2} = ${decimal1 - decimal2}\")\n    println(\"${decimal1} * ${decimal2} = ${decimal1 * decimal2}\")\n    println(\"${decimal1} / ${decimal2} = ${decimal1 / decimal2}\")\n    println(\"${decimal1} / ${decimal2} with precision 10 and rounding mode HALF_EVEN = ${decimal1.divWithPrecision(decimal2, 10, roundingMode: HALF_EVEN)}\")\n    let (quo, rem) = decimal1.divAndRem(decimal2)\n    println(\"${decimal1} / ${decimal2} = ${quo} .. ${rem}\")\n    return 0\n}\n\n//Results:\n\n12345.6789 + 987.654321 = 13333.333221\n12345.6789 - 987.654321 = 11358.024579\n12345.6789 * 987.654321 = 12193263.1112635269\n12345.6789 / 987.654321 = 12.49999988609375000142382812498220\n12345.6789 / 987.654321 with precision 10 and rounding mode HALF_EVEN = 12.49999989\n12345.6789 / 987.654321 = 12 .. 493.827048"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nExample of a Decimal base property.\nHere's an example of initializing a Decimal object and querying its basic properties:import std.math.*\nimport std.math.numeric.*\n\n\nmain() {\n    let decimalProperties = Decimal(\"-123456.7890123456789\")\n    println(\"decimal: ${decimalProperties}\")\n    println(\"decimal sign: ${decimalProperties.sign}\")\n    println(\"decimal scale: ${decimalProperties.scale}\")\n    println(\"decimal value: ${decimalProperties.value}\")\n    println(\"decimal precision: ${decimalProperties.precision}\")\n\n\n    //If you want to initialize a Decimal object with a specified precision and rounding method, you can use the following approach\n    let decimalProperties2 = Decimal(\"-123456.7890123456789\").roundWithPrecision(10, roundingMode: HALF_EVEN)\n    println(\"decimal2: ${decimalProperties2}\")\n    println(\"decimal2 sign: ${decimalProperties2.sign}\")\n    println(\"decimal2 scale: ${decimalProperties2.scale}\")\n    println(\"decimal2 value: ${decimalProperties2.value}\")\n    println(\"decimal2 precision: ${decimalProperties2.precision}\")\n\n\n    return 0\n}\n\n//Results:\n\ndecimal: -123456.7890123456789\ndecimal sign: -1\ndecimal scale: 13\ndecimal value: -1234567890123456789\ndecimal precision: 19\ndecimal2: -123456.7890\ndecimal2 sign: -1\ndecimal2 scale: 4\ndecimal2 value: -1234567890\ndecimal2 precision: 10"}
{"text": "Cangjie programming language syntax:\nstd.math.numeric package\nExample of a Decimal size comparison.\nHere's an example of initializing multiple Decimal objects and comparing their sizes:import std.math.*\nimport std.math.numeric.*\n\n\nmain() {\n    let decimal1 = Decimal(\"12345.6789\")\n    let decimal2 = Decimal(\"987.654321\")\n    println(\"${decimal1} > ${decimal2} = ${decimal1 > decimal2}\")\n    println(\"${decimal1} < ${decimal2} = ${decimal1 < decimal2}\")\n    println(\"${decimal1} == ${decimal2} = ${decimal1 == decimal2}\")\n    println(\"${decimal1} != ${decimal2} = ${decimal1 != decimal2}\")\n    println(\"${decimal1} <= ${decimal2} = ${decimal1 <= decimal2}\")\n    println(\"${decimal1} >= ${decimal2} = ${decimal1 >= decimal2}\")\n    println(\"${decimal1}.compare(${decimal2}) = ${decimal1.compare(decimal2)}\")\n    return 0\n}\n\nResults:\n\n12345.6789 > 987.654321 = true\n12345.6789 < 987.654321 = false\n12345.6789 == 987.654321 = false\n12345.6789 != 987.654321 = true\n12345.6789 <= 987.654321 = false\n12345.6789 >= 987.654321 = true\n12345.6789.compare(987.654321) = Ordering.GT"}
{"text": "Cangjie programming language syntax:\nstd.objectpool package\nFunction introduction\nThe objectpool package provides the ability to cache and reuse objects.\n\nIn object-oriented languages, the application and release of objects are generally complex and time-consuming, which is likely to become a performance bottleneck for applications. The same problem is faced with the application and release of Cangjie subjects. By caching and reusing objects, object pools reduce the application and release of objects, effectively improving program performance.\n\nThe ObjectPool class of this package implements the caching and reuse of objects of the specified type, calling the put method to put the used objects into the object pool cache, and calling the get method to take out the objects to be used from the object pool cache.\n\nIn addition, in order to reduce competition and further improve the efficiency of object access, ObjectPool is implemented to access objects in different arrays according to the id of the current Cangjie thread.\n\nnote\n1. Since ObjectPool is accessed according to the ID of the Cangjie thread in the implementation, it will be difficult to retrieve the stored objects when the storage and retrieval are distributed in different Cangjie threads. Therefore, this object pool should be used in scenarios where the storage and retrieval are evenly distributed across the Cangjie threads.\n2. Capacity reduction is not supported.\n\nClass name\tfunction\nObjectPool\tThis class provides a concurrency-safe object cache type that can store objects that have been allocated memory but are not used."}
{"text": "Cangjie programming language syntax:\nstd.os package\nFunction introduction\nThe OS package provides capabilities to obtain or manipulate information about the current process (such as process parameters, environment variables, directory information, etc.), register callback functions, and exit the current process.\n\nCurrently, Linux, macOS, Windows and HarmonyOS are supported.\n\nList of APIs\nfunction name\tfunction\tSupport Platforms\ncurrentDir()\tGet the current working directory.\tLinux、Windows、macOS、HarmonyOS\nenvVars()\tGet all environment variables.\tLinux、Windows、macOS、HarmonyOS\ngetArgs()\tReturns a list of command-line arguments, such as executing a.out ab cd ef in the command line, where a.out is the program name, and the returned list contains three elements, ab cd ef.\tLinux、Windows、macOS、HarmonyOS\ngetEnv(String)\tObtain the value of the environment variable with the specified name.\tLinux、Windows、macOS、HarmonyOS\nhomeDir()\tGet the home directory.\tLinux、Windows、macOS\nprocessorCount()\tGet the number of processors.\tLinux、Windows、macOS、HarmonyOS\nremoveEnv(String)\tRemove environment variables by specifying their names.\tLinux、Windows、macOS、HarmonyOS\nsetEnv(String, String)\tUsed to set a pair of environment variables.\tLinux、Windows、macOS、HarmonyOS\ntempDir()\tGet a temporary directory.\tLinux、Windows、macOS、HarmonyOS"}
{"text": "Cangjie programming language syntax:\nstd.os.posix package\nFunction introduction\nThe os.posix package is mainly adapted to the POSIX system interface.\n\nThis package provides multi-platform unified control capabilities, and currently supports Linux, macOS, Windows, and HarmonyOS platforms.\n\nList of APIs\nfunction name\tfunction\tSupport Platforms\nopen(String, Int32)\tOpen the file and return a new file descriptor for it, or -1 if it fails.\tLinux、Windows、macOS、HarmonyOS\nopen(String, Int32, UInt32)\tOpen the file and return a new file descriptor for it, or -1 if it fails.\tLinux、Windows、macOS、HarmonyOS\naccess(String, Int32)\tDetermines whether a file has a certain permission, and returns 0, otherwise -1.\tLinux、Windows、macOS、HarmonyOS\nchdir(String)\tChange the current working directory of the invoking process by specifying a path.\tLinux、Windows、macOS、HarmonyOS\nchmod(String, UInt32)\tModify file access permissions.\tLinux、Windows、macOS、HarmonyOS\nchown(String, UInt32, UInt32)\tModify the file owner and the group to which the file owner belongs.\tLinux、macOS、HarmonyOS\nclose(Int32)\tWhen you close the file, close will trigger the data to be written back to disk and free up the resources occupied by the file.\tLinux、Windows、macOS、HarmonyOS\ncreat(String, UInt32)\tCreate a file and return a file descriptor for it, or -1 if it fails.\tLinux、Windows、macOS、HarmonyOS\ndup(Int32)\tUsed to copy the file descriptor specified by the old fd parameter and return.\tLinux、Windows、macOS、HarmonyOS\ndup2(Int32, Int32)\tLets you copy the file descriptor specified by the oldfd parameter and return it to the newfd parameter.\tLinux、Windows、macOS、HarmonyOS\nfaccessat(Int32, String, Int32, Int32)\tTo determine whether the file corresponding to fd has a certain permission, it returns 0, otherwise it returns -1.\tLinux、macOS、HarmonyOS\nfchdir(Int32)\tChange the current working directory of the calling process by specifying a descriptor for the file path.\tLinux、macOS、HarmonyOS\nfchmod(Int32, UInt32)\tModify the file access permissions for the file descriptor.\tLinux、Windows、macOS、HarmonyOS\nfchmodat(Int32, String, UInt32, Int32)\tModify the file access permissions for the file descriptor.\tLinux、Windows、macOS、HarmonyOS\nfchown(Int32, UInt32, UInt32)\tModify the file owner and the group to which the file owner belongs to the FD.\tLinux、macOS、HarmonyOS\nfchownat(Int32, String, UInt32, UInt32, Int32)\tModify the file owner and the group to which the file descriptor belongs.\tLinux、macOS、HarmonyOS\ngetcwd()\tObtain the absolute path to the working directory of the current execution process.\tLinux、Windows、macOS、HarmonyOS\ngetgid()\tGet the user group ID.\tLinux、macOS、HarmonyOS\ngetgroups(Int32, CPointer<UInt32>)\tObtain the code of the group to which the current user belongs.\tLinux、macOS、HarmonyOS\ngethostname()\tGets the name of the host, which is typically the name of the host on the TCP/IP network.\tLinux、macOS、HarmonyOS\ngetlogin()\tGet the current login.\tLinux、macOS、HarmonyOS\ngetos()\tGet the information about the Linux system from the /proc/version file.\tLinux\ngetpgid(Int32)\tGets the PGID of the process specified by the pid, and if the pid is zero, returns the process ID of the calling process.\tLinux、macOS、HarmonyOS\ngetpgrp()\tGets the parent process ID of the calling process.\tLinux、macOS、HarmonyOS\ngetpid()\tObtain the process ID (PID) of the calling process.\tLinux、Windows、macOS、HarmonyOS\ngetppid()\tGets the parent process ID of the calling process.\tLinux、macOS、HarmonyOS\ngetuid()\tGet the real user ID of the calling process.\tLinux、macOS、HarmonyOS\nisBlk(String)\tChecks that the incoming object is a block device and returns a Boolean type.\tLinux、Windows、macOS、HarmonyOS\nisChr(String)\tChecks whether the incoming object is a character device and returns a Boolean type.\tLinux、Windows、macOS、HarmonyOS\nisDir(String)\tChecks whether the incoming object is a folder and returns a Boolean type.\tLinux、Windows、macOS、HarmonyOS\nisFIFO(String)\tCheck if the incoming object is a FIFO file, returning a Boolean type.\tLinux、macOS、HarmonyOS\nisLnk(String)\tCheck whether the incoming object is a soft link and return a Boolean type.\tLinux、macOS、HarmonyOS\nisReg(String)\tCheck whether the incoming object is a normal file and return the Boolean type.\tLinux、Windows、macOS、HarmonyOS\nisSock(String)\tChecks whether the incoming object is a socket file and returns a Boolean type.\tLinux、macOS、HarmonyOS\nisType(String, UInt32)\tCheck whether the file is in the specified mode.\tLinux、macOS、HarmonyOS\nisatty(Int32)\tIt is used to test whether the file descriptor refers to the terminal, and returns true if successful, otherwise it returns false.\tLinux、Windows、macOS、HarmonyOS\nkill(Int32, Int32)\tA system call can be used to send any signal to any process group or process.\tLinux、macOS、HarmonyOS\nkillpg(Int32, Int32)\tSend a signal sig to the process group pgrp, and if pgrp is 0, killpg() sends the signal to the process group that called the process.\tLinux、macOS、HarmonyOS\nlchown(String, UInt32, UInt32)\tModify the file link itself owner and the group to which the owner belongs.\tLinux、macOS\nlink(String, String)\tCreate links to existing files, a file can have multiple directory entries that point to its i-node.\tLinux、macOS、HarmonyOS\nlinkat(Int32, String, Int32, String, Int32)\tCreates a file link relative to the directory file descriptor.\tLinux、macOS、HarmonyOS\nlseek(Int32, Int64, Int32)\tWhen a file is read or written, the read or write location increases accordingly.\tLinux、Windows、macOS、HarmonyOS\nnice(Int32)\tChange the priority of the current thread.\tLinux、macOS、HarmonyOS\nopen64(String, Int32)\tOpen the file and return a new file descriptor for it, or -1 if it fails.\tLinux、HarmonyOS\nopen64(String, Int32, UInt32)\tOpen the file and return a new file descriptor for it, or -1 if it fails.\tLinux、HarmonyOS\nopenat(Int32, String, Int32)\tOpen the file and return a new file descriptor for it, or -1 if it fails.\tLinux、macOS、HarmonyOS\nopenat(Int32, String, Int32, UInt32)\tOpen the file and return a new file descriptor for it, or -1 if it fails.\tLinux、macOS、HarmonyOS\nopenat64(Int32, String, Int32)\tOpen the file and return a new file descriptor for it, or -1 if it fails.\tLinux、macOS、HarmonyOS\nopenat64(Int32, String, Int32, UInt32)\tOpen the file and return a new file descriptor for it, or -1 if it fails.\tLinux、macOS、HarmonyOS\npread(Int32, CPointer<UInt8>, UIntNative, Int32)\tTransfer the nbytes of the file that fd points to to the memory that the buffer points to.\tLinux、macOS、HarmonyOS\npwrite(Int32, CPointer<UInt8>, UIntNative, Int32)\tWrites the nbytes in memory in memory pointed by the buffer from the specified offset to the file that the fd points to.\tLinux、macOS、HarmonyOS\nread(Int32, CPointer<UInt8>, UIntNative)\tTransfer the nbytes of the file that fd points to to the memory that the buffer points to.\tLinux、Windows、macOS、HarmonyOS\nremove(String)\tDelete a file or directory.\tLinux、Windows、macOS、HarmonyOS\nrename(String, String)\tRename the file and move the directory where the file is located if needed.\tLinux、Windows、macOS、HarmonyOS\nrenameat(Int32, String, Int32, String)\tRename the file and move the directory where the file is located if needed.\tLinux、macOS、HarmonyOS\nsetgid(UInt32)\tSetting a valid group ID for the calling process requires the appropriate permissions.\tLinux、macOS\nsethostname(String)\tSet the hostname, which can only be called by the superuser.\tLinux、macOS\nsetpgid(Int32, Int32)\tThis function sets the group ID specified by the parameter pid to the group ID specified by the parameter pgrp.\tLinux、macOS、HarmonyOS\nsetpgrp()\tSet the group ID to which the current process belongs to the process ID of the current process, which is equivalent to calling setpgid(0, 0).\tLinux、macOS、HarmonyOS\nsetuid(UInt32)\tSet a valid user ID for the calling process, which requires the appropriate permissions.\tLinux、macOS\nsymlink(String, String)\tCreate a file named symPath that links to the path specified.\tLinux、macOS、HarmonyOS\nsymlinkat(String, Int32, String)\tCreate a file named symPath that links to the path and fd specified.\tLinux、macOS、HarmonyOS\nttyname(Int32)\tReturns the terminal name.\tLinux、Windows、macOS、HarmonyOS\numask(UInt32)\tSet the permission mask.\tLinux、Windows、macOS、HarmonyOS\nunlink(String)\tDelete the file from the file system.\tLinux、macOS、HarmonyOS\nunlinkat(Int32, String, Int32)\tDelete the file from the file system.\tLinux、macOS、HarmonyOS\nwrite(Int32, CPointer<UInt8>, UIntNative)\tWrite the nbytes in memory that the buffer points to to the file that fd points to.\tLinux、Windows、macOS、HarmonyOS"}
{"text": "Cangjie programming language syntax:\nstd.os.posix package\nHere's an example of what to do with the contents of a file.\n\nHere's the code:import std.os.posix.*\n\n\nmain(): Int64 {\n    var fd = `open`(\"textcase.txt\", O_RDWR | O_APPEND | O_CREAT, S_IRWXU)\n    println(\"fd ==> ${fd}\")\n    close(fd)\n    var fd2 = `open`(\"textcase.txt\", O_RDWR)\n    var len = lseek(fd2, 0, SEEK_END)\n    println(\"len ==> ${len}\")\n    close(fd2)\n    var str1 = unsafe{LibC.mallocCString(\" \")}\n    var buf = str1.getChars()\n    var fd3 = `open`(\"textcase.txt\", O_RDWR)\n    var readNum = unsafe { read(fd3, buf, 2) }\n    unsafe{ LibC.free(str1)}\n    println(\"readNum ==> ${readNum}\")\n    close(fd3)\n    var str2 = unsafe{LibC.mallocCString(\"123456\")}\n    var buf2 = str2.getChars()\n\n\n    var fd4 = `open`(\"textcase.txt\", O_RDWR)\n    var fd5 = dup(fd4)\n    var writeNum = unsafe { write(fd5, buf2, UIntNative(str2.size())) }\n    unsafe { LibC.free(str2)}\n    println(\"writeNum ==> ${writeNum}\")\n    close(fd4)\n    return 0\n}\n\n//The possible results of the run are as follows:\n\nfd ==> 3\nlen ==> 6\nreadNum ==> 2\nwriteNum ==> 6"}
{"text": "Cangjie programming language syntax:\nstd.os.posix package\nThe following is an example of what to do with file information, and the following example does not support the Windows platform.\n\nHere's the code:import std.os.posix.*\n\n\nmain(): Int64 {\n    var result1: Bool = isType(\"/notdirs\", S_IFDIR)\n    println(\"result ==> ${result1}\")\n    var result2: Bool = isDir(\"/dev\")\n    println(\"result ==> ${result2}\")\n    var result3 = access(\"./oscfg.cfg\", F_OK)\n    println(\"result ==> ${result3}\")\n    var result4 = chmod(\"oscfg.cfg\", UInt32(S_IXUSR))\n    println(\"result ==> ${result4}\")\n    return 0\n}\n\n//The result is as follows:\n\nresult ==> false\nresult ==> true\nresult ==> -1\nresult ==> -1"}
{"text": "Cangjie programming language syntax:\nstd.os.posix package\n\nThe following is an example of getting various types of system information, and the following examples are not supported on the Windows platform.\n\nHere's the code:import std.os.posix.*\n\n\nmain(): Int64 {\n    /* 系统名称相关 */\n    var os_info = getos()\n    println(\"os info ==> ${os_info}\")\n    var hostname = gethostname()\n    println(\"hostname ==> ${hostname}\")\n    var logname: String = getlogin()\n    println(\"logname ==> ${logname}\")\n\n\n    /* 程序运行路径相关函数 */\n    var changePath = \"/\"\n    var chdir_result = chdir(changePath)\n    println(\"chdir_result ==> ${chdir_result}\")\n    var cwd_path: String = getcwd()\n    println(\"cwd_path ==> ${cwd_path}\")\n\n\n    /* 系统 id 相关函数 getpgid */\n    var arr: CString = unsafe { LibC.mallocCString(\" \") }\n    var a: CPointer<UInt8> = arr.getChars()\n    var cp: CPointer<UInt32> = CPointer<UInt32>(a)\n    var getg = unsafe{ getgroups(0, cp)}\n    var s: String = \" \"\n    for (_ in 0..getg) {\n        s = s + \"\\0\"\n    }\n    println(getg)\n    var local: UInt32 = 0\n    for (temp in 0..getg) {\n        unsafe { local = cp.read(Int64(temp)) }\n        println(\"getgroups ==> ${local.toString()}\")\n    }\n    unsafe { LibC.free(arr)}\n    return 0\n}\n\n//The result is as follows (the return result may be different depending on the system):\n\nLinux version 4.15.0-159-generic (buildd@lgw01-amd64-055) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #167-Ubuntu SMP Tue Sep 21 08:55:05 UTC 2021\nhostname ==> e124e6e0fe0f\nlogname ==> root\nchdir_result ==> 0\ncwd_path ==> /\n1\ngetgroups ==> 1309868064"}
{"text": "Cangjie programming language syntax:\nstd.os.posix package\n\nHere's an example of a process-related action, and the following examples don't support the Windows platform.\n\nHere's the code:import std.os.posix.*\n\n\nmain(): Int64 {\n    var result = nice(200)\n    print(\"${result}\")\n    var result1 = kill(0, SIGCHLD)\n    println(result1)\n    var result2 = killpg(0, SIGURG)\n    println(\"result ==> ${result2}\")\n    if (isatty(0) && isatty(1) && isatty(2)) {\n            print(\"true01 \")\n        } else {\n            print(\"false01 \")\n        }\n        if (isatty(-23) || isatty(4) || isatty(455) || isatty(43332)) {\n            print(\"true02 \")\n        } else {\n            println(\"false02\")\n        }\n        return 0\n}\n\n//The result is as follows:\n\n190\nresult ==> 0\ntrue01 false02"}
{"text": "Cangjie programming language syntax:\nstd.os.process package\n\nFunction introduction\nThe os.process package mainly provides process operation interfaces, including process creation, standard stream acquisition, process waiting, process information query, etc.\n\nThis package provides multi-platform unified control capabilities, and currently supports Linux, macOS, Windows, and HarmonyOS platforms.\n\nList of APIs\nClass name\tfunction\nCurrentProcess\tThis class is the current process class, inherits from the Process class, and provides functions related to the operation of the current process.\nProcess\tThis class is a process class that provides functions related to process operations.\nSubProcess\tThis class is a subprocess class, which inherits from the Process class and provides functions related to the operation of the subprocess."}
{"text": "Cangjie programming language syntax:\nstd.os.process package\nOperations related to the current process.\nThe following is an example of what to do for the current process, and the following example does not support the Windows platform.\n\nHere's the code:import std.os.process.*\n\nmain(): Int64 {\n    let curProcess = Process.current\n    println(curProcess.pid)\n    println(curProcess.name)\n    println(curProcess.command)\n    println(curProcess.arguments.toString())\n    println(curProcess.commandLine.toString())\n    println(curProcess.workingDirectory.toString())\n    curProcess.atExit(printText)\n    curProcess.exit(0)\n    return 0\n}\n\nfunc printText(): Unit {\n    println(\"hello cangjie!\")\n}\n\n//The result may be as follows (in the output result, main is the command name of the current process, and the current process will exit after the callback is executed):\n\n75590\n./main\n./main\n[]\n[./main]\n/root/code/Process/test\nhello cangjie!"}
{"text": "Cangjie programming language syntax:\nstd.os.process package\nDelete the subprocess executable after the Windows platform subprocess ends.\nThe following is an example of what happens after a Windows platform sub-process fails to delete a sub-process executable after it has ended.\n\nHere's the code:import std.os.process.*\nimport std.io.*\nimport std.fs.*\nimport std.time.*\nimport std.sync.*\n\n//Using commands related to the Windows platform as an example, the following use case requires the creation of an executable file named 'test. exe' in the current directory in advance\nmain(): Int64 {\n    Process.runOutput(\"cmd.exe\", \"/c\", \"test.exe\")\n    for (_ in 0..5) {\n        try {\n            File.delete(\".\\\\test.exe\")\n            break\n        } catch (e: FSException) {\n            if (e.message != \"Failed to recursive delete directory: \\\"Access is denied.\\\".\") {\n                throw e\n            }\n            sleep(Duration.millisecond * 5)\n        }\n    }\n    println(\"delete file success.\")\n    return 0\n}\n\n//The result might be as follows:\n\ndelete file success."}
{"text": "Cangjie programming language syntax:\nstd.os.process package\nArbitrary process-related operations.\nThe following is an example of what to do with any process, and the following example is not supported on the Windows platform.\n\nHere's the code:import std.os.process.*\nimport std.fs.*\n\n\nmain(): Int64 {\n    let echoProcess: SubProcess = Process.start(\"sleep\", \"10s\")\n    let ofProcess: Process = Process.of(echoProcess.pid)\n    println(ofProcess.pid)\n    println(ofProcess.name)\n    println(ofProcess.command)\n    println(ofProcess.arguments.toString())\n    println(ofProcess.commandLine.toString())\n    ofProcess.terminate(force: true)\n    return 0\n}\n\n//The result might be as follows:\n\n78980\nsleep\nsleep\n[10s]\n[sleep, 10s]"}
{"text": "Cangjie programming language syntax:\nstd.os.process package\nSubprocess-related operations.\nThe following is an example of a subprocess-related operation, and the following example does not support the Windows platform.\n\nHere's the code:import std.os.process.*\nimport std.io.*\nimport std.fs.*\n\n//Taking Linux platform related commands as an example, the following use cases require the creation of the \"/root/code/Process/test\" directory in advance\nmain(): Int64 {\n    let sleepProcess: SubProcess = Process.start(\"sleep\", \"10s\", workingDirectory: Path(\"/root/code/Process/test\"))\n    println(sleepProcess.pid)\n    println(sleepProcess.name)\n    println(sleepProcess.command)\n    println(sleepProcess.arguments.toString())\n    println(sleepProcess.commandLine.toString())\n    println(sleepProcess.workingDirectory.toString())\n    sleepProcess.terminate(force: true)\n    let rtnCode = sleepProcess.wait()\n    println(\"sleepProcess rtnCode: ${rtnCode}\")\n\n\n    let echoProcess: SubProcess = Process.start(\"echo\", \"hello cangjie!\", stdOut: ProcessRedirect.Pipe)\n    let strReader: StringReader<InputStream> = StringReader(echoProcess.stdOut)\n    println(strReader.readToEnd())\n    return 0\n}\n\n//The result might be as follows:\n\n45090\nsleep 10s\nsleep\n[10s]\n[sleep, 10s]\n/root/code/Process/test\nsleepProcess rtnCode: 9\nhello cangjie!"}
{"text": "Cangjie programming language syntax:\nstd.overflow package\nFunction introduction\nThe overflow package provides the ability to handle integer operations when they overflow.\n\nIn integer arithmetic, an overflow occurs when the result is greater than the maximum value of its type or less than the minimum value of its type. By default, an exception is thrown when an overflow occurs.\n\nThe overflow package provides four overflow handling strategies and defines the corresponding interfaces, which are listed as follows:\n\ntactics\tinterface\tdescription\nreturn Option\tCheckedOp\tWhen an integer operation overflows, None is returned.\nsaturate\tSaturatingOp\tWhen the calculation result is greater than the MAX value of the target type, the MAX value is returned; When the calculation result is less than the MIN value of the target type, the MIN value is returned.\nThrows an exception\tThrowingOp\tWhen an integer operation overflows, an exception is thrown.\nHigh-level truncation\tWrappingOp\tWhen an integer operation overflows, the high bits in the operation result that exceed the number of bits of the target type are truncated.\nThe overflow package provides implementations of these interfaces for all integer types by extension, and users can implement overflow interfaces for other types in the same way.\n\nList of APIs\ninterface\nThe name of the interface\tfunction\nCheckedOp\tWhen an integer operation overflows, None is returned.\nSaturatingOp\tWhen an integer operation overflows, saturation is processed.\nThrowingOp\tWhen an integer operation overflows, an exception is thrown.\nWrappingOp\tWhen an integer operation overflows, the high bits in the operation result that exceed the number of bits of the target type are truncated.\nException class\nClass name\tfunction\nOvershiftException\tAn exception thrown when the number of shifted digits exceeds the number of operands during a shift operation.\nUndershiftException\tAn exception thrown when the number of shifted bits is less than 0 during the shift operation."}
{"text": "Cangjie programming language syntax:\nstd.overflow package\nAn example of an option strategy is returned.\nHere's an example of an option policy that returns an attempt to square Int64.Max, and an overflow occurs, returning None.import std.overflow.*\nimport std.math.*\n\n\nmain() {\n    let a: Int64 = Int64.Max\n    println(a.checkedPow(UInt64(2)))\n}\n\n//The result is as follows:\nNone"}
{"text": "Cangjie programming language syntax:\nstd.overflow package\nAn example of a saturation strategy.\nHere's an example of a saturation strategy where UInt16.Max is tried to be multiplied by 16, and the result exceeds the maximum value of UInt16, and an overflow occurs, so the maximum value of UInt16 is returned.import std.overflow.*\nimport std.math.*\n\n\nmain() {\n    let a: UInt16 = UInt16.Max\n    println(a.saturatingMul(16))\n}\n\n//The result is as follows:\n65535"}
{"text": "Cangjie programming language syntax:\nstd.overflow package\nAn example of a strategy for throwing exceptions.\nHere's an example of an exception throwing strategy, where an attempt to compute Int64.Max + 1 occurs, an overflow occurs, and an OverflowException is thrown.import std.overflow.*\nimport std.math.*\n\n\nmain() {\n    let a: Int64 = Int64.Max\n    println(a.throwingAdd(1))\n}\n\n//The result is as follows:\nAn exception has occurred:\nOverflowException: add"}
{"text": "Cangjie programming language syntax:\nstd.overflow package\nAn example of a high-level truncation strategy.\nThe following is an example of a high-level truncation strategy, in which UInt8.Max + 1 is attempted, the UInt8.Max binary representation is 0b111111111, and UInt8.Max + 1 is 0b100000000, since UInt8 can only store 8 bits, the result is 0 after high-level truncation.import std.overflow.*\nimport std.math.*\n\n\nmain() {\n    let a: UInt8 = UInt8.Max\n    println(a.wrappingAdd(1))\n}\n\n//The result is as follows:\n0"}
{"text": "Cangjie programming language syntax:\nstd.random package\nFunction introduction\nThe random package provides the ability to generate pseudo-random numbers.\n\nList of APIs\nClass name\tfunction\nRandom\tProvides the ability to generate pseudorandom numbers."}
{"text": "Cangjie programming language syntax:\nstd.regex package\nFunction introduction\nThe regex package uses regular expressions to analyze and process textual capabilities (only ASCII-encoded strings are supported), and supports functions such as finding, splitting, replacing, validating, and more.\n\nregex rule set\nCurrently, the regular expression of Cangjie only supports the following rules, and using unsupported rules will cause the output to be inconsistent with expectations.\n\ncharacter\tdescription\n\\\tMark the next character as a special character (File Format Escape, see this table for a list), or a literal character (Identity Escape, with ^$()*+?. [{|12 in total), or a backreferences. For example, \"n\" matches the character \"n\". \\nMatch a line break. The sequence \\matches\\, while (then matches (.\n^\tMatches the start position of the input string. If the multi-row mode multiLine() in RegexOption is set, ^ also matches the position after \\n or \\r.\n$\tMatches the end position of the input string.\n*\tMatches the preceding subexpression zero or more times. For example, zo* matches z, zo, and zoo. *Equivalent to {0,}.\n+\tMatch the preceding subexpression one or more times. For example, zo+ can match zo and zoo, but not z. + is equivalent to {1,}.\n?\tMatch the preceding subexpression zero times or once. For example, do(es) can match do and does in does. Equivalent to {0,1}.\n{n}\tn is a non-negative integer. Matched the identified n times. For example, o{2} can't match the o in Bob, but it can match two o's in food.\n{n,}\tn is a non-negative integer. Match at least n times. For example, o{2,} can't match the o in Bob, but it can match all the o's in foooood. o{1,} is equivalent to o+. o{0,} is equivalent to o*.\n{n,m}\tm and n are both non-negative integers, where n<=m. Minimum match n times and maximum match m times. For example, o{1,3} will match the first three o's in fooooood. o{0,1} is equivalent to o?. Note that there can be no space between a comma and two numbers.\n?\tNon-greedy quantifiers: The matching pattern is non-greedy when the character is immediately followed by any of the other repeating modifiers (*, +,?,{n}, {n,}, {n,m}). The non-greedy mode matches as few strings as possible, while the default greedy mode matches as many strings as possible. For example, for the string oooo, O+?, which will match a single O, and O+, will match all O's.\n.\tMatches any single character except \\n. To match any character, including \\n, use a character like (.| \\n).\n(pattern)\tMatch the pattern and get the substring of that match. This substring is used for backward references. The resulting matches can be obtained from the resulting Matches collection. To match parenthesis characters, use \\ (or \\). It can be suffix quantity.\nx|y\tIt is not enclosed in (), and its scope is the entire regular expression. For example, z|food can match either z or food. (?:z|f)ood matches zood or food.\n[xyz]\tCharacter class. Match any of the characters it contains. For example, [abc] can match a in plain. Special characters only have a backslash\\ to keep a special meaning and are used to escape characters. Other special characters such as asterisks, plus signs, and various parentheses are treated as normal characters. The caret ^, if it appears in the first place, indicates a collection of negative characters; If it appears in the middle of a string, it is only a normal character. Hyphen - if appears in the middle of the string, it indicates a character range description; If it appears at the beginning (or end), it is only as a normal character. The opening bracket should be escaped and can also appear as the first character.\n[^xyz]\tNegated character classes. Matches any character that is not listed. For example, [^abc] can match plin in plain.\n[a-z]\tCharacter range. Matches any character within the specified range. For example, [a-z] can match any lowercase letter character in the range A to Z.\n[^a-z]\tThe range of excluded characters. Matches any arbitrary character that is not within the specified range. For example, [^a-z] can match any character that is not in the range a to z.\n\\b\tMatch a word boundary, which is the position between the word and the space. For example, er\\b can match the er in never, but not the er in verb.\n\\B\tMatch non-word boundaries. er\\B can match the er in verb, but not the er in never.\n\\d\tMatch a numeric character. Equivalent to [0-9].\n\\D\tMatch a non-numeric character. Equivalent to [^0-9].\n\\f\tMatch a page break. Equivalent to \\x0c.\n\\n\tMatch a line break. Equivalent to \\x0a.\n\\r\tMatch a carriage return. Equivalent to \\x0d.\n\\s\tMatch any whitespace character, including spaces, tabs, page breaks, and more. Equivalent to [\\f\\n\\r\\t\\v].\n\\S\tMatches any non-whitespace characters. Equivalent to [^\\f\\n\\r\\t\\v].\n\\t\tMatch a tab. Equivalent to \\x09.\n\\v\t匹配\\n\\v\\f\\r\\x85。\n\\w\tMatches any word character that includes underscores. Equivalent to [A-Za-z0-9_].\n\\W\tMatch any non-word characters. Equivalent to [^A-Za-z0-9_].\n\\xnm\tHexadecimal escape character sequence. Match the characters represented by the two hexadecimal digits nm. For example, \\x41 matches A. ASCII codes can be used in regular expressions.\n\\num\tBack-reference a substring that matches the num parenthetically enclosed capture group subexpression of the regular expression. where num is a decimal positive integer starting at 1, and the Regex capture group is capped at 63. For example: (.) \\1 matches two consecutive identical characters.\n(?:pattern)\tMatching patterns but not getting matching substrings (shy groups), i.e. this is a non-getting match, and the matching substrings are not stored for backward reference. This is done in the use of the or character (|) It's useful to combine the parts of a pattern.\n(?=pattern)\tLook ahead positive assert, which matches the lookup string at the beginning of any string that matches the pattern. This is a non-acquisition match, that is, the match does not need to be acquired for later use. For example, Windows(?=95|98| NT|2000) can match Windows in Windows 2000, but not Windows in Windows 3.1. Prelookup does not consume characters, that is, after one match occurs, the search for the next match starts immediately after the last match, rather than after the character that contains the prelook.\n(?! pattern)\tNegative assert, which matches the lookup string at the beginning of any string that does not match the pattern. This is a non-acquisition match, that is, the match does not need to be acquired for later use. e.g. Windows (?!) 95|98| NT|2000) can match Windows in Windows 3.1, but not Windows in Windows 2000. Prelookup does not consume characters, that is, after one match occurs, the search for the next match starts immediately after the last match, rather than after the character that contains the prelook.\n(?<=pattern)\tA look behind positive pre-check is similar to a positive positive pre-check, but in the opposite direction. For example, (?<=95|98| NT|2000) Windows can match Windows in 2000Windows, but not Windows in 3.1.\n(?<!pattern)\tA reverse negative pre-check is similar to a positive negative pre-check, but in the opposite direction. For example, (?<!95|98| NT|2000) Windows can match Windows in 3.1Windows, but not Windows in 2000.\n(?i)\tSpecify that some rules ignore case by specifying a rule. Currently, Regex only supports global case ignorance, and when this option is specified, it will be treated as a global case ignorance.\n(?-i)\tUse rules to specify that some rules are case-sensitive. Currently, Regex is case-sensitive by default, and this option is only compiled-compatible, not sensitive.\n+\tA single plus sign, not an escaped \\+.\n*\tA single asterisk, not an escaped \\*.\n-\tA single minus, not an escaped \\-.\n]\tA single closing bracket, not an escaped \\].\n}\tA single closing curly brace, not an escaped \\}.\n[[:alpha:]]\tIndicates arbitrary uppercase and lowercase letters.\n[[:^alpha:]]\tRepresents any character other than uppercase and lowercase letters.\n[[:lower:]]\tIndicates any lowercase letter.\n[[:^lower:]]\tRepresents any character other than lowercase letters.\n[[:upper:]]\tIndicates any capital letter.\n[[:^upper:]]\tRepresents any character other than capital letters.\n[[:digit:]]\tRepresents any single number between 0 and 9.\n[[:^digit:]]\tRepresents any character other than a single number between 0 and 9.\n[[:xdigit:]]\tLetters and numbers that represent hexadecimal.\n[[:^xdigit:]]\tRepresents any character other than hexadecimal letters and numbers.\n[[:alnum:]]\tIndicates any number or letter.\n[[:^alnum:]]\tRepresents any character other than numbers or letters.\n[[:space:]]\tRepresents any whitespace character, including \"space\", \"tab key\", etc.\n[[:^space:]]\tRepresents any character other than whitespace.\n[[:punct:]]\tIndicates arbitrary punctuation.\n[[:^punct:]]\tRepresents any character other than any punctuation marks.\nIn Cangjie, there are some special rules:\n\nIf the characters in front of ?, +, and * are not quantifiable, they will be ignored; Special case: (*, |*, * are treated as normal characters when starting with *, |*, *.)\n\n*? In matching all *? If you form a string of previous characters, the characters will not be matched.\n\nThe maximum number of capture groups for regular expressions is 63, and the maximum length of the compiled rule is 65535.\n\nTemporarily unsupported scenarios: ((pattern1){m1,n1}pattern2){m2,n2}, that is:\n\nGroup definition 1 is modified by {m1,n1};\nGroup Definition 1 is wrapped by Group Definition 2;\nGroup definition 2 is modified by {m2,n2}."}
{"text": "Cangjie programming language syntax:\nstd.regex package\nRegexOption gets the current regular match patternimport std.regex.*\n\n\nmain(): Unit {\n    var a = RegexOption()\n    println(a.toString())\n    a = RegexOption().ignoreCase()\n    println(a.toString())\n    a = RegexOption().multiLine()\n    println(a.toString())\n    a = RegexOption().multiLine().ignoreCase()\n    println(a.toString())\n}\n\n//Results:\nNORMAL,NFA\nIGNORECASE,NFA\nMULTILINE,NFA\nMULTILINE,IGNORECASE,NFA"}
{"text": "Cangjie programming language syntax:\nstd.regex package\nRegex matches caseimport std.regex.*\n\n\nmain(): Unit {\n    let r1 = Regex(\"ab\")\n    let r2 = Regex(\"ab\", RegexOption().ignoreCase())\n    match (r1.matches(\"aB\")) {\n        case Some(r) => println(r.matchStr())\n        case None => println(\"None\")\n    }\n    match (r2.matches(\"aB\")) {\n        case Some(r) => println(r.matchStr())\n        case None => println(\"None\")\n    }\n}\n\n//Results:\nNone\naB"}
{"text": "Cangjie programming language syntax:\nstd.regex package\nMatchOption matches multiple rowsimport std.regex.*\n\n\nmain(): Unit {\n    let rule = ##\"^(\\w+)\\s(\\d+)*$\"##\n    let pattern: String = \"\"\"\nJoe 164\nSam 208\nAllison 211\nGwen 171\n\"\"\"\n\n\n    let r1 = Regex(rule, RegexOption().multiLine())\n    var arr = r1.matcher(pattern).findAll() ?? Array<MatchData>()\n    for (md in arr) {\n        println(md.matchStr())\n    }\n}\n\n//Results:\nJoe 164\nSam 208\nAllison 211\nGwen 171"}
{"text": "Cangjie programming language syntax:\nstd.regex package\nUse of Matcher and MatchDataimport std.regex.*\n\n\nmain(): Unit {\n    let r = Regex(#\"a\\wa\"#).matcher(\"1aba12ada555\")\n    for (_ in 0..2) {\n        let matchData = r.find()\n        match (matchData) {\n            case Some(md) =>\n                println(md.matchStr())\n                let pos = md.matchPosition()\n                println(\"[${pos.start}, ${pos.end})\")\n            case None => println(\"None\")\n        }\n    }\n}\n\n//Results:\naba\n[1, 4)\nada\n[6, 9)"}
{"text": "Cangjie programming language syntax:\nstd.regex package\nresetString/fullMatch/matchStart function in Matcherimport std.regex.*\n\n\nmain(): Unit {\n    let r = Regex(\"\\\\d+\")\n    let m = r.matcher(\"13588123456\")\n    let matchData1 = m.fullMatch()\n    m.resetString(\"13588abc\")\n    let matchData2 = m.matchStart()\n    m.resetString(\"abc13588123abc\")\n    let matchData3 = m.matchStart()\n    match (matchData1) {\n        case Some(md) => println(md.matchStr())\n        case None => println(\"None\")\n    }\n    match (matchData2) {\n        case Some(md) => println(md.matchStr())\n        case None => println(\"None\")\n    }\n    match (matchData3) {\n        case Some(md) => println(md.matchStr())\n        case None => println(\"None\")\n    }\n}\n\n//Results:\n13588123456\n13588\nNone"}
{"text": "Cangjie programming language syntax:\nstd.regex package\nreplace/replaceAll function in Matcherimport std.regex.*\n\n\nmain(): Unit {\n    let r = Regex(\"\\\\d\").matcher(\"a1b1c2d3f4\")\n    println(r.replace(\"X\")) //replace a digit once with X\n    println(r.replace(\"X\", 2)) //replace once from index 4\n    println(r.replaceAll(\"X\")) //replace all digit with X\n    println(r.replaceAll(\"X\", 2)) //replace all at most 2 times\n    println(r.replaceAll(\"X\", -1)) //replace all digit with X\n}\n\n//Results:\naXb1c2d3f4\na1bXc2d3f4\naXbXcXdXfX\naXbXc2d3f4\naXbXcXdXfX"}
{"text": "Cangjie programming language syntax:\nstd.regex package\nMatcher gets the total number of matchesimport std.regex.*\n\n\nmain(): Unit {\n    var matcher = Regex(\"a+b\").matcher(\"1ab2aab3aaab4aaaab\")\n    println(matcher.allCount())\n}\n\n//Results:\n\n4"}
{"text": "Cangjie programming language syntax:\nstd.regex package\ngroupNumber function in MatchDataimport std.regex.*\n\n\nmain(): Unit {\n    var r = Regex(\"(a+c)(a?b)()(()?c+((e|s([a-h]*))))\")\n    var m = r.matcher(\"aacbcsdedd\")\n    var matchData = m.find()\n    match (matchData) {\n        case Some(s) =>\n            println(\"groupNum : ${s.groupNumber()}\")\n            if (s.groupNumber() > 0) {\n                for (i in 1..=s.groupNumber()) {\n                    println(\"group[${i}] : ${s.matchStr(i)}\")\n                    var pos = s.matchPosition(i)\n                    println(\"position : [${pos.start}, ${pos.end})\")\n                }\n            }\n        case None => ()\n    }\n}\n\n//Results:\ngroupNum : 8\ngroup[1] : aac\nposition : [0, 3)\ngroup[2] : b\nposition : [3, 4)\ngroup[3] :\nposition : [4, 4)\ngroup[4] : csdedd\nposition : [4, 10)\ngroup[5] :\nposition : [10, 10)\ngroup[6] : sdedd\nposition : [5, 10)\ngroup[7] : sdedd\nposition : [5, 10)\ngroup[8] : dedd\nposition : [6, 10)"}
{"text": "Cangjie programming language syntax:\nstd.runtime package\nFunction introduction\nThe runtime package interacts with the program's runtime environment, providing a set of functions and variables for controlling, managing, and monitoring the program's execution.\n\nThe CangJie language uses an automatic garbage collection mechanism to manage memory, and the runtime package provides functions such as manually triggering garbage collection, setting garbage collection thresholds, and obtaining memory statistics to regulate and monitor garbage collection.\n\nList of APIs\nfunction\nfunction name\tfunction\nGC(Bool)\t\nSetGCThreshold(UInt64)\tModify the memory threshold that the user expects to trigger GC, and trigger GC in KB when the size of the Cangjie heap exceeds this value.\nStructure\nThe name of the structure\tfunction\nMemoryInfo\tProvides an interface to get some heap memory statistics.\nThreadInfo\tProvides an interface to obtain some Cangjie thread statistics."}
{"text": "Cangjie programming language syntax:\nstd.socket package\n\nFunction introduction\nThe socket package is used for network communication, providing functions such as starting the socket server, connecting to the socket server, sending data, and receiving data.\n\nWe support three socket types: UDP/TCP/UDS, which users can choose according to their needs.\n\nUDP (User Datagram Protocol) is a connectionless transport protocol that does not provide reliability and flow control, but has low latency and low network overhead. UDP is mainly used in applications that require high real-time performance, such as live video streaming and online games.\n\nTCP (Transmission Control Protocol) is a connection-oriented and reliable transmission protocol. It provides reliable data transmission, flow control, congestion control, error detection, and traffic management, and is one of the most commonly used transport protocols on the Internet.\n\nUDS (Unix Domain Socket) is a mechanism for communication between processes on the same computer. Unlike network sockets, UDS does not require a network protocol stack and network equipment, so it can communicate faster, with lower latency and higher throughput.\n\nThe following is the class inheritance relationship for the socket provided for this library:\nHierarchy\n Resource\n ├StreamingSocket\n │   ├TcpSocket\n │   └UnixSocket\n │\n ├DatagramSocket\n │   ├UdpSocket\n │   └UnixDatagramSocket\n │\n └ServerSocket\n     ├TcpServerSocket\n     └UnixServerSocket\n\nList of APIs\nConstants & Variables\nConstant & variable name\tfunction\nIPV4_ALL_ROUTER\tIPv4 reserved multicast address.\nIPV4_ALL_SYSTEM\tIPv4 multicast address.\nIPV4_BROADCAST\tIPv4 broadcast address.\nIPV4_LOCAL_HOST\tIPv4 local address.\nIPV4_ZERO\tIPv4 universal address.\nIPV6_INTERFACE_LOCAL_ALL_NODES\tIPv6 multicast addresses for all nodes in the local range of the node.\nIPV6_LINK_LOCAL_ALL_NODES\tIPv6 multicast addresses for all nodes within the link-local range.\nIPV6_LINK_LOCAL_ALL_ROUTERS\tAll router multicast addresses in the local range of the IPv6 link.\nIPV6_LOOPBACK\tIPv6 loopback address (local address).\nIPV6_ZERO\tIPv6 universal address.\n\ninterface\nThe name of the interface\tfunction\nDatagramSocket\tA DatagramSocket is a socket that receives and reads packets.\nServerSocket\tThe interface required for the socket on the service side.\nStreamingSocket\tA running socket in duplex streaming mode, which can be read and written."}
{"text": "Cangjie programming language syntax:\nstd.socket package\nUse cases for property configuration usage.\nAttribute configurationimport std.socket.*\nimport std.time.*\nimport std.sync.*\n\n\nmain (){\n   try (tcpSocket = TcpSocket(\"127.0.0.1\", 80)) {\n      tcpSocket.readTimeout = Duration.second\n      tcpSocket.noDelay = false\n      tcpSocket.linger = Duration.minute\n\n\n      tcpSocket.keepAlive = SocketKeepAliveConfig(\n         interval: Duration.second * 7,\n         count: 15\n      )\n   }\n}"}
{"text": "Cangjie programming language syntax:\nstd.socket package\nUse cases for property configuration usage.\nAdd custom attributesimport std.socket.*\n\n\nextend TcpSocket {\n    public mut prop customNoDelay: Int64 {\n        get() {\n            Int64(getSocketOptionIntNative(SocketOptions.IPPROTO_TCP, SocketOptions.TCP_NODELAY))\n        }\n        set(value) {\n            setSocketOptionIntNative(SocketOptions.IPPROTO_TCP, SocketOptions.TCP_NODELAY, IntNative(value))\n        }\n    }\n}\n\n\nmain() {\n    let socket = TcpSocket(\"127.0.0.1\", 0)\n    socket.customNoDelay = 1\n    println(socket.customNoDelay)\n}\n\n//Results:\n1"}
{"text": "Cangjie programming language syntax:\nstd.sort package\nFunction introduction\nThe sort package provides sorting functions of the array type.\n\nAccording to the sorting method, this package provides two sets of implementations: stable sorting and unstable sorting. Stable ordering means that the order of equal elements remains the same before and after the sorting. Conversely, unstable ordering means that there is no guarantee that the order of equal elements will be consistent before and after sorting.\n\nThis package provides a set of sorting functions with generics that can be used to sort an array of elements of type T. Sorting necessarily requires that the elements are comparable, so this set of functions is further divided into two categories: 1) T is required to implement the Comparable<T> interface, and 2) T is passed into the function as a parameter.\n\nIn addition, the package provides auxiliary interfaces, SortByExtension and SortExtension, which can be used to implement sorting-related functions for other types.\n\nList of APIs\nfunction\nfunction name\tfunction\nstableSort<T>(Array<T>) where T <: Comparable<T>\tSort arrays in a steady ascending order.\nstableSort<T>(Array<T>, (T, T) -> Ordering)\tSort arrays in a steady ascending order.\nunstableSort<T>(Array<T>) where T <: Comparable<T>\tPerform an unstable ascending sort of array.\nunstableSort<T>(Array<T>, (T, T) -> Ordering)\tPerform an unstable ascending sort of array.\ninterface\nThe name of the interface\tfunction\nSortByExtension\tThis interface acts as a sorting-related secondary interface and is empty internally.\nSortExtension\tThis interface acts as a sorting-related secondary interface and is empty internally."}
{"text": "Cangjie programming language syntax:\nstd.sort package\nCreate an unordered Array, sort the Array in ascending order, and use isAsc to determine whether the sort is in ascending order.\n\nCode:import std.sort.*\nimport std.random.*\n\n\nmain(): Unit {\n    let r: Random = Random()\n    let arr: Array<Int64> = Array<Int64>(70000, { _ => r.nextInt64() })\n    arr.sortBy(stable: true){ rht: Int64, lht: Int64 =>\n        if (rht < lht) {\n            return Ordering.LT\n        }\n        if (rht > lht) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    }\n\n\n    println(isAsc(arr))\n}\n\n\nfunc isAsc(t: Array<Int64>) {\n    var item: Int64 = t[0]\n    for (i in 1..t.size) {\n        if (item > t[i]) {\n            return false\n        }\n        item = t[i]\n    }\n    return true\n}\n\n//Results:\ntrue"}
{"text": "Cangjie programming language syntax:\nstd.sync package\nFunction introduction\nThe sync package provides capabilities related to concurrent programming.\n\nAs more and more computers begin to use multi-core processors, concurrent programming is becoming increasingly important to take full advantage of multi-cores.\n\nDifferent programming languages implement threads in different ways. Some programming languages create threads by calling operating system APIs, meaning that each language thread corresponds to an operating system thread, commonly referred to as a 1:1 threading model; There are also programming languages that offer special threading implementations that allow multiple language threads to switch executions in the context of a different number of OS threads, a threading model also known as M:N, where M language threads schedule execution on N OS threads, where M and N are not necessarily equal.\n\nCangjie programming language hopes to provide developers with a friendly, efficient, and unified concurrent programming interface, so that developers do not need to care about the conceptual differences such as operating system threads and user-mode threads, and at the same time shield the underlying implementation details, so we only provide a concept of Cangjie threads. Cangjie threads are implemented in the M:N thread model, so it is essentially a user-mode lightweight thread that supports preemption and occupies less memory resources than operating system threads.\n\nWhen a developer wants to execute a piece of code concurrently, he or she only needs to create a Cangjie thread.\n\nTo create a new Cangjie thread, you can use the keyword spawn and pass a lambda expression with an invisible parameter, which is the code we want to execute in the new thread.\n\nExample:\n\nCreate a Cangjie thread with the spawn keyword:import std.sync.sleep\nimport std.time.Duration\n\n\nmain () {\n    spawn {\n        //Execute in a new thread\n        println(\"Thread: ${Thread.currentThread.id}\")\n    }\n   //Execute in the main thread\n    println(\"Thread: ${Thread.currentThread.id}\")\n    sleep(Duration.second)\n\n    0\n}"}
{"text": "Cangjie programming language syntax:\nThe sync package mainly provides different types of atomic operations, reentrant mutexes and their interfaces, thread synchronization mechanisms that take advantage of shared variables, and the functionality of timers.\n\nAtomic operations provide atomic operations that include integer types, Bool types, and reference types.\n\nThe integer types include: Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, and UInt64.\n\nAtomic operations of integer type support basic operations such as read, load, store, swap/compareAndSwap, and arithmetic operations (fetchAdd/fetchSub).\n\nThe return value of swap and arithmetic operations is the value before the modification.\n\ncompareAndSwap is to determine whether the value of the current atomic variable is equal to the specified value, and if so, replace it with another value; Otherwise, it will not be replaced.\n\nAtomic operations of bool type and reference type only provide read, write and swap operations, with the following caveats:\n\nAtomic operations on reference types are only valid for reference types.\n\nReentrantMutex has many inconveniences when using ReentrantMutex, such as forgetting to unlock it if you are not careful, or throwing an exception when holding a mutex lock cannot automatically release the lock. Therefore, the Cangjie programming language provides the synchronized keyword, which can be used in conjunction with ReentrantMutex to solve similar problems.\n\nBy adding a reentrant mutex instance to the end of synchronized and protecting the code block behind it, you can make it possible for at most one thread to execute the protected code at any one time:\n\nA thread automatically acquires a lock on the ReentrantMutex instance before entering a synchronized-decorated block, and if it can't, the current thread is blocked.\nA thread automatically releases the lock on a ReentrantMutex instance before exiting a synchronized-modified block of code, including using control transition expressions such as break, continue, return, throw, etc. in the block.\nBefore the thread of each for loop enters the synchronized block, it will automatically obtain the lock corresponding to the MTX instance, and before exiting the code block, the lock corresponding to the MTX instance will be released.\nExample:import std.sync.{ReentrantMutex, sleep}\nimport std.time.Duration\n\n\nmain () {\n    let mtx = ReentrantMutex()\n    let cnt = Box<Int64>(0)\n\n\n    for (_ in 0..10) {\n        spawn {\n            synchronized(mtx) {\n                cnt.value ++\n                println(\"count: ${cnt.value}\")\n            }\n        }\n    }\n\n\n    sleep(Duration.second)\n    0\n}"}
{"text": "Cangjie programming language syntax:\nstd.sync package\nUse of Atomic\nIn a multithreaded program, count is implemented using atomic operations:import std.sync.*\nimport std.time.*\nimport std.collection.*\n\n\nlet count = AtomicInt64(0)\n\n\nmain(): Int64 {\n    let list = ArrayList<Future<Int64>>()\n\n\n    /*Create 1000 threads*/\n    for (_ in 0..1000) {\n        let fut = spawn {\n            sleep(Duration.millisecond) /*Sleep for 1 millisecond*/\n            count.fetchAdd(1)\n        }\n        list.append(fut)\n    }\n\n    /*Waiting for all threads to complete*/\n    for (f in list) {\n        f.get()\n    }\n\n\n    var val = count.load()\n    println(\"count = ${val}\")\n    return 0\n}\n\n//Output:count = 1000"}
{"text": "Cangjie programming language syntax:\nCurrently, you cannot directly import the compress module through import compress, otherwise, an error error (error: can not find package 'compress') will be reported during the compilation phase. It is recommended that you currently use the compress module in the form of importing compress subpackages.\n\nIntroduction to the compress function\nThe compress module provides compression and decompression functions.\n\nCompression refers to representing data with fewer bits in order to store and transmit data more efficiently. In practical applications, compression is widely used in file compression, web page compression, database backup, etc.\n\nThe implementation of the compression function depends on compression algorithms, such as deflate, lz77, lzw, etc., which can remove or replace the redundant information in the data into a more compact representation, so as to achieve the purpose of data compression. This module currently uses the self-developed deflate algorithm.\n\nBased on the deflate compression algorithm, the compressed data can be encapsulated into compressed files in different formats, such as deflate-raw (no encapsulation), gzip, zip, png, etc. Where zip can be used for compression and packaging of multiple files, gzip contains only one compressed file. Currently, the data formats supported by this module are deflate-raw and gzip, and the file packaging function is not supported.\n\nIn addition, this module supports setting the compression level, the higher compression level corresponds to a higher compression ratio and a slower compression speed, and conversely, the lower compression level corresponds to a lower compression ratio and a faster compression speed.\n\nIn particular, zlib refers to an implementation library of compression functions, and the zlib package of this module implements the deflate algorithm and supports deflate-raw and gzip compression formats.\n\nA list of packages for the compress module\nThe compress module provides the following packages:\n\nPackage name\tfunction\nzlib\tThe zlib package provides compression and decompression capabilities.\n\nzlib compression and decompression library.\n\nThis package uses the self-developed deflate algorithm, supports deflate-raw and gzip data formats, and supports three compression levels: fast, default, and high compression ratio, and the compression speed decreases and the compression rate increases in turn.\n\nThis package provides streaming compression and decompression, that is, it supports reading data from the input stream, compressing or decompressing it, and writing it to a byte array, or reading data from a byte array, compressing or decompressing it, and writing it to the output stream.\n\nillustrate\nThis package does not support file packing.\n\nList of APIs\nClass name\tfunction\nCompressInputStream\tCompress the input stream.\nCompressOutputStream\tCompress the output stream.\nDecompressInputStream\tDecompress the input stream.\nDecompressOutputStream\tExtract the output stream."}
{"text": "Cangjie programming language syntax:\nCompression and decompression of data in Deflate formatimport compress.zlib.*\nimport std.fs.*\n\n\nmain() {\n    var arr: Array<Byte> = Array<Byte>(1024 * 1024, {i => UInt8(i % 256)})\n    File.writeTo(\"./zlib1.txt\", arr, openOption: Create(false))\n\n\n    if (compressFile(\"./zlib1.txt\", \"./zlib_compressed1.zlib\") <= 0) {\n        println(\"Failed to compress file!\")\n    }\n\n\n    if (decompressFile(\"./zlib_compressed1.zlib\", \"./zlib_decompressed1.txt\") != arr.size) {\n        println(\"Failed to decompress file!\")\n    }\n\n\n    if (compareFile(\"./zlib1.txt\", \"./zlib_decompressed1.txt\")) {\n        println(\"success\")\n    } else {\n        println(\"failed\")\n    }\n\n\n    File.delete(\"./zlib1.txt\")\n    File.delete(\"./zlib_compressed1.zlib\")\n    File.delete(\"./zlib_decompressed1.txt\")\n    return 0\n}\n\n\nfunc compressFile(srcFileName: String, destFileName: String): Int64 {\n    var count: Int64 = 0\n    var srcFile: File = File(srcFileName, OpenOption.Open(true, false))\n    var destFile: File = File(destFileName, OpenOption.Create(false))\n\n\n    var tempBuf: Array<UInt8> = Array<UInt8>(1024, item: 0)\n    var compressOutputStream: CompressOutputStream = CompressOutputStream(destFile, wrap: DeflateFormat)\n    while (true) {\n        var readNum = srcFile.read(tempBuf)\n        if (readNum > 0) {\n            compressOutputStream.write(tempBuf.slice(0, readNum).toArray())\n            count += readNum\n        } else {\n            break\n        }\n    }\n    compressOutputStream.flush()\n    compressOutputStream.close()\n\n\n    srcFile.close()\n    destFile.close()\n    return count\n}\n\n\nfunc decompressFile(srcFileName: String, destFileName: String): Int64 {\n    var count: Int64 = 0\n    var srcFile: File = File(srcFileName, OpenOption.Open(true, false))\n    var destFile: File = File(destFileName, OpenOption.Create(false))\n\n\n    var tempBuf: Array<UInt8> = Array<UInt8>(1024, item: 0)\n    var decompressInputStream: DecompressInputStream = DecompressInputStream(srcFile, wrap: DeflateFormat)\n    while (true) {\n        var readNum = decompressInputStream.read(tempBuf)\n        if (readNum <= 0) {\n            break\n        }\n        destFile.write(tempBuf.slice(0, readNum).toArray())\n        count += readNum\n    }\n    decompressInputStream.close()\n\n\n    srcFile.close()\n    destFile.close()\n    return count\n}\n\n\nfunc compareFile(fileName1: String, fileName2: String): Bool {\n    return File.readFrom(fileName1) == File.readFrom(fileName2)\n}"}
{"text": "Cangjie programming language syntax:\nCompression and decompression of data in Gzip formatimport compress.zlib.*\nimport std.fs.*\n\n\nmain() {\n    var arr: Array<Byte> = Array<Byte>(1024 * 1024, {i => UInt8(i % 256)})\n    File.writeTo(\"./zlib.txt\", arr, openOption: Create(false))\n\n\n    if (compressFile(\"./zlib.txt\", \"./zlib_compressed.zlib\") <= 0) {\n        println(\"Failed to compress file!\")\n    }\n\n\n    if (decompressFile(\"./zlib_compressed.zlib\", \"./zlib_decompressed.txt\") != arr.size) {\n        println(\"Failed to decompress file!\")\n    }\n\n\n    if (compareFile(\"./zlib.txt\", \"./zlib_decompressed.txt\")) {\n        println(\"success\")\n    } else {\n        println(\"failed\")\n    }\n\n\n    File.delete(\"./zlib.txt\")\n    File.delete(\"./zlib_compressed.zlib\")\n    File.delete(\"./zlib_decompressed.txt\")\n    return 0\n}\n\n\nfunc compressFile(srcFileName: String, destFileName: String): Int64 {\n    var count: Int64 = 0\n    var srcFile: File = File(srcFileName, OpenOption.Open(true, false))\n    var destFile: File = File(destFileName, OpenOption.Create(false))\n\n\n    var tempBuf: Array<UInt8> = Array<UInt8>(1024, item: 0)\n    var compressOutputStream: CompressOutputStream = CompressOutputStream(destFile, wrap: GzipFormat, bufLen: 10000)\n    while (true) {\n        var readNum = srcFile.read(tempBuf)\n        if (readNum > 0) {\n            compressOutputStream.write(tempBuf.slice(0, readNum).toArray())\n            count += readNum\n        } else {\n            break\n        }\n    }\n    compressOutputStream.flush()\n    compressOutputStream.close()\n\n\n    srcFile.close()\n    destFile.close()\n    return count\n}\n\n\nfunc decompressFile(srcFileName: String, destFileName: String): Int64 {\n    var count: Int64 = 0\n    var srcFile: File = File(srcFileName, OpenOption.Open(true, false))\n    var destFile: File = File(destFileName, OpenOption.Create(false))\n\n\n    var tempBuf: Array<UInt8> = Array<UInt8>(1024, item: 0)\n    var decompressInputStream: DecompressInputStream = DecompressInputStream(srcFile, wrap: GzipFormat, bufLen: 10000)\n    while (true) {\n        var readNum = decompressInputStream.read(tempBuf)\n        if (readNum <= 0) {\n            break\n        }\n        destFile.write(tempBuf.slice(0, readNum).toArray())\n        count += readNum\n    }\n    decompressInputStream.close()\n\n\n    srcFile.close()\n    destFile.close()\n    return count\n}\n\n\nfunc compareFile(fileName1: String, fileName2: String): Bool {\n    return File.readFrom(fileName1) == File.readFrom(fileName2)\n}"}
{"text": "Cangjie programming language syntax:\nCurrently, you cannot import a crypto module directly through import crypto, otherwise, an error (error: can not find package 'crypto') will be reported during the compilation phase. It is recommended to currently use the crypto module in the form of importing crypto subpackages.\n\nIntroduction to crypto features\nThe crypto module provides secure cryptographic capabilities, including generating secure random numbers, generating message digests, encrypting and signing data, creating and resolving certificates, and more.\n\nIn practical applications, crypto modules are often used to encrypt user passwords, protect sensitive data, and generate digital signatures.\n\nA list of packages for crypto modules\nThe crypto module provides the following packages:\n\nPackage name\tfunction\ncrypto\tThe crypto package provides a secure random number feature.\ndigest\tThe digest package provides commonly used message digest algorithms, including MD5, SHA1, SHA224, SHA256, SHA384, SHA512, HMAC, SM3, and more.\nkeys\tThe keys package provides asymmetric encryption and signature algorithms, including RSA and SM2 asymmetric encryption algorithms and ECDSA signature algorithms.\nx509\tThe x509 package provides the ability to process digital certificates, providing key functions including parsing and serializing X509 certificates, validating certificates, creating self-signed certificates, and creating and validating certificate chains."}
{"text": "Cangjie programming language syntax:\nExample: Random creates a random number object.\n\nCode:import crypto.crypto.*\nmain() {\n    let r = SecureRandom()\n    for (_ in 0..10) {\n        let flip = r.nextBool()\n        println(flip)\n    }\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nExample: SM4 encrypts and decrypts data.\n\nCode:import crypto.crypto.*\nimport encoding.hex.fromHexString\nmain() {\n\n\n    var plains = \"hello cangjie!\"\n    var key = \"1234567890123456\"\n    var iv = \"1234567890123456\"\n    var sm4 = SM4(OperationMode.CBC, key.toArray(), iv: iv.toArray())\n    var enRe = sm4.encrypt(plains.toArray())\n    var dd =sm4.decrypt(enRe)\n    println(String.fromUtf8(dd))\n}\n\n//Results:\nhello cangjie!"}
{"text": "Cangjie programming language syntax:\nExample of the MD5 algorithm\nCall the general digest function provided by the Cangjie standard libraryimport crypto.digest.*\nimport std.convert.*\nimport std.crypto.digest.*\nimport encoding.hex.*\n\n\nmain() {\n    var str: String = \"helloworld\"\n    var md5Instance = MD5()\n    var md: Array<Byte> = digest(md5Instance, str)\n    var result: String = toHexString(md)\n    println(result)\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nCall the MD5 member functionimport crypto.digest.*\nimport std.convert.*\nimport std.crypto.digest.*\nimport encoding.hex.*\n\n\nmain() {\n    var str: String = \"helloworld\"\n    var md5Instance = MD5()\n    md5Instance.write(str.toArray())\n    var md: Array<Byte> = md5Instance.finish()\n    var result: String = toHexString(md)\n    println(result)\n    return 0\n}\n//Results:fc5e038d38a57032085441e7fe7010b0"}
{"text": "Cangjie programming language syntax:\nExample of an RSA key\nGenerate rsa public and private keys, encrypt them with OAEP padding mode of public keys, and decrypt them with OAEP padding mode of private keys:import crypto.keys.*\nimport crypto.digest.*\nimport std.io.*\nimport std.crypto.digest.*\n\n\nmain() {\n    var rsaPri = RSAPrivateKey(2048)\n    var rsaPub = RSAPublicKey(rsaPri)\n\n\n    var str: String = \"hello world, hello cangjie\"\n    var bas1 = ByteArrayStream()\n    var bas2 = ByteArrayStream()\n    var bas3 = ByteArrayStream()\n    bas1.write(str.toArray())\n\n\n    var encOpt = OAEPOption(SHA1(), SHA256())\n    rsaPub.encrypt(bas1, bas2, padType: OAEP(encOpt))\n    var encOpt2 = OAEPOption(SHA1(), SHA256())\n    rsaPri.decrypt(bas2, bas3, padType: OAEP(encOpt2))\n\n\n    var buf = Array<Byte>(str.size, item:0)\n    bas3.read(buf)\n    if (str.toArray() == buf){\n        println(\"success\")\n    } else {\n        println(\"fail\")\n    }\n}\n\n//Results:success"}
{"text": "Cangjie programming language syntax:\nRead the rsa public and private keys from the file and sign them using the PKCS1 padding mode of the private key, and verify the signing result with the PKCS1 padding mode of the public key\nIllustrate:\n\nYou need to prepare your own public and private key files.import crypto.keys.*\nimport crypto.digest.*\nimport std.crypto.digest.*\nimport std.fs.*\n\n\nmain() {\n    var pemPri = String.fromUtf8(File(\"./files/rsaPri.pem\", OpenOption.Open(true, false)).readToEnd())\n    var rsaPri = RSAPrivateKey.decodeFromPem(pemPri)\n\n\n    var pemPub = String.fromUtf8(File(\"./files/rsaPub.pem\", OpenOption.Open(true, false)).readToEnd())\n    var rsaPub = RSAPublicKey.decodeFromPem(pemPub)\n\n\n    var str: String = \"helloworld\"\n    var sha512Instance = SHA512()\n    var md: Array<Byte> = digest(sha512Instance, str)\n\n\n    var sig = rsaPri.sign(sha512Instance, md, padType: PKCS1)\n    if (rsaPub.verify(sha512Instance, md, sig, padType: PKCS1)){\n        println(\"verify successful\")\n    }\n}\n\n//Results:\nverify successful"}
{"text": "Cangjie programming language syntax:\nAn example of an ECDSA key\nUse the ECDSA key usage example.\n\nGenerate ECDSA public key and private key, sign with private key, and verify the signature result with the public keyimport crypto.keys.*\nimport crypto.digest.*\nimport std.convert.*\nimport std.crypto.digest.*\n\n\nmain() {\n    var ecPri = ECDSAPrivateKey(P224)\n    var ecPub = ECDSAPublicKey(ecPri)\n\n\n    var str: String = \"helloworld\"\n    var sha512Instance = SHA512()\n    var md: Array<Byte> = digest(sha512Instance, str)\n\n\n    var sig = ecPri.sign(md)\n    println(sig)\n    if (ecPub.verify(md, sig)){\n        println(\"verify successful\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nencoding module\n\nCurrently, you cannot directly import encoding modules through import encoding, otherwise, an error (error: can not find package 'encoding') will be reported during the compilation phase. It is recommended to currently use the encoding module in the form of importing encoding subpackages.\n\nIntroduction to the encoding function\nThe encoding module provides character encoding and decoding functions.\n\nBase64, Hex, JSON, and URL data are supported.\n\nA list of packages for the encoding module\nThe encoding module provides the following packages:\n\nPackage name\tfunction\nbase64\tThe base package provides Base64 encoding and decoding of strings.\nhex\tThe hex package provides hex encoding and decoding of strings.\njson\tThe json package is used to process json data and realize the conversion between String, JsonValue, and DataModel.\njson.stream\tThe json.stream package is mainly used for converting between Cangjie objects and JSON data streams.\nurl\tThe url package provides URL-related capabilities, including parsing various components of the URL, encoding and decoding the URL, merging URLs or paths, and so on."}
{"text": "Cangjie programming language syntax:\nByte array and Base64 swap example:import encoding.base64.*\nmain(): Int64 {\n    var arr = Array<Byte>([77, 97, 110])\n    var str = toBase64String(arr)\n    print(\"${str},\")\n    var opArr: Option<Array<Byte>> = fromBase64String(str)\n    var arr2: Array<Byte> = match (opArr) {\n        case Some(s) => s\n        case None => Array<Byte>()\n    }\n    for (i in 0..arr2.size) {\n        print(\"${arr2[i]},\")\n    }\n    return 0\n}\n\n//The result is as follows:TWFu,77,97,110,"}
{"text": "Cangjie programming language syntax:\nByte arrays and Hex are swapped example:import encoding.hex.*\nmain(): Int64 {\n    var arr = Array<Byte>([65, 66, 94, 97])\n    var str = toHexString(arr)\n    print(\"${str},\")\n    var opArr: Option<Array<Byte>> = fromHexString(str)\n    var arr2: Array<Byte> = match (opArr) {\n        case Some(s) => s\n        case None => Array<Byte>()\n    }\n    for (i in 0..arr2.size) {\n        print(\"${arr2[i]},\")\n    }\n    return 0\n}\n\n//The result is as follows:\n41425e61,65,66,94,97,"}
{"text": "Cangjie programming language syntax:\nJsonArray usage example\nHere's an example of using JsonArray, which constructs a JsonArray object, adds some JsonValues to it, and finally prints the JsonArray object in two formats.import encoding.json.*\nimport std.collection.*\n\n\nmain() {\n    var a: JsonValue = JsonNull()\n    var b: JsonValue = JsonBool(true)\n    var c: JsonValue = JsonBool(false)\n    var d: JsonValue = JsonInt(7363)\n    var e: JsonValue = JsonFloat(736423.546)\n    var list: ArrayList<JsonValue> = ArrayList<JsonValue>()\n    var list2: ArrayList<JsonValue> = ArrayList<JsonValue>()\n    var map = JsonObject()\n    var map1 = JsonObject()\n    map1.put(\"a\", JsonString(\"jjjjjj\"))\n    map1.put(\"b\", b)\n    map1.put(\"c\", JsonString(\"hhhhh\"))\n    list2.append(b)\n    list2.append(JsonInt(3333333))\n    list2.append(map1)\n    list2.append(JsonString(\"sdfghgfasd\"))\n    list.append(b)\n    list.append(a)\n    list.append(map)\n    list.append(c)\n    list.append(JsonArray(list2))\n    list.append(d)\n    list.append(JsonString(\"ddddddd\"))\n    list.append(e)\n    var result: JsonValue = JsonArray(list)\n    println(\"func toString result is:\")\n    println(result.toString())\n    println(\"func toJsonString result is:\")\n    println(result.toJsonString())\n    0\n}"}
{"text": "Cangjie programming language syntax:\nJsonValue and String are converted to each other\nHere's an example of converting JsonValue and String to and from each other, using JsonValue.fromStr to convert a JSON string to a JsonValue, and then printing the JsonValue object in both formats.import encoding.json.*\n\nmain() {\n    var str = ##\"[true,\"kjjjke\\\"eed\",{\"sdfd\":\"ggggg\",\"eeeee\":[341,false,{\"nnnn\":55.87}]},3422,22.341,false,[22,22.22,true,\"ddd\"],43]\"##\n    var jv: JsonValue = JsonValue.fromStr(str)\n    var res = jv.toString()\n    var prettyres = jv.toJsonString()\n    println(res)\n    println(prettyres)\n    0\n}"}
{"text": "Cangjie programming language syntax:\nJsonValue to DataModel\n\nHere's an example of a conversion between a JSON string and a custom type, which implements the Serializable interface for the Person type, followed by a conversion from a JSON string to a custom type and from a custom type to a JSON string.import serialization.serialization.*\nimport encoding.json.*\n\n\nclass Person <: Serializable<Person> {\n    var name: String = \"\"\n    var age: Int64 = 0\n    var loc: Option<Location> = Option<Location>.None\n\n\n    public func serialize(): DataModel {\n        return DataModelStruct().add(field<String>(\"name\", name)).add(field<Int64>(\"age\", age)).add(field<Option<Location>>(\"loc\", loc))\n    }\n\n\n    public static func deserialize(dm: DataModel): Person {\n        var dms = match (dm) {\n            case data: DataModelStruct => data\n            case _ => throw Exception(\"this data is not DataModelStruct\")\n        }\n        var result = Person()\n        result.name = String.deserialize(dms.get(\"name\"))\n        result.age = Int64.deserialize(dms.get(\"age\"))\n        result.loc = Option<Location>.deserialize(dms.get(\"loc\"))\n        return result\n    }\n}\n\n\nclass Location <: Serializable<Location>{\n    var country: String = \"\"\n    var province: String = \"\"\n\n\n    public func serialize(): DataModel {\n        return DataModelStruct().add(field<String>(\"country\", country)).add(field<String>(\"province\", province))\n    }\n\n\n    public static func deserialize(dm: DataModel): Location {\n        var dms = match (dm) {\n            case data: DataModelStruct => data\n            case _ => throw Exception(\"this data is not DataModelStruct\")\n        }\n        var result = Location()\n        result.country = String.deserialize(dms.get(\"country\"))\n        result.province = String.deserialize(dms.get(\"province\"))\n        return result\n    }\n}\n\n\nmain() {\n    var js = ##\"{\n    \"name\": \"A\",\n    \"age\": 30,\n    \"loc\": {\n        \"country\": \"China\",\n        \"province\": \"Beijing\"\n    }\n}\"##\n    var jv = JsonValue.fromStr(js)\n    var dm = DataModel.fromJson(jv)\n    var A = Person.deserialize(dm)\n    println(\"name == ${A.name}\")\n    println(\"age == ${A.age}\")\n    println(\"country == ${A.loc.getOrThrow().country}\")\n    println(\"province == ${A.loc.getOrThrow().province}\")\n    println(\""}
{"text": "Cangjie programming language syntax:\n"}
{"text": "Cangjie programming language syntax:\nCurrently, you cannot directly import a fuzz module through import fuzz, otherwise, an error (error: can not find package 'fuzz') will be reported during the compilation phase. It is recommended to currently use the fuzz module in the form of importing fuzz subpackages.\n\nIntroduction to the Fuzz feature\nThe fuzz module provides fuzzing capabilities based on coverage feedback. Its main function is to automatically generate a large amount of random input data to detect the stability and safety of the target software in various abnormal situations.\n\nA list of packages for the fuzz module\nThe fuzz module provides the following packages:\n\nPackage name\tfunction\nfuzz\tThe fuzz package provides developers with the Cangjie fuzz engine and corresponding interfaces based on coverage feedback, and developers can write code to test the API."}
{"text": "Cangjie programming language syntax:\nTest the guess character feature\nWrite the API under test to throw an exception if and only if the input array length is 8 and the content is \"Cangjie!\" corresponding to the ASCII, and at worst it takes 2^64 guesses to trigger the exception in the case of pure randomness.\nCreate a Fuzzer and call the API to be tested to enter the main process.// 导入依赖的类\nimport fuzz.fuzz.Fuzzer\n\nmain() {\n    //Create a fuzzer and start the fuzz process\n    Fuzzer(api).startFuzz()\n    return 0\n}\n\n//The tested function will throw an exception when certain conditions are met, which will be captured by the fuzzer\npublic func api(data: Array<UInt8>): Int32 {\n    if (data.size == 8 && data[0] == b'C' && data[1] == b'a' && data[2] == b'n' && data[3] == b'g' && data[4] == b'j' &&\n        data[5] == b'i' && data[6] == b'e' && data[7] == b'!') {\n        throw Exception(\"TRAP\")\n    }\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nUse the DataProvider feature for testing\nIn addition to the method of testing the API using byte streams, the fuzz package provides the FuzzDataProvider class for more user-friendly generation of standard data types from mutated data sources, making it easy to test the API.\nIn this case, enabling --sanitizer-coverage-trace-compares effectively improves fuzz efficiency.\n\nIn DataProvider mode, it is impossible to visually determine what the return value of each API is, so Fuzzer.enableDebugDataProvider() and DebugDataProvider are provided, and you can call enableDebugDataProvider() before startFuzz to make the fuzz print the log every time it calls consumeXXX.\n\nFor example, after the above code triggers an exception, add enableDebugDataProvider to recompile, and the effect is as follows.import fuzz.fuzz.*\n\n\nmain() {\n    let fuzzer = Fuzzer(api2)\n    fuzzer.enableDebugDataProvider()\n    fuzzer.startFuzz()\n    return 0\n}"}
{"text": "Cangjie programming language syntax:\nIntroduction to the log function\nThe log module provides log management and log printing interfaces.\n\nlog module's package list\nThe log module provides the following packages:\n\nPackage name\tfunction\nlog\tThe log package provides a single logging API that abstracts away the actual logging implementation."}
{"text": "Cangjie programming language syntax:\nExample of log printing\nLog library development scenarios\nThe following is an example of printing logs when developing a Cangjie library.\n\nHere's the code:import log.*\nimport logger.*\nimport std.console.Console\n\n\npublic class PGConnection {\n    let objId: Int64 = 1\n    let logger = getGlobalLogger((\"name\", \"PGConnection\"))\n\n\n    public func close(): Unit {\n        logger.trace(\"driver conn closed\", (\"id\", objId))\n    }\n}\n\n\nmain(): Unit {\n    let tl = SimpleLogger(Console.stdOut)\n    tl.level = LogLevel.TRACE\n    setGlobalLogger(tl)\n    var conn = PGConnection()\n    conn.close()\n}"}
{"text": "Cangjie programming language syntax:\nExample of log printing\nApplication development scenario log printing\nHere's an example of custom PasswordFilter and TextLogger log printing.\n\nHere's the code:import std.time.*\nimport std.io.{OutputStream, ByteArrayStream, BufferedOutputStream}\nimport std.console.Console\nimport std.fs.*\nimport std.collection.{ArrayList, Map, HashMap}\nimport std.collection.concurrent.NonBlockingQueue\nimport std.sync.AtomicBool\nimport std.time.{Duration, DateTime}\nimport log.{LogValue, LogWriter, Logger, Attr, LogRecord, LogLevel}\nimport log\n\n\n\n\npublic class PasswordFilter <: Logger {\n    var _level = LogLevel.INFO\n    let processor: Logger\n    public init(logger: Logger) {\n        processor = logger\n    }\n    public mut prop level: LogLevel {\n        get() {\n            _level\n        }\n        set(v) {\n            _level = v\n        }\n    }\n    public func withAttrs(attrs: Array<Attr>): Logger {\n        this\n    }\n    // log\n    public func log(level: LogLevel, message: String, attrs: Array<Attr>): Unit {\n        let record: LogRecord = LogRecord(DateTime.now(), level, message, attrs)\n        log(record)\n    }\n    // lazy\n    public func log(level: LogLevel, message: () -> String, attrs: Array<Attr>): Unit {\n        let record: LogRecord = LogRecord(DateTime.now(), level, message(), attrs)\n        log(record)\n    }\n    // 根据键值对的名字过滤，将密码值换成 \"***\"\n    public func log(record: LogRecord): Unit {\n        var attrs = record.attrs.clone()\n        for (i in 0..attrs.size) {\n            var attr = attrs[i]\n            if (attr[0] == \"password\") {\n                attrs[i] = (attr[0], \"***\")\n            }\n        }\n        let r = LogRecord(record.time, record.level, record.message, attrs)\n        processor.log(r)\n    }\n    public func isClosed(): Bool {\n        false\n    }\n    public func close(): Unit {\n    }\n}\n\n\nmain() {\n    let o = ByteArrayStream()\n    let tl = TextLogger(Console.stdOut)\n    tl.level = LogLevel.TRACE\n    let l = PasswordFilter(tl)\n    log.setGlobalLogger(l)\n    let logger = log.getGlobalLogger([(\"name\", \"main\")])\n    let user = User()\n    // 普通记录信息日志\n    logger.info(\"Hello, World!\", (\"k1\", [[1, 4], [2, 5], [3]]), (\"password\", \"v22222\"))\n    // 记录诊断日志，如果 DEBUG 级别未开启，直接返回，几乎无cost\n    logger.debug(\"Logging in user ${user.name} with birthday ${user.birthdayCalendar}\")\n\n\n    // lazy 方式记录耗时日志数据\n    logger.log(LogLevel.ERROR, \"long-running operation msg\", (\"k1\", 100), (\"k2\", user.birthdayCalendar),\n        (\"oper\", ToStringWrapper({=> \"Some long-running operation returned\"})))\n\n\n    logger.log(LogLevel.ERROR, \"long-running operation msg\", (\"sourcePackage\", @sourcePackage()),\n        (\"sourceFile\", @sourceFile()), (\"sourceLine\", @sourceLine()), (\"birthdayCalendar\", user.birthdayCalendar),\n        (\"oper\", ToStringWrapper({=> \"Some long-running operation returned\"})))\n\n\n    let m = HashMap<String, String>()\n    m.put(\"k1\", \"1\")\n    m.put(\"k2\", \"2\")\n    m.put(\"k3\", \"3\")\n    logger.trace({=> \"Some long-running operation returned\"}, (\"k1\", m))\n    let m2 = HashMap<String, LogValue>()\n    m2.put(\"g1\", m)\n\n\n    // 如果TRACE 级别没有开启，那么lambda表达式不会被执行\n    logger.trace({=> \"Some long-running operation returned\"}, (\"k2\", m2))\n\n\n    // Console.stdOut.write(o.bytes())\n    // Console.stdOut.flush()\n}\n\n\npublic class User {\n    public prop name: String {\n        get() {\n            \"foo\"\n        }\n    }\n    public prop birthdayCalendar: DateTime {\n        get() {\n            DateTime.now()\n        }\n    }\n}\n\n\npublic class ToStringWrapper <: ToString & LogValue {\n    let _fn: () -> String\n    public init(fn: () -> String) {\n        _fn = fn\n    }\n    public func toString(): String {\n        return _fn()\n    }\n    public func writeTo(w: LogWriter): Unit {\n        w.writeValue(_fn())\n    }\n}\n\n\nfunc expensiveOperation(): String {\n    for (i in 0..1000000) {\n        unsafe {\n            let b = LibC.malloc<Byte>(count: 1000)\n            LibC.free(b)\n        }\n    }\n    \"Some long-running operation returned\"\n}\n\n\npublic class TextLogger <: Logger {\n    let w: TextLogWriter\n    let opts = HashMap<String, String>()\n    let _closed = AtomicBool(false)\n    let queue = NonBlockingQueue<LogRecord>()\n    let bo: BufferedOutputStream<OutputStream>\n    let _attrs = ArrayList<Attr>()\n    var _level = LogLevel.INFO\n    public init(output: OutputStream) {\n        bo = BufferedOutputStream<OutputStream>(output)\n        w = TextLogWriter(bo)\n    }\n\n\n    public mut prop level: LogLevel {\n        get() {\n            _level\n        }\n        set(v) {\n            _level = v\n        }\n    }\n    public func withAttrs(attrs: Array<Attr>): Logger {\n        if (attrs.size > 0) {\n            let nl = TextLogger(w.out)\n            nl._attrs.appendAll(attrs)\n            return nl\n        }\n        return this\n    }\n    // log\n    public func log(level: LogLevel, message: String, attrs: Array<Attr>): Unit {\n        if (this.enabled(level)) {\n            let record: LogRecord = LogRecord(DateTime.now(), level, message, attrs)\n            log(record)\n        }\n    }\n    // lazy\n    public func log(level: LogLevel, message: () -> String, attrs: Array<Attr>): Unit {\n        if (this.enabled(level)) {\n            let record: LogRecord = LogRecord(DateTime.now(), level, message(), attrs)\n            log(record)\n        }\n    }\n    public func log(record: LogRecord): Unit {\n        // write time\n        w.writeKey(\"time\")\n        w.writeValue(record.time)\n        w.writeString(\" \")\n        // write level\n        w.writeKey(\"level\")\n        w.writeString(record.level.toString())\n        w.writeString(\" \")\n        // write message\n        w.writeKey(\"msg\")\n        w.writeValue(record.message)\n        w.writeString(\" \")\n        // write source\n\n\n        // write attrs\n        for (i in 0..record.attrs.size) {\n            let attr = record.attrs[i]\n            w.writeKey(attr[0])\n            w.writeValue(attr[1])\n            if (i < record.attrs.size - 1) {\n                w.writeString(\" \")\n            }\n        }\n        w.writeString(\"\\n\")\n        bo.flush()\n    }\n    public func isClosed(): Bool {\n        _closed.load()\n    }\n    public func close(): Unit {\n        if (isClosed()) {\n            return\n        }\n        _closed.store(true)\n    }\n}\n\n\nclass TextLogWriter <: LogWriter {\n    var out: OutputStream\n    init(out: OutputStream) {\n        this.out = out\n    }\n    public func writeNone(): Unit {\n        out.write(\"None\".toArray())\n    }\n    public func writeInt(v: Int64): Unit {\n        out.write(v.toString().toArray())\n    }\n    public func writeUInt(v: UInt64): Unit {\n        out.write(v.toString().toArray())\n    }\n    public func writeBool(v: Bool): Unit {\n        out.write(v.toString().toArray())\n    }\n    public func writeFloat(v: Float64): Unit {\n        out.write(v.toString().toArray())\n    }\n    public func writeString(v: String): Unit {\n        out.write(v.toArray())\n    }\n    public func writeDateTime(v: DateTime): Unit {\n        out.write(v.toString().toArray())\n    }\n    public func writeDuration(v: Duration): Unit {\n        out.write(v.toString().toArray())\n    }\n    public func writeKey(v: String): Unit {\n        out.write(v.toString().toArray())\n        out.write(\"=\".toArray())\n    }\n    public func writeValue(v: LogValue): Unit {\n        match (v) {\n            case vv: String =>\n                out.write(\"\\\"\".toArray())\n                out.write(vv.toArray())\n                out.write(\"\\\"\".toArray())\n            case vv: ToString =>\n                out.write(\"\\\"\".toArray())\n                out.write(vv.toString().toArray())\n                out.write(\"\\\"\".toArray())\n            case _ =>\n                out.write(\"\\\"\".toArray())\n                v.writeTo(this)\n                out.write(\"\\\"\".toArray())\n        }\n    }\n    public func startArray(): Unit {\n        out.write(\"[\".toArray())\n    }\n    public func endArray(): Unit {\n        out.write(\"]\".toArray())\n    }\n    public func startObject(): Unit {\n        out.write(\"{\".toArray())\n    }\n    public func endObject(): Unit {\n        out.write(\"}\".toArray())\n    }\n}"}
{"text": "Cangjie programming language syntax:\nCurrently, you cannot directly import the Serialization module through import Serialization, otherwise, an error error (error: can not find package 'Serialization') will be reported during the compilation phase. It is recommended to currently use the Serialization module in the form of importing serialization subpackages.\n\nThe Serialization module provides serialization and deserialization capabilities.\n\nA list of packages for the serialization module\nThe serialization module provides the following packages:\n\nPackage name\tfunction\nserialization\tThe serialization package provides the ability to serialize and deserialize."}
{"text": "Cangjie programming language syntax:\nclass serialization and deserializationimport serialization.serialization.*\nimport std.math.*\nimport encoding.json.*\n\n\n/*Implement serializable interface to achieve serialization and deserialization of custom types*/\nclass Abc <: Serializable<Abc> {\n    var name: String = \"Abcde\"\n    var age: Int64 = 555\n    var loc: Option<Location> = Option<Location>.None\n\n\n    /*Implement the serializable interface serialization method*/\n    public func serialize(): DataModel {\n        return DataModelStruct().add(field<String>(\"name\", name)).add(field<Int64>(\"age\", age)).add(field<Option<Location>>(\"loc\", loc))\n    }\n\n\n    /*Implement deserialization method*/\n    public static func deserialize(dm: DataModel): Abc {\n        let dms = match (dm) {\n            case data: DataModelStruct => data\n            case _ => throw Exception(\"this data is not DataModelStruct\")\n        }\n        let result = Abc()\n        result.name = String.deserialize(dms.get(\"name\"))\n        result.age = Int64.deserialize(dms.get(\"age\"))\n        result.loc = Option<Location>.deserialize(dms.get(\"loc\"))\n        return result\n    }\n}\n\n\nclass Location <: Serializable<Location> {\n    var time: Int64 = 666\n    var heheh: Rune = 'T'\n\n\n    /*Implement the serializable interface serialization method*/\n    public func serialize(): DataModel {\n        return DataModelStruct().add(field<Int64>(\"time\", time)).add(field<Rune>(\"heheh\", heheh))\n    }\n\n\n    /*Implement deserialization method*/\n    public static func deserialize(dm: DataModel): Location {\n        let dms = match (dm) {\n            case data: DataModelStruct => data\n            case _ => throw Exception(\"this data is not DataModelStruct\")\n        }\n        let result = Location()\n        result.time = Int64.deserialize(dms.get(\"time\"))\n        result.heheh = Rune.deserialize(dms.get(\"heheh\"))\n        return result\n    }\n}\n\n\nmain(): Unit {\n    let dd = Abc()\n    let aa: JsonValue = dd.serialize().toJson()\n    let bb: JsonObject = (aa as JsonObject).getOrThrow()\n    let v1 = (bb.get(\"name\").getOrThrow() as JsonString).getOrThrow()\n    let v2 = (bb.get(\"age\").getOrThrow() as JsonInt).getOrThrow()\n    let v3 = bb.get(\"loc\").getOrThrow()\n    println(v1.getValue())\n    println(v2.getValue())\n    println(v3.toString())\n    println(\""}
{"text": "Cangjie programming language syntax:\n"}
{"text": "Cangjie programming language syntax:\nHashSet and HashMap serializationimport std.collection.*\nimport serialization.serialization.*\nimport encoding.json.*\n\n\nmain(): Unit {\n    let s: HashSet<Values> = HashSet<Values>([Values(3), Values(5), Values(7)])\n    let seris: DataModel = s.serialize()\n    println(seris.toJson().toJsonString())\n    println(\""}
{"text": "Cangjie programming language syntax:\n"}
