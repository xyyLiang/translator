{"text": "Cangjie programming language syntax:\nInteger types are divided into signed integer types and unsigned integer types.\nSigned integer types include Int8, Int16, Int32, Int64, and IntNative, which are used to represent signed integer values of lengths 8-bit, 16-bit, 32-bit, 64-bit, and platform-dependent sizes, respectively.Unsigned integer types include UInt8, UInt16, UInt32, UInt64, and UIntNative, which are used to represent unsigned integer values of lengths 8-bit, 16-bit, 32-bit, 64-bit, and platform-dependent sizes, respectively.\nInteger literals with suffixes can be used in the following way:var x = 100i8  // x is 100 with type Int8\nvar y = 0x10u64 // y is 16 with type UInt64\nvar z = 0o432i32  // z is 282 with type Int32"}
{"text": "Cangjie programming language syntax:\nThe Changjie programming language supports character byte literals to facilitate the use of ASCII codes to represent UInt8 type values. A character byte literal consists of the character b, a pair of single quotes to identify the beginning and end, and an ASCII character, for example:var a = b'x' // a is 120 with type UInt8\nvar b = b'\\n' // b is 10 with type UInt8\nvar c = b'\\u{78}' // c is 120 with type UInt8"}
{"text": "Cangjie programming language syntax:\nexponentiation(**)'s left operand can only be Int64 type or Float64 type, and:When the left operand type is Int64, the right operand can only be UInt64 type, and the expression type is Int64.When the left operand type is Float64, the right operand can only be Int64 type or Float64 type, and the expression type is Float64.\nThe use of exponentiation, see the following examples:let p1 = 2 ** 3               // p1 = 8\nlet p2 = 2 ** UInt64(3 ** 2)  // p2 = 512\nlet p3 = 2.0 ** 3             // p3 = 8.0\nlet p4 = 2.0 ** 3 ** 2        // p4 = 512.0\nlet p5 = 2.0 ** 3.0           // p5 = 8.0\nlet p6 = 2.0 ** 3.0 ** 2.0    // p6 = 512.0"}
{"text": "Cangjie programming language syntax:\nFloating-point literals have two radix representations: decimal, hexadecimal. In decimal representation, a floating-point literal must contain at least one integer part or a fractional part, and if there is no fractional part, it must include an exponent part (prefixed with e or E, with a base of 10). In hexadecimal representation, a floating-point literal must contain at least one integer part or a fractional part (prefixed with 0x or 0X), and must also include an exponent part (prefixed with p or P, with a base of 2).\nThe following examples show the use of floating-point literals:let a: Float32 = 3.14\nlet b: Float32 = 2e3\nlet c: Float32 = 2.4e-1\nlet d: Float64 = .123e2\nlet e: Float64 = 0x1.1p0\nlet f: Float64 = 0x1p2\nlet g: Float64 = 0x.2p4"}
{"text": "Cangjie programming language syntax:\nWhen using decimal floating-point literals, you can explicitly specify the type of the floating-point literal by adding a suffix, Floating-point literals with suffixes can be used in the following way:let a = 3.14f32   // a is 3.14 with type Float32\nlet b = 2e3f32    // b is 2e3 with type Float32\nlet c = 2.4e-1f64 // c is 2.4e-1 with type Float64\nlet d = .123e2f64 // d is .123e2 with type Float64"}
{"text": "Cangjie programming language syntax:\nBoolean types only have two literals: true and false. The following examples show the use of boolean literals:let a: Bool = true\nlet b: Bool = false"}
{"text": "Cangjie programming language syntax:\nCharacter type literals have three forms: single characters, escaped characters, and general characters. A Rune literal starts with the character r and is followed by a character enclosed in a pair of single or double quotes.\nAn escape character is a character that interprets the following character differently within a character sequence. Escape characters start with the escape symbol '\\', followed by the character to be escaped.\nGeneral characters start with \\u, followed by 1 to 8 hexadecimal numbers defined within a pair of curly braces, to represent the character corresponding to the Unicode value.main() {\n    let a: Rune = r'a'\n    let b: Rune = r\"b\"\n    let slash: Rune = r'\\\\'\n    let newLine: Rune = r'\\n'\n    let tab: Rune = r'\\t'\n    let he: Rune = r'\\u{4f60}'\n    let llo: Rune = r'\\u{597d}'\n    print(he)\n    print(llo)\n}"}
{"text": "Cangjie programming language syntax:\nThe String type is used to represent textual data, consisting of a sequence of Unicode characters.String literals are divided into three types: single-line string literals, multi-line string literals, and multi-line raw string literals.\nSingle-line string literals are defined within a pair of single quotes or a pair of double quotes. The content inside the quotes can be any number of characters (except for the unescaped quotes used to define the string literal and the standalone \\). Single-line string literals can only be written on the same line and cannot span multiple lines. Here are some examples:let s1: String = \"\"\nlet s2 = 'Hello Cangjie Lang'\nlet s3 = \"\\\"Hello Cangjie Lang\\\"\"\nlet s4 = 'Hello Cangjie Lang\\n'"}
{"text": "Cangjie programming language syntax:\nThe String type is used to represent textual data, consisting of a sequence of Unicode characters.String literals are divided into three types: single-line string literals, multi-line string literals, and multi-line raw string literals.\nMulti-line string literals must start and end with three double quotes (\"\"\"\") or three single quotes (''''). The content of the literal starts from the first line after the opening three quotes and ends with the first non-escaped three quotes encountered. The content can be any number of characters (except for standalone \\). Unlike single-line string literals, multi-line string literals can span multiple lines. Here are some examples:let s1: String = \"\"\"\n    \"\"\"\nlet s2 = '''\n    Hello,\n    Cangjie Lang'''"}
{"text": "Cangjie programming language syntax:\nThe String type is used to represent textual data, consisting of a sequence of Unicode characters.String literals are divided into three types: single-line string literals, multi-line string literals, and multi-line raw string literals.\nMulti-line raw string literals start with one or more hash symbols (#) followed by a single quote ('') or double quote (\"). They are followed by any number of valid characters until a quote and the same number of hash symbols as at the beginning of the string appear. If a matching double quote and the same number of hash symbols are not encountered before the end of the current file, a compilation error occurs. Like multi-line string literals, raw multi-line string literals can span multiple lines. The difference is that escape rules do not apply to raw multi-line string literals; the content within the literal remains unchanged (escape characters are not escaped, such as the \\n in the example below, which is not a newline character but the string formed by \\ and n). Here are some examples:let s1: String = #\"\"#\nlet s2 = ##'\\n'##\nlet s3 = ###\"\n    Hello,\n    Cangjie\n    Lang\"###"}
{"text": "Cangjie programming language syntax:\nThe String type is used to represent textual data, consisting of a sequence of Unicode characters.String literals are divided into three types: single-line string literals, multi-line string literals, and multi-line raw string literals.\nFor assignment operations like left = right, if the type of the left operand is Byte (an alias of the built-in type UInt8), and the right operand is a string literal representing an ASCII character, the string of the right operand will be forcibly converted to Byte type before assignment; if the type of the left operand is Rune, and the right operand is a single-character string literal, the string of the right operand will be forcibly converted to Rune type before assignment.main() {\n    var b: Byte = \"0\"\n    print(b)\n    b = \"1\"\n    print(b)\n    var r: Rune = \"0\"\n    print(r)\n    r = \"1\"\n    print(r)\n}"}
{"text": "Cangjie programming language syntax:\nAn interpolation string is a string literal containing one or more interpolation expressions (not applicable to multi-line raw string literals). By inserting expressions into the string, it effectively avoids string concatenation issues. Although it is introduced now, it has actually appeared in previous example code, because it is often used in the println function to output non-string type variable values, such as println(\"${x}\").\nInterpolation expressions must be enclosed in curly braces {} and prefixed with a $ before the braces. {} can contain one or more declarations or expressions.\nWhen evaluating interpolated strings, each interpolated expression's position is replaced by the value of the last item in {}, and the entire interpolated string remains a string.main() {\n    let fruit = \"apples\"\n    let count = 10\n    let s = \"There are ${count * count} ${fruit}\"\n    println(s)\n\n\n    let r = 2.4\n    let area = \"The area of a circle with radius ${r} is ${let PI = 3.141592; PI * r * r}\"\n    println(area)\n}"}
{"text": "Cangjie programming language syntax:\nThe string type supports comparison using relational operators and concatenation using +. The following examples demonstrate equality judgment and concatenation of the string type:main() {\n    let s1 = \"abc\"\n    var s2 = \"ABC\"\n    let r1 = s1 == s2\n    println(\"The result of 'abc' == 'ABC' is: ${r1}\")\n    let r2 = s1 + s2\n    println(\"The result of 'abc' + 'ABC' is: ${r2}\")\n}"}
{"text": "Cangjie programming language syntax:\nA tuple (Tuple) can combine multiple different types into a new type. Tuple types are represented as (T1, T2, ..., TN), where T1 to TN can be any type, and different types are connected by commas (,). A tuple is at least binary, for example, (Int64, Float64) represents a binary tuple type, and (Int64, Float64, String) represents a ternary tuple type.The length of a tuple is fixed, meaning once an instance of a tuple type is defined, its length cannot be changed.Tuple types are immutable types, meaning once an instance of a tuple type is defined, its contents cannot be updated. For examplevar tuple = (true, false)\ntuple[0] = false // Error, 'tuple element' can not be assigned"}
{"text": "Cangjie programming language syntax:\nA literal of tuple type is represented as (e1, e2, ..., eN), where e1 to eN are expressions, and multiple expressions are separated by commas. In the examples below, a variable x of type (Int64, Float64) and a variable y of type (Int64, Float64, String) are defined, and their initial values are set using tuple literals:let x: (Int64, Float64) = (3, 3.141592)\nlet y: (Int64, Float64, String) = (3, 3.141592, \"PI\")"}
{"text": "Cangjie programming language syntax:\nTuples support accessing elements at specific positions using the syntax t[index], where t is a tuple, index is an index, and index must be an integer literal starting from 0 and less than the number of elements in the tuple, otherwise, a compilation error occurs. In the examples below, pi[0] and pi[1] can be used to access the first and second elements of the binary tuple pi, respectively.main() {\n    var pi = (3.14, \"PI\")\n    println(pi[0])\n    println(pi[1])\n}"}
{"text": "Cangjie programming language syntax:\nIn assignment expressions, tuple literals can be used to destructure the right-hand side of an expression. This requires the left-hand side of the assignment expression to be a tuple literal, and the elements inside this tuple literal must all be lvalues (lvalues are expressions that appear on the left side of the assignment operator and can hold values, see the description of assignment operations in each chapter for details) or another tuple literal. When an underscore _ appears in the tuple literal, it indicates that the evaluation result at the corresponding position on the right-hand side of the tuple is ignored (meaning the type check at this position can always pass). The expression on the right-hand side must also be a tuple type, and each element's type in the right-hand tuple must be a subtype of the corresponding lvalue type. Note that compound assignment does not support this deconstruction method. In terms of evaluation order, the expression on the right-hand side is evaluated first, and then the lvalue part is assigned from left to right, for example:var a: Int64\nvar b: String\nvar c: Unit\nfunc f() { ((1, \"abc\"), ()) }\n((a, b), c) = f() // value of a is 1, value of b is \"abc\", value of c is '()'\n((a, b), _) = ((2, \"def\"), 3.0) // value of a is 2, value of b is \"def\", 3.0 is ignored"}
{"text": "Cangjie programming language syntax:\nYou can explicitly mark type parameter names for tuple types; in the examples below, name and price are type parameter names.func getFruitPrice (): (name: String, price: Int64) {\n    return (\"banana\", 10)\n}"}
{"text": "Cangjie programming language syntax:\nFor a tuple type, either all type parameter names must be written uniformly, or none should be written at all; alternation is not allowed, and parameter names themselves cannot be used as variables or to access elements within the tuple.let a: (name: String, Int64) = (\"banana\", 5)   // Error\nlet b: (name: String, price: Int64) = (\"banana\", 5) // OK\nb.name // Error"}
{"text": "Cangjie programming language syntax:\nThe Array type can be used to construct ordered sequences of data with a single element type.Cangjie uses Array<T> to represent the Array type. T represents the element type of the Array, and T can be any type.var a: Array<Int64> = ... // Array whose element type is Int64\nvar b: Array<String> = ... // Array whose element type is String"}
{"text": "Cangjie programming language syntax:\nCangjie uses Array<T> to represent the Array type. T represents the element type of the Array, and T can be any type.Arrays of different element types are of different types, so they cannot be assigned to each other.Arrays can be easily initialized using literals by enclosing a comma-separated list of values in square brackets.The compiler will automatically infer the type of the Array literal based on the context.let a: Array<String> = [] // Created an empty Array whose element type is String\nlet b = [1, 2, 3, 3, 2, 1] // Created a Array whose element type is Int64, containing elements 1, 2, 3, 3, 2, 1\n\nError_case:\nb = a // Type mismatch"}
{"text": "Cangjie programming language syntax:\nArrays can be easily initialized using literals by enclosing a comma-separated list of values in square brackets.%% You can also construct an Array of a specified element type using a constructor.It is important to note that when initializing an Array with an initial value specified by item, the constructor does not copy the item. If the item is a reference type, every element in the constructed array will point to the same reference.let a = Array<Int64>() // Created an empty Array whose element type is Int64\nlet b = Array<Int64>(a) // Use another Array to initialize b\nlet c = Array<Int64>(3, item: 0) // Created an Array whose element type is Int64, length is 3 and all elements are initialized as 0\nlet d = Array<Int64>(3, {i => i + 1}) // Created an Array whose element type is Int64, length is 3 and all elements are initialized by the initialization function"}
{"text": "Cangjie programming language syntax:\nWhen you need to access all elements of an Array, you can use a for-in loop to iterate through all elements of the Array.An Array is ordered by the insertion order of its elements, so the order of iterating through an Array is always consistent.main() {\n    let arr = [0, 1, 2]\n    for (i in arr) {\n        println(\"The element is ${i}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nWhen you need to know the number of elements contained in an Array, you can use the size property to obtain the corresponding information.main() {\n    let arr = [0, 1, 2]\n    if (arr.size == 0) {\n        println(\"This is an empty array\")\n    } else {\n        println(\"The size of array is ${arr.size}\")\n    }\n}"}
{"text": "Cangjie programming language syntax:\nWhen you want to access an element at a specific position of an Array, you can use subscript syntax (the type of the subscript must be Int64). The first element of a non-empty Array always starts at position 0. You can access any element of an Array starting from 0 up to the last position (Array's size - 1). Index values cannot be negative or greater than or equal to size. If the compiler can detect an illegal index value, it will report an error at compile time; otherwise, it will throw an exception at runtime.main() {\n    let arr = [0, 1, 2]\n    let a = arr[0] // a == 0\n    let b = arr[1] // b == 1\n    let c = arr[-1] // array size is '3', but access index is '-1', which would overflow\n}"}
{"text": "Cangjie programming language syntax:\nIf you want to get a segment of elements from an Array, you can pass a Range type value in the subscript to obtain a segment of the Array corresponding to the Range at once.When a Range literal is used in subscript syntax, you can omit the start or end.When start is omitted, Range starts from 0; when end is omitted, Range's end extends to the last element.\nlet arr1 = [0, 1, 2, 3, 4, 5, 6]\nlet arr2 = arr1[0..5] // arr2 contains the elements 0, 1, 2, 3, 4\nlet arr3 = arr1[..3] // arr3 contains elements 0, 1, 2\nlet arr4 = arr1[2..] // arr4 contains elements 2, 3, 4, 5, 6"}
{"text": "Cangjie programming language syntax:\nArray is a Collection type with a fixed length, so Array does not provide member functions for adding and removing elements.However, Array allows modification of its elements, using the same subscript syntax.main() {\n    let arr = [0, 1, 2, 3, 4, 5]\n    arr[0] = 3\n    println(\"The first element is ${arr[0]}\")\n}"}
{"text": "Cangjie programming language syntax:\nArray, although it is a struct type, only holds references to its elements internally. Therefore, when used as an expression, it does not copy the elements. All references of the same Array instance share the same element data.Therefore, modifying an Array element will affect all references to that instance.let arr1 = [0, 1, 2]\nlet arr2 = arr1\narr2[0] = 3\n// arr1 contains elements 3, 1, 2\n// arr2 contains elements 3, 1, 2"}
{"text": "Cangjie programming language syntax:\n%% In addition to the reference type array Array, Cangjie also introduces the value type array VArray<T, $N>, where T represents the element type of the value type array, and $N is a fixed syntax, represented by $ plus an Int64 type literal to indicate the length of this value type array. It should be noted that VArray<T, $N> cannot omit <T, $N>, and when using type aliases, the VArray keyword and its generic parameters cannot be split.\nCompared to frequently using the reference type Array, using the value type VArray can reduce the pressure of heap memory allocation and garbage collection. However, it should be noted that due to the copy of value types during passing and assignment, there is an additional performance overhead, so it is recommended not to use VArray with large lengths in performance-sensitive scenarios. The characteristics of value types and reference types can be referred to in Value Types and Reference Types Variables.type varr1 = VArray<Int64, $3> // Ok\ntype varr2 = VArray // Error"}
{"text": "Cangjie programming language syntax:\nVArray can be initialized with an array literal, where the lvalue a must specify the instantiated type of the VArray.At the same time, it has two constructors.var a: VArray<Int64, $3> = [1, 2, 3]\n// VArray<T, $N>(initElement: (Int64) -> T)\nlet b = VArray<Int64, $5>({ i => i}) // [0, 1, 2, 3, 4]\n// VArray<T, $N>(item!: T)\nlet c = VArray<Int64, $5>(item: 0) // [0, 0, 0, 0, 0]"}
{"text": "Cangjie programming language syntax:\nthe VArray<T, $N> type provides two member methods:The [] operator method for subscript access and modification.The size member used to get the length of VArray.var a: VArray<Int64, $3> = [1, 2, 3]\nlet i = a[1] // i is 2\na[2] = 4 // a is [1, 2, 4]\nlet s = a.size // s is 3"}
{"text": "Cangjie programming language syntax:\nThe Range type is used to represent sequences with a fixed step size. The Range type is a generic (see the Generic chapter), represented as Range<T>. When T is instantiated with different types (requiring this type to support relational operators and be able to perform addition with Int64 type values), different Range types are obtained, such as the most commonly used Range<Int64> for representing integer ranges.\nEach instance of the interval type contains three values: start, end, and step. Among them, start and end represent the starting and ending values of the sequence, respectively, and step indicates the difference between consecutive elements in the sequence (i.e., the step size); the types of start and end are the same (i.e., the type T is instantiated), and the type of step is Int64, and its value cannot be equal to 0.\nThe following example shows how to instantiate the interval type (for details on the interval type definition and its attributes, see the \"Changjie Programming Language Library API\").// Range<T>(start: T, end: T, step: Int64, hasStart: Bool, hasEnd: Bool, isClosed: Bool)\nlet r1 = Range<Int64>(0, 10, 1, true, true, true) // r1 contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nlet r2 = Range<Int64>(0, 10, 1, true, true, false) // r2 contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\nlet r3 = Range<Int64>(10, 0, -2, true, true, false) // r3 contains 10, 8, 6, 4, 2"}
{"text": "Cangjie programming language syntax:\nAn interval literal has two forms: a \"left-closed, right-open\" interval and a \"left-closed, right-closed\" interval.\nThe format of a \"left-closed, right-open\" interval is start..end : step, which represents a range starting from start, with a step of step, up to but not including end;\nThe format of a \"left-closed, right-closed\" interval is start..=end : step, which represents a range starting from start, with a step of step, up to and including end.\n The following examples define several interval-type variables:let n = 10\nlet r1 = 0..10 : 1   // r1 contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\nlet r2 = 0..=n : 1   // r2 contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nlet r3 = n..0 : -2   // r3 contains 10, 8, 6, 4, 2\nlet r4 = 10..=0 : -2 // r4 contains 10, 8, 6, 4, 2, 0"}
{"text": "Cangjie programming language syntax:\nAn interval literal has two forms: a \"left-closed, right-open\" interval and a \"left-closed, right-closed\" interval.\nIn interval literals, the step can be omitted, in which case the step defaults to 1, but note that the step value cannot be 0. Also, intervals can be empty (i.e., empty sequences that do not contain any elements).\nIn the expression start..end : step, start..end : step is an empty range when step > 0 and start >= end, or when step < 0 and start <= end;\nIn the expression start..=end : step, start..=end : step is an empty range when step > 0 and start > end, or when step < 0 and start < end.let r5 = 0..10   // the step of r5 is 1, and it contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\nlet r6 = 0..10 : 0 // Error, step cannot be 0\n\nlet r7 = 10..0 : 1 // r7 to r10 are empty ranges\nlet r8 = 0..10 : -1\nlet r9 = 10..=0 : 1\nlet r10 = 0..=10 : -1"}
{"text": "Cangjie programming language syntax:\nFor expressions that are only concerned with side effects and not with values, their type is Unit. For example, the print function, assignment expressions, compound assignment expressions, increment and decrement expressions, and loop expressions all have the type Unit.\nThe Unit type has only one value, which is also its literal: (). Except for assignment, equality, and inequality, the Unit type does not support other operations."}
{"text": "Cangjie programming language syntax:\nNothing is a special type that does not contain any value, and Nothing type is a subtype of all types.The types of break, continue, return, and throw expressions are Nothing. The compiler currently does not allow the explicit use of the Nothing type where a type is expected.When the program executes these expressions, the code following them will not be executed. return can only be used within a function body, break and continue can only be used within a loop body. See the following examples for reference:while (true) {\n    func f() {\n        break // Error, break must be used directly inside a loop\n    }\n    let g = { =>\n        continue // Error, continue must be used directly inside a loop\n    }\n}"}
{"text": "Cangjie programming language syntax:\nNothing is a special type that does not contain any value, and Nothing type is a subtype of all types.The compiler currently does not allow the explicit use of the Nothing type where a type is expected.\nSince the formal parameters and default values of a function do not belong to its function body, the return expression in the example below lacks the function body surrounding itâ€”it does not belong to the outer function f (because the inner function definition g has already started), nor is it within the function body of the inner function g:func f() {\n    func g(x!: Int64 = return) { // Error, return must be used inside a function body\n        0\n    }\n    1\n}"}
