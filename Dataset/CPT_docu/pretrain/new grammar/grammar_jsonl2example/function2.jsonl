{"text": "Cangjie programming language syntax:\nIn Clang, the keyword `func` is used to indicate the start of a function definition, followed by the function name, parameter list, an optional function return value type, and the function body. The function name can be any valid identifier, the parameter list is defined within a pair of parentheses (multiple parameters are separated by commas), the parameter list and function return value type (if present) are separated by a colon, and the function body is defined within a pair of curly braces.Example of function definition:a function named add is defined, whose parameter list consists of two Int64 type parameters a and b, the function return value type is Int64, and the function body adds a and b and returns the result.func add(a: Int64, b: Int64): Int64 {\n    return a + b\n}"}
{"text": "Cangjie programming language syntax:\nA function can have 0 or more parameters, all of which are defined in the function's parameter list. Depending on whether parameter names are required when calling the function, parameters in the parameter list can be divided into two categories: unnamed parameters and named parameters.The definition of unnamed parameters is p: T, where p represents the parameter name, T represents the type of parameter p, and the parameter name and its type are connected by a colon. For example, both parameters a and b of the add function in the previous example are unnamed parameters.\nThe definition of named parameters is p!: T, the difference from unnamed parameters being the addition of an ! after the parameter name p. The two unnamed parameters of the add function in the previous example can be modified to named parameters as follows:func add(a!: Int64, b!: Int64): Int64 {\n    return a + b\n}"}
{"text": "Cangjie programming language syntax:\nA function can have 0 or more parameters, all of which are defined in the function's parameter list. Depending on whether parameter names are required when calling the function, parameters in the parameter list can be divided into two categories: unnamed parameters and named parameters.The definition of unnamed parameters is p: T, where p represents the parameter name, T represents the type of parameter p, and the parameter name and its type are connected by a colon. For example, both parameters a and b of the add function in the previous example are unnamed parameters.\nNamed parameters can also have default values, by setting the default value of parameter p to the value of expression e using p!: T = e. For example, the default values of both parameters of the add function mentioned above can be set to 1:func add(a!: Int64 = 1, b!: Int64 = 1): Int64 {\n    return a + b\n}"}
{"text": "Cangjie programming language syntax:\nA function can have 0 or more parameters, all of which are defined in the function's parameter list. Depending on whether parameter names are required when calling the function, parameters in the parameter list can be divided into two categories: unnamed parameters and named parameters.\nNon-named and named parameters can be defined together in the parameter list, but it is important to note that non-named parameters can only be defined before named parameters, meaning non-named parameters cannot appear after named parameters. For example, the parameter list definition of the add function in the following example is invalid:\n\nError_case:\nfunc add(a!: Int64, b: Int64): Int64 { // Error, named parameter 'a' must be defined after non-named parameter 'b'\n    return a + b\n}"}
{"text": "Cangjie programming language syntax:\nA function can have 0 or more parameters, all of which are defined in the function's parameter list. Depending on whether parameter names are required when calling the function, parameters in the parameter list can be divided into two categories: unnamed parameters and named parameters.\nThe main difference between non-named and named parameters lies in their usage, which can be found in the section on \"Calling Functions\" below.\nAll function parameters are immutable variables and cannot be reassigned within the function definition.\n\nError_case:\nfunc add(a: Int64, b: Int64): Int64 {\n    a = a + b // Error\n    return a\n}"}
{"text": "Cangjie programming language syntax:\nThe scope of function parameters extends from the definition to the end of the function body:func add(a: Int64, b: Int64): Int64 {\n    var a_ = a // OK\n    var b = b  // Error, redefinition of declaration 'b'\n    return a\n}"}
{"text": "Cangjie programming language syntax:\nThe function return value type is the type of the value obtained after the function is called. When defining a function, the return value type is optional: it can be explicitly defined (the return value type is defined between the parameter list and the function body), or it can be left undefined, allowing the compiler to infer it.\nWhen the function return value type is explicitly defined, it requires that the type of the function body (on how to determine the function body type, see the next section Function Body), and the type of all return e expressions within the function body are subtypes of the return value type. For example, for the aforementioned add function, its return value type is explicitly defined as Int64. If the function body's return a + b is modified to return (a, b), it will result in a type mismatch error:\n\nError_case:\n// Error, the type of the expression after return does not match the return type of the function\nfunc add(a: Int64, b: Int64): Int64 {\n    return (a, b)\n}"}
{"text": "Cangjie programming language syntax:\nWhen defining a function, if the return value type is not explicitly defined, the compiler will derive the function's return value type based on the type of the function body and all return expressions within the function body. For example, in the following example, although the return value type of the add function is omitted, the compiler can deduce that the return value type of the add function is Int64 based on the return a + b expression:func add(a: Int64, b: Int64) {\n    return a + b\n}"}
{"text": "Cangjie programming language syntax:\nThe function body defines the operations to be executed when the function is called, typically containing a series of variable definitions and expressions, and can also include new function definitions (i.e., nested functions). For example, in the add function's function body, it first defines an Int64 type variable r (initially set to 0), then assigns the value of a + b to r, and finally returns the value of r:func add(a: Int64, b: Int64) {\n    var r = 0\n    r = a + b\n    return r\n}"}
{"text": "Cangjie programming language syntax:\nYou can use the return expression at any position within the function body to terminate the function execution and return. The return expression has two forms: return and return expr (where expr is an expression).\nFor `return expr`, the type of `expr` must be consistent with the return value type defined in the function. For example, the following will result in an error because the type of `100` in `return 100` (Int64) is different from the return value type of function `foo` (String).\n\nError_case:\n// Error, cannot convert an integer literal to type 'Struct-String'\nfunc foo(): String {\n    return 100\n}"}
{"text": "Cangjie programming language syntax:\nYou can use the return expression at any position within the function body to terminate the function execution and return. The return expression has two forms: return and return expr (where expr is an expression).\nFor return, it is equivalent to return (), so the return value type of the function is required to be Unit.The return expression as a whole does not determine its type based on the expressions that follow it; it is of the Nothing type.func add(a: Int64, b: Int64) {\n    var r = 0\n    r = a + b\n    return r\n}\n\nfunc foo(): Unit {\n    add(1, 2)\n    return\n}"}
{"text": "Cangjie programming language syntax:\nVariables defined within the function body are a type of local variable (such as the r variable in the example above), and their scope extends from their point of definition to the end of the function body.\nFor a local variable, it is allowed to define a variable with the same name in an outer scope, and within the scope of the local variable, the local variable will \"shadow\" the variable with the same name in the outer scope. For example:the global variable r of type Int64 is defined before the add function, and the add function body also defines a local variable with the same name r. Therefore, within the function body, all occurrences of the variable r (such as r = a + b) refer to the local variable r, meaning that the local variable r \"shadows\" the global variable r.let r = 0\nfunc add(a: Int64, b: Int64) {\n    var r = 0\n    r = a + b\n    return r\n}"}
{"text": "Cangjie programming language syntax:\nIn the section on function return value types, it is mentioned that the function body also has a type. The type of the function body is the type of the last \"item\" in the function body: if the last item is an expression, then the type of the function body is the type of this expression; if the last item is a variable definition or a function declaration, or if the function body is empty, then the type of the function body is Unit.In th example, since the last \"item\" in the function body is an expression of type Int64 (i.e., a + b), the type of the function body is also Int64, matching the return value type defined in the function. Similarly, in the following example, the last item in the function body is a print function call, so the type of the function body is Unit, which also matches the return value type defined in the function:func foo(): Unit {\n    let s = \"Hello\"\n    print(s)\n}"}
{"text": "Cangjie programming language syntax:\nThe form of a function call is f(arg1, arg2, ..., argn). Here, f is the name of the function to be called, and arg1 to argn are n arguments passed during the call (called actual parameters), requiring each actual parameter to be a subtype of the corresponding parameter type. Actual parameters can have 0 or more, and when the number of actual parameters is 0, the call format is f().\nDepending on whether the parameters are non-named or named when defining the function, the way actual parameters are passed during the function call also varies: for non-named parameters, the corresponding actual parameter is an expression, and for named parameters, the corresponding actual parameter needs to use the form p: e, where p is the name of the named parameter and e is an expression (i.e., the value passed to parameter p).\nExample of non-named parameter call:func add(a: Int64, b: Int64) {\n    return a + b\n}\nmain() {\n    let x = 1\n    let y = 2\n    let r = add(x, y)\n    println(\"The sum of x and y is ${r}\")\n}"}
{"text": "Cangjie programming language syntax:\nThe form of a function call is f(arg1, arg2, ..., argn). Here, f is the name of the function to be called, and arg1 to argn are n arguments passed during the call (called actual parameters), requiring each actual parameter to be a subtype of the corresponding parameter type. Actual parameters can have 0 or more, and when the number of actual parameters is 0, the call format is f().\nDepending on whether the parameters are non-named or named when defining the function, the way actual parameters are passed during the function call also varies: for non-named parameters, the corresponding actual parameter is an expression, and for named parameters, the corresponding actual parameter needs to use the form p: e, where p is the name of the named parameter and e is an expression (i.e., the value passed to parameter p).\nExample of named parameter calls:func add(a: Int64, b!: Int64) {\n    return a + b\n}\n\n\nmain() {\n    let x = 1\n    let y = 2\n    let r = add(x, b: y)\n    println(\"The sum of x and y is ${r}\")\n}"}
{"text": "Cangjie programming language syntax:\nFor multiple named parameters, the order of passing parameters during the call can be different from the order of parameters when defined. For example, in the following example, when calling the add function, b can appear before a:func add(a!: Int64, b!: Int64) {\n    return a + b\n}\n\n\nmain() {\n    let x = 1\n    let y = 2\n    let r = add(b: y, a: x)\n    println(\"The sum of x and y is ${r}\")\n}"}
{"text": "Cangjie programming language syntax:\nFor named parameters with default values, if no actual argument is passed during the call, this parameter will use its default value as the value of the actual argument. For example, when calling the add function in the following example, no actual argument is passed for parameter b, so the value of parameter b is equal to its default value of 2 defined at the time of definition:func add(a: Int64, b!: Int64 = 2) {\n    return a + b\n}\n\n\nmain() {\n    let x = 1\n    let r = add(x)\n    println(\"The sum of x and y is ${r}\")\n}"}
{"text": "Cangjie programming language syntax:\nFor named parameters with default values, a new actual argument can also be passed during the call. In this case, the value of the named parameter is equal to the value of the new actual argument, meaning the default value defined at the time of definition will be invalid. For example, when calling the add function in the following example, a new actual argument value of 20 is passed for parameter b, so the value of parameter b is 20:func add(a: Int64, b!: Int64 = 2) {\n    return a + b\n}\n\n\nmain() {\n    let x = 1\n    let r = add(x, b: 20)\n    println(\"The sum of x and y is ${r}\")\n}"}
{"text": "Cangjie programming language syntax:\nIn the Clang programming language, functions are first-class citizens, which can be used as parameters or return values of functions, or assigned to variables. Therefore, functions themselves also have types, called function types.\nThe function type is composed of the parameter type and return type of the function, with the parameter type and return type connected by ->. The parameter type is enclosed in parentheses (), and can have 0 or more parameters. If there are multiple parameters, they are separated by commas (,).The example defines a function, named hello, with a type of () -> Unit, indicating that the function takes no parameters and has a return type of Unit.func hello(): Unit {\n    println(\"Hello!\")\n}"}
{"text": "Cangjie programming language syntax:\nThe function name is display, with a type of (Int64) -> Unit, indicating that the function has one parameter, the parameter type is Int64, and the return type is Unit.func display(a: Int64): Unit {\n    println(a)\n}"}
{"text": "Cangjie programming language syntax:\nThe function name is add, with a type of (Int64, Int64) -> Int64, indicating that the function has two parameters, both parameter types are Int64, and the return type is Int64.func add(a: Int64, b: Int64): Int64 {\n    a + b\n}"}
{"text": "Cangjie programming language syntax:\nThe function name is returnTuple, its type is (Int64, Int64) -> (Int64, Int64), both parameter types are Int64, and the return type is a tuple type: (Int64, Int64).func returnTuple(a: Int64, b: Int64): (Int64, Int64) {\n    (a, b)\n}"}
{"text": "Cangjie programming language syntax:\nFunction types can be marked with explicit type parameter names, such as name and price in the example below, which are the type parameter names.func showFruitPrice(name: String, price: Int64) {\n    println(\"fruit: ${name} price: ${price} yuan\")\n}\n\n\nmain() {\n    let fruitPriceHandler: (name: String, price: Int64) -> Unit\n    fruitPriceHandler = showFruitPrice\n    fruitPriceHandler(\"banana\", 10)\n}"}
{"text": "Cangjie programming language syntax:\nAdditionally, for a function type, either all type parameter names must be written uniformly, or none must be written uniformly; they cannot coexist alternately.\n\nError_case:\nlet handler: (name: String, Int64) -> Int64   // Error"}
{"text": "Cangjie programming language syntax:\nThe function name is printAdd, its type is ((Int64, Int64) -> Int64, Int64, Int64) -> Unit, which means this function has three parameters, the parameter types are function type (Int64, Int64) -> Int64 and two Int64, and the return type is Unit.func printAdd(add: (Int64, Int64) -> Int64, a: Int64, b: Int64): Unit {\n    println(add(a, b))\n}"}
{"text": "Cangjie programming language syntax:\nA function type can also be the return type of another function.\nIn the following example, the function name is returnAdd, and its type is () -> (Int64, Int64) -> Int64, which indicates that the function takes no parameters and returns a function type (Int64, Int64) -> Int64. Note that -> is right-associative.func add(a: Int64, b: Int64): Int64 {\n    a + b\n}\n\n\nfunc returnAdd(): (Int64, Int64) -> Int64 {\n    add\n}\n\n\nmain() {\n    var a = returnAdd()\n    println(a(1,2))\n}"}
{"text": "Cangjie programming language syntax:\nThe function name itself is also an expression, and its type is the corresponding function type.In the example, the function name is add, and its type is (Int64, Int64) -> Int64. The type of variable f is the same as the type of add, and add is used to initialize f.func add(p1: Int64, p2: Int64): Int64 {\n    p1 + p2\n}\nlet f: (Int64, Int64) -> Int64 = add"}
{"text": "Cangjie programming language syntax:\nIf a function is overloaded in the current scope (see Function Overloading), directly using the function name as an expression may cause ambiguity. If ambiguity occurs, the compiler will report an error, for example:func add(i: Int64, j: Int64) {\n    i + j\n}\n\nfunc add(i: Float64, j: Float64) {\n    i + j\n}\n\nmain() {\n    var f = add   // Error, ambiguous function 'add'\n    var plus: (Int64, Int64) -> Int64 = add  // OK\n}"}
{"text": "Cangjie programming language syntax:\nFunctions defined at the top level of the source file are called global functions. Functions defined within a function body are called nested functions.\nExample, function foo defines a nested function nestAdd, which can be called within foo, or the nested function nestAdd can be returned as a return value and called outside foo:func foo() {\n    func nestAdd(a: Int64, b: Int64) {\n        a + b + 3\n    }\n\n    println(nestAdd(1, 2))  // 6\n\n    return nestAdd\n}\n\nmain() {\n    let f = foo()\n    let x = f(1, 2)\n    println(\"result: ${x}\")\n}"}
{"text": "Cangjie programming language syntax:\nThe syntax of a lambda expression is as follows: { p1: T1, ..., pn: Tn => expressions | declarations }.\nAmong them, the part before => is the parameter list, with multiple parameters separated by commas, and each parameter name and parameter type separated by a colon. There can also be no parameters before =>. The part after => is the lambda expression body, which is a sequence of expressions or statements. The scope of the parameter name in a lambda expression is the same as that of a function, specifically the function body part of the lambda expression. Its scope level can be considered equivalent to variables defined within the lambda expression's function body.let f1 = { a: Int64, b: Int64 => a + b }\n\nvar display = { =>   // Parameterless lambda expression.\n    println(\"Hello\")\n    println(\"World\")\n}"}
{"text": "Cangjie programming language syntax:\nRegardless of whether a lambda expression has parameters or not, => cannot be omitted unless it is used as a trailing lambda. For example:var display = { => println(\"Hello\") }\n\nfunc f2(lam: () -> Unit) {}\nlet f2Res = f2 { println(\"World\") } // OK to omit the =>"}
{"text": "Cangjie programming language syntax:\nType annotations for parameters in a lambda expression can be omitted. In the following cases, if the parameter type is omitted, the compiler will attempt type inference. If the compiler cannot infer the type, a compilation error will occur:\nWhen a lambda expression is assigned to a variable, its parameter type is inferred based on the variable type;When used as an argument in a function call expression, the parameter type of a lambda expression is inferred based on the parameter type of the function.// The parameter types are inferred from the type of the variable sum1\nvar sum1: (Int64, Int64) -> Int64 = { a, b => a + b }\n\n\nvar sum2: (Int64, Int64) -> Int64 = { a: Int64, b => a + b }\n\n\nfunc f(a1: (Int64) -> Int64): Int64 {\n    a1(1)\n}\n\n\nmain(): Int64 {\n    // The parameter type of lambda is inferred from the type of function f\n    f({ a2 => a2 + 10 })\n}"}
{"text": "Cangjie programming language syntax:\nLambda expressions do not support declaring a return type; their return type is always inferred from the context. If it cannot be inferred, an error is reported.\nIf the context explicitly specifies the return type of a lambda expression, its return type is the type specified in the context.\nWhen a lambda expression is assigned to a variable, its return type is inferred based on the variable type.let f: () -> Unit = { ... }"}
{"text": "Cangjie programming language syntax:\nLambda expressions do not support declaring a return type; their return type is always inferred from the context. If it cannot be inferred, an error is reported.\nIf the context explicitly specifies the return type of a lambda expression, its return type is the type specified in the context.\nWhen a lambda expression is assigned to a variable, its return type is inferred based on the variable type.\nWhen used as a parameter, the return type of a lambda expression is inferred based on the type of the formal parameter in the function call where it is used.func f(a1: (Int64) -> Int64): Int64 {\n    a1(1)\n}\nmain(): Int64 {\n    f({ a2: Int64 => a2 + 10 })\n}"}
{"text": "Cangjie programming language syntax:\nLambda expressions do not support declaring a return type; their return type is always inferred from the context. If it cannot be inferred, an error is reported.\nIf the context explicitly specifies the return type of a lambda expression, its return type is the type specified in the context.\nWhen used as a return value, the return type of a lambda expression is inferred based on the return type of the function where it is used:func f(): (Int64) -> Int64 {\n    { a: Int64 => a }\n}"}
{"text": "Cangjie programming language syntax:\nLambda expressions do not support declaring a return type; their return type is always inferred from the context. If it cannot be inferred, an error is reported.\nIf the type is not explicitly specified in the context, similar to deriving the return value type of a function, the compiler will infer the return type of the lambda expression based on the types of all return expressions return xxx within the lambda expression body, as well as the type of the lambda expression body, to jointly derive the return type of the lambda expression.\n=> The content on the right follows the same rules as a regular function body, with the return type being Int64.\n => Empty on the right, return type is Unit.let sum1 = { a: Int64, b: Int64 => a + b }\nlet f = { => }"}
{"text": "Cangjie programming language syntax:\nLambda expressions support immediate invocation, for example:let r1 = { a: Int64, b: Int64 => a + b }(1, 2) // r1 = 3\nlet r2 = { => 123 }()                          // r2 = 123"}
{"text": "Cangjie programming language syntax:\nLambda expressions can also be assigned to a variable and invoked using the variable name, for example:func f() {\n    var g = { x: Int64 => println(\"x = ${x}\") }\n    g(2)\n}"}
{"text": "Cangjie programming language syntax:\nThe closure `add` captures the local variable `num` declared with `let`, and then returns it to the scope outside of `num`'s definition. When `add` is called, it can still access `num` normally.func returnAddNum(): (Int64) -> Int64 {\n    let num: Int64 = 10\n\n\n    func add(a: Int64) {\n        return a + num\n    }\n    add\n}\n\n\nmain() {\n    let f = returnAddNum()\n    println(f(10))\n}"}
{"text": "Cangjie programming language syntax:\nExample : The captured variable must be visible at the time of closure definition.func f() {\n    let x = 99\n    func f1() {\n        println(x)\n    }\n    let f2 = { =>\n        println(y)      // Error, cannot capture 'y' which is not defined yet\n    }\n    let y = 88\n    f1()          // Print 99.\n    f2()\n}"}
{"text": "Cangjie programming language syntax:\nExample : The captured variable must be initialized before the closure definition.func f() {\n    let x: Int64\n    func f1() {\n        println(x)    // Error, x is not initialized yet.\n    }\n    x = 99\n    f1()\n}"}
{"text": "Cangjie programming language syntax:\nIf the captured variable is a reference type, its mutable instance member variables can be modified.class C {\n    public var num: Int64 = 0\n}\n\n\nfunc returnIncrementer(): () -> Unit {\n    let c: C = C()\n\n\n    func incrementer() {\n        c.num++\n    }\n\n\n    incrementer\n}\n\n\nmain() {\n    let f = returnIncrementer()\n    f() // c.num increases by 1\n}"}
{"text": "Cangjie programming language syntax:\nTo prevent closures that capture variables declared with `var` from escaping, such closures can only be called and cannot be used as first-class citizens, including not being assigned to variables, not used as actual parameters or return values, and not directly using the closure's name as an expression.func f() {\n    var x = 1\n    let y = 2\n\n\n    func g() {\n        println(x)  // OK, captured a mutable variable.\n    }\n    let b = g  // Error, g cannot be assigned to a variable\n\n\n    g  // Error, g cannot be used as an expression\n    g()  // OK, g can be invoked\n\n\n    g  // Error, g cannot be used as a return value.\n}"}
{"text": "Cangjie programming language syntax:\nIt should be noted that capture has transitivity. If a function f calls a function g that captures the variable var, and the var variable captured by g is not defined within function f, then function f also captures the var variable. In this case, f cannot be used as a first-class citizen.\nIn the following example, g captures the variable x declared by var, f calls g, and the x captured by g is not defined within f, so f cannot be used as a first-class citizen:func h(){\n    var x = 1\n\n\n    func g() {  x }   // captured a mutable variable\n\n\n    func f() {\n        g()      // invoked g\n    }\n    return f // Error\n}"}
{"text": "Cangjie programming language syntax:\nIn the following example, g captures the variable x declared by var, f calls g. But the x captured by g is defined within f, and f does not capture any other variables declared by var. Therefore, f is still used as a first-class citizen:func h(){\n    func f() {\n        var x = 1\n        func g() { x }   // captured a mutable variable\n\n\n        g()\n    }\n    return f // Ok\n}"}
{"text": "Cangjie programming language syntax:\nAccess to static member variables and global variables does not fall under variable capture, so functions or lambdas that access global variables or static member variables decorated with the `var` modifier can still be used as first-class citizens.class C {\n    static public var a: Int32 = 0\n    static public func foo() {\n        a++       // OK\n        return a\n    }\n}\n\n\nvar globalV1 = 0\n\n\nfunc countGlobalV1() {\n    globalV1++\n    C.a = 99\n    let g = C.foo  // OK\n}\n\n\nfunc g(){\n    let f = countGlobalV1 // OK\n    f()\n}"}
{"text": "Cangjie programming language syntax:\n"}
{"text": "Cangjie programming language syntax:\nTrailing lambda can make function calls look like built-in language syntax, enhancing the language's extensibility.When the last formal parameter of a function is of function type, and the actual argument corresponding to the function call is a lambda, you can use the trailing lambda syntax, placing the lambda at the end of the function call, outside the parentheses.\nFor example, the following example defines a myIf function, its first parameter is of Bool type, and the second parameter is of function type. When the value of the first parameter is true, it returns the value after calling the second parameter, otherwise it returns 0. myIf can be called like a regular function, or using the trailing lambda syntax.func myIf(a: Bool, fn: () -> Int64) {\n    if(a) {\n        fn()\n    } else {\n        0\n    }\n}\n\n\nfunc test() {\n    myIf(true, { => 100 }) // General function call\n\n\n    myIf(true) {        // Trailing closure call\n        100\n    }\n}"}
{"text": "Cangjie programming language syntax:\nTrailing lambda can make function calls look like built-in language syntax, enhancing the language's extensibility.\nWhen the last formal parameter of a function is of function type, and the actual argument corresponding to the function call is a lambda, you can use the trailing lambda syntax, placing the lambda at the end of the function call, outside the parentheses.\nWhen a function call has exactly one lambda actual argument, you can also omit (), just writing the lambda.func f(fn: (Int64) -> Int64) { fn(1) }\n\nfunc test() {\n    f { i => i * i }\n}"}
{"text": "Cangjie programming language syntax:\nWhen you need to perform a series of processes on input data, you can use pipeline expressions to simplify the description. The syntax of a pipeline expression is as follows: e1 |> e2. It is equivalent to the following syntax sugar: let v = e1; e2(v).\nAmong them, e2 is an expression of function type, and the type of e1 is a subtype of the parameter type of e2.func inc(x: Array<Int64>): Array<Int64> { // Increasing the value of each element in the array by '1'\n    let s = x.size\n    var i = 0\n    for (e in x where i < s) {\n        x[i] = e + 1\n        i++\n    }\n    x\n}\n\n\nfunc sum(y: Array<Int64>): Int64 { // Get the sum of elements in the array.\n    var s = 0\n    for (j in y) {\n        s += j\n    }\n    s\n}\n\n\nlet arr: Array<Int64> = Array<Int64>([1, 3, 5])\nlet res = arr |> inc |> sum // res = 12"}
{"text": "Cangjie programming language syntax:\nA composition expression represents the combination of two single-argument functions. The syntax of a composition expression is as follows: f ~> g. It is equivalent to the following form: { x => g(f(x)) }.\nAmong them, f and g are expressions of function types that take only one parameter.\nWhen f and g are combined, it is required that the return type of f(x) is a subtype of the parameter type of g(...).Example 1:\n\nfunc f(x: Int64): Float64 {\n    Float64(x)\n}\nfunc g(x: Float64): Float64 {\n    x\n}\n\nvar fg = f ~> g // The same as { x: Int64 => g(f(x)) }"}
{"text": "Cangjie programming language syntax:\nA composition expression represents the combination of two single-argument functions. The syntax of a composition expression is as follows: f ~> g. It is equivalent to the following form: { x => g(f(x)) }.\nAmong them, f and g are expressions of function types that take only one parameter.\nWhen f and g are combined, it is required that the return type of f(x) is a subtype of the parameter type of g(...).Example 2:\n\nfunc f(x: Int64): Float64 {\n    Float64(x)\n}\n\nlet lambdaComp = ({x: Int64 => x}) ~> f // The same as { x: Int64 => f({x: Int64 => x}(x)) }"}
{"text": "Cangjie programming language syntax:\nA composition expression represents the combination of two single-argument functions. The syntax of a composition expression is as follows: f ~> g. It is equivalent to the following form: { x => g(f(x)) }.\nAmong them, f and g are expressions of function types that take only one parameter.\nWhen f and g are combined, it is required that the return type of f(x) is a subtype of the parameter type of g(...).Example 3:\n\nfunc h1<T>(x: T): T { x }\nfunc h2<T>(x: T): T { x }\nvar hh = h1<Int64> ~> h2<Int64> // The same as { x: Int64 => h2<Int64>(h1<Int64>(x)) }"}
{"text": "Cangjie programming language syntax:\nAdditionally, stream operators cannot be used directly with named parameters functions that do not have default values, because named parameters functions without default values must be called with named arguments. For example:\n\nError_case:\nfunc f(a!: Int64): Unit {}\n\nvar a = 1 |> f  // Error"}
{"text": "Cangjie programming language syntax:\nAdditionally, stream operators cannot be used directly with named parameters functions that do not have default values, because named parameters functions without default values must be called with named arguments. If needed, users can pass named arguments for the f function through a lambda expression:func f(a!: Int64): Unit {}\n\nvar x = 1 |>  { x: Int64 => f(a: x) } // Ok"}
{"text": "Cangjie programming language syntax:\nAdditionally, stream operators cannot be used directly with named parameters functions that do not have default values, because named parameters functions without default values must be called with named arguments. \nFor the same reason, it is also incorrect to use directly with stream operators when the parameters of f have default values, for example:\n\nError_case:\nfunc f(a!: Int64 = 2): Unit {}\nvar a = 1 |> f // Error"}
{"text": "Cangjie programming language syntax:\nAdditionally, stream operators cannot be used directly with named parameters functions that do not have default values, because named parameters functions without default values must be called with named arguments. \nHowever, when all named parameters have default values, the function can be called without providing named arguments, only non-named arguments need to be passed. Such functions can be used together with stream operators, for example:func f(a: Int64, b!: Int64 = 2): Unit {}\n\n\nvar a = 1 |> f  // Ok"}
{"text": "Cangjie programming language syntax:\nAdditionally, stream operators cannot be used directly with named parameters functions that do not have default values, because named parameters functions without default values must be called with named arguments. \nOf course, if you want to pass additional parameters to argument b when calling f, you also need to use a lambda expression:func f(a: Int64, b!: Int64 = 2): Unit {}\n\n\nvar a = 1 |> {x: Int64 => f(x,  b: 3)}  // Ok"}
{"text": "Cangjie programming language syntax:\nVariable-length parameters are a special function call syntax sugar. When the last non-named parameter of the formal parameter is of Array type, the corresponding position in the actual parameter can directly pass a parameter sequence instead of an Array literal (the number of parameters can be 0 or more). For example:func sum(arr: Array<Int64>) {\n    var total = 0\n    for (x in arr) {\n        total += x\n    }\n    return total\n}\n\n\nmain() {\n    println(sum())\n    println(sum(1, 2, 3))\n}"}
{"text": "Cangjie programming language syntax:\nNote that only the last non-named parameter can be used as a variadic parameter; named parameters cannot use this syntactic sugar.func length(arr!: Array<Int64>) {\n    return arr.size\n}\n\n\nmain() {\n    println(length())        // Error, expected 1 argument, found 0\n    println(length(1, 2, 3)) // Error, expected 1 argument, found 3\n}"}
{"text": "Cangjie programming language syntax:\nVariable-length parameters can appear at the call sites of global functions, static member functions, instance member functions, local functions, constructors, function variables, lambdas, function call operator overloads, and index operator overloads. Other operator overloads, composition, and pipeline call methods are not supported. Examples are as follows:class Counter {\n    var total = 0\n    init(data: Array<Int64>) { total = data.size }\n    operator func ()(data: Array<Int64>) { total += data.size }\n}\n\n\nmain() {\n    let counter = Counter(1, 2)\n    println(counter.total)\n    counter(3, 4, 5)\n    println(counter.total)\n}"}
{"text": "Cangjie programming language syntax:\nFunction overload resolution always prioritizes functions that can match without using variable-length parameters. It only attempts to use variable-length parameter parsing when all functions cannot match. For example:func f<T>(x: T) where T <: ToString {\n    println(\"item: ${x}\")\n}\n\n\nfunc f(arr: Array<Int64>) {\n    println(\"array: ${arr}\")\n}\n\n\nmain() {\n    f()\n    f(1)\n    f(1, 2)\n}"}
{"text": "Cangjie programming language syntax:\nIn the Changjie programming language, when multiple function definitions correspond to a single function name within a scope, this phenomenon is known as function overloading.\nFunctions with the same name but different function parameters (meaning different number of parameters, or the same number of parameters but different parameter types) constitute overloading. Examples are as follows:// Scenario 1\nfunc f(a: Int64): Unit {\n}\n\nfunc f(a: Float64): Unit {\n}\n\nfunc f(a: Int64, b: Float64): Unit {\n}"}
{"text": "Cangjie programming language syntax:\nIn the Changjie programming language, when multiple function definitions correspond to a single function name within a scope, this phenomenon is known as function overloading.\nFor two generic functions with the same name (see Generic Functions section), if renaming the generic parameter of one function results in the same order of generic parameters, and their non-generic parts differ in function parameters from another function, the two functions constitute overloading. Otherwise, these two generic functions constitute a redefinition error (type parameter constraints are not involved in the judgment). Examples are as follows:interface I1{}\ninterface I2{}\n\n\nfunc f1<X, Y>(a: X, b: Y) {}\nfunc f1<Y, X>(a: X, b: Y) {} // Ok: after rename generic type parameter, it will be 'func f1<X, Y>(a: Y, b: X)'\n\n\nfunc f2<T>(a: T) where T <: I1 {}\nfunc f2<T>(a: T) where T <: I2 {} // Error, not overloading"}
{"text": "Cangjie programming language syntax:\nIn the Changjie programming language, when multiple function definitions correspond to a single function name within a scope, this phenomenon is known as function overloading.\nTwo constructors within the same class with different parameters constitute overloading. Examples are as follows:// Scenario 2\nclass C {\n    var a: Int64\n    var b: Float64\n\n\n    public init(a: Int64, b: Float64) {\n        this.a = a\n        this.b = b\n    }\n\n\n    public init(a: Int64) {\n        b = 0.0\n        this.a = a\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn the Changjie programming language, when multiple function definitions correspond to a single function name within a scope, this phenomenon is known as function overloading.\nThe main constructor and init constructor within the same class with different parameters constitute overloading (considering the main constructor and init function to have the same name). Examples are as follows:// Scenario 3\nclass C {\n    C(var a!: Int64, var b!: Float64) {\n        this.a = a\n        this.b = b\n    }\n\n\n    public init(a: Int64) {\n        b = 0.0\n        this.a = a\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn the Changjie programming language, when multiple function definitions correspond to a single function name within a scope, this phenomenon is known as function overloading.\nTwo functions with the same name but different parameters are defined in different scopes, and constitute overloading in the scope where both functions are visible. Example as follows:// Scenario 4\nfunc f(a: Int64): Unit {\n}\n\n\nfunc g() {\n    func f(a: Float64): Unit {\n    }\n}"}
{"text": "Cangjie programming language syntax:\nIn the Changjie programming language, when multiple function definitions correspond to a single function name within a scope, this phenomenon is known as function overloading.\nIf a function with the same name as the parent class exists in the subclass, and the parameter types of the function are different, it constitutes function overloading. Example as follows:// Scenario 5\nopen class Base {\n    public func f(a: Int64): Unit {\n    }\n}\n\n\nclass Sub <: Base {\n    public func f(a: Float64): Unit {\n    }\n}"}
{"text": "Cangjie programming language syntax:\nOnly function overloading introduced by function declarations is allowed, but the following cases do not constitute overloading. The two names that do not constitute overloading cannot be defined or declared in the same scope:\nStatic member functions and instance member functions of class, interface, and struct types cannot be overloaded;\nConstructors, static member functions, and instance member functions of enum type cannot be overloaded.\nAs shown in the following example, both variables are of function type with different parameter types, but since they are not function declarations, they cannot be overloaded. The following example will result in a compilation error (redefinition error):main() {\n    var f: (Int64) -> Unit\n    var f: (Float64) -> Unit\n}"}
{"text": "Cangjie programming language syntax:\nOnly function overloading introduced by function declarations is allowed, but the following cases do not constitute overloading. The two names that do not constitute overloading cannot be defined or declared in the same scope:\nStatic member functions and instance member functions of class, interface, and struct types cannot be overloaded;\nConstructors, static member functions, and instance member functions of enum type cannot be overloaded.\nAs shown in the following example, although the variable f is of function type, since variables and functions cannot have the same name, the following example will result in a compilation error (redefinition error):\n\nError_case:\nmain() {\n    var f: (Int64) -> Unit\n\n\n    func f(a: Float64): Unit {   // Error, functions and variables cannot have the same name.\n    }\n}"}
{"text": "Cangjie programming language syntax:\nOnly function overloading introduced by function declarations is allowed, but the following cases do not constitute overloading. The two names that do not constitute overloading cannot be defined or declared in the same scope:\nStatic member functions and instance member functions of class, interface, and struct types cannot be overloaded;\nConstructors, static member functions, and instance member functions of enum type cannot be overloaded.\nAs shown in the example, the static member function f and the instance member function f have different parameter types, but since static member functions and instance member functions within a class cannot be overloaded, the example below will result in a compilation error:\n\nError_case:\nclass C {\n    public static func f(a: Int64): Unit {\n    }\n    public func f(a: Float64): Unit {\n    }\n}"}
{"text": "Cangjie programming language syntax:\nWhen a function is called, all callable functions (those visible in the current scope and pass type checking) form the candidate set. With multiple functions in the candidate set, determining which function to choose requires function overload resolution, which follows these rules:\nPrefer the function within the scope with the higher scope level. In nested expressions or functions, the innermost scope has the highest level.\nIn the following example, when calling g(Sub()) inside the inner function body, the candidate set includes the function g defined within the inner function and the function g defined outside the inner function. Function resolution selects the function g defined within the inner function, as it has the higher scope level.open class Base {}\nclass Sub <: Base {}\n\n\nfunc outer() {\n    func g(a: Sub) {\n        print(\"1\")\n    }\n\n\n    func inner() {\n        func g(a: Base) {\n            print(\"2\")\n        }\n\n\n        g(Sub())   // Output: 2\n    }\n}"}
{"text": "Cangjie programming language syntax:\nWhen a function is called, all callable functions (those visible in the current scope and pass type checking) form the candidate set. With multiple functions in the candidate set, determining which function to choose requires function overload resolution, which follows these rules:\nIf there are multiple functions at the highest scope level, the most matching function needs to be selected (for functions f and g as well as given arguments, if f can be called when g can always be called but not vice versa, then f is considered more matching than g). If there is no uniquely most matching function, an error is reported.\nIn the following example, two functions g are defined in the same scope, select the more matching function g(a: Sub): Unit.open class Base {}\nclass Sub <: Base {}\n\n\nfunc outer() {\n    func g(a: Sub) {\n        print(\"1\")\n    }\n    func g(a: Base) {\n        print(\"2\")\n    }\n\n\n    g(Sub())   // Output: 1\n\n\n}"}
{"text": "Cangjie programming language syntax:\nWhen a function is called, all callable functions (those visible in the current scope and pass type checking) form the candidate set. With multiple functions in the candidate set, determining which function to choose requires function overload resolution, which follows these rules:\nSubclasses and parent classes are considered to be in the same scope. In the example below, one function `g` is defined in the parent class, and another function `g` is defined in the subclass. When calling `s.g(Sub())`, both functions `g` are resolved at the same scope level, and the more matching function `g(a: Sub): Unit` defined in the parent class is selected.open class Base {\n    public func g(a: Sub) { print(\"1\") }\n}\n\n\nclass Sub <: Base {\n    public func g(a: Base) {\n        print(\"2\")\n    }\n}\n\n\nfunc outer() {\n    let s: Sub = Sub()\n    s.g(Sub())   // Output: 1\n}"}
{"text": "Cangjie programming language syntax:\nImplement a function that negates the two member variables x and y in a Point instance, then returns a new Point object. + Implement a function that calculates the sum of x and y in two Point instances separately, then returns a new Point object.Next, you can directly use the unary - operator and binary + operator on Point instances:open class Point {\n    var x: Int64 = 0\n    var y: Int64 = 0\n    public init (a: Int64, b: Int64) {\n        x = a\n        y = b\n    }\n\n\n    public operator func -(): Point {\n        Point(-x, -y)\n    }\n    public operator func +(right: Point): Point {\n        Point(this.x + right.x, this.y + right.y)\n    }\n}\nmain() {\n    let p1 = Point(8, 24)\n    let p2 = -p1      // p2 = Point(-8, -24)\n    let p3 = p1 + p2  // p3 = Point(0, 0)\n}"}
{"text": "Cangjie programming language syntax:\nThe index operator ([]) has two forms: getting a value let a = arr[i] and assignment arr[i] = a. They are distinguished by the presence or absence of a special named parameter value. Index operator overloading does not require both forms to be overloaded simultaneously. You can overload assignment without overloading getting, or vice versa.\nThe getting form of the index operator [] inside the parameter sequence corresponds to the non-named parameters of the operator overloading, which can be 1 or more, and can be of any type. There should be no other named parameters. The return type can be of any type.class A {\n    operator func [](arg1: Int64, arg2: String): Int64 {\n        return 0\n    }\n}\n\n\nfunc f() {\n    let a = A()\n    let b: Int64 = a[1, \"2\"]\n    // b == 0\n}"}
{"text": "Cangjie programming language syntax:\nIndex operator assignment form, the parameter sequence inside the [] corresponds to the non-named parameters of operator overloading, which can be one or more and can be of any type. The expression on the right side of = corresponds to the named parameter of operator overloading, which must have exactly one named parameter. The name of this named parameter must be value, it cannot have a default value, and value can be of any type. The return type must be Unit type.It should be noted that value is only a special marker, and named parameters do not need to be used in the form of index operator assignment.\nParticularly, immutable types other than enum do not support overloading index operator assignment form.class A {\n    operator func [](arg1: Int64, arg2: String, value!: Int64): Unit {\n        return\n    }\n}\n\n\nfunc f() {\n    let a = A()\n    a[1, \"2\"] = 0\n}"}
{"text": "Cangjie programming language syntax:\nFunction call operator (()) overloads a function, the input parameter and return value types can be of any type. For example:open class A {\n    public init() {}\n\n\n    public operator func ()(): Unit {}\n}\n\n\nfunc test1() {\n    let a = A() // Ok, A() is call the constructor of A.\n    a() // Ok, a() is to call the operator () overloading function.\n}"}
{"text": "Cangjie programming language syntax:\nCannot use `this` or `super` to call () operator overloading functions. Example as follows:\n\nError_case:\nopen class A {\n    public init() {}\n    public init(x: Int64) {\n        this() // Ok, this() calls the constructor of A.\n    }\n\n\n    public operator func ()(): Unit {}\n\n\n    public func foo() {\n        this()  // Error, this() calls the constructor of A.\n        super() // Error\n    }\n}\n\n\nclass B <: A {\n    public init() {\n        super() // Ok, super()  calls the constructor of the super class.\n    }\n\n\n    public func goo() {\n        super() // Error\n    }\n}"}
{"text": "Cangjie programming language syntax:\nFor enumeration types, when both the constructor form and the () operator overload function form are satisfied, the constructor form is prioritized. For example:enum E {\n    Y | X | X(Int64)\n\n\n    public operator func ()(p: Int64) {}\n    public operator func ()(p: Float64) {}\n}\n\n\nmain() {\n    let e = X(1) // Ok, X(1) is to call the constructor X(Int64).\n    X(1.0) // Ok, X(1.0) is to call the operator () overloading function.\n    let e1 = X\n    e1(1) // Ok, e1(1) is to call the operator () overloading function.\n    Y(1) // oK, Y(1) is to call the operator () overloading function.\n}"}
{"text": "Cangjie programming language syntax:\nConstant evaluation allows certain specific forms of expressions to be evaluated at compile time, which can reduce the amount of computation needed at runtime. \nconst variables can omit type annotations but cannot omit initialization expressions. const variables can be global variables, local variables, or static member variables. However, const variables cannot be defined in extensions. const variables can access all instance members of their corresponding type and can also call all non mut instance member functions of their corresponding type.\nThe following example defines a struct that records the mass and radius of a planet, and defines a const member function gravity to calculate the gravitational force exerted by the planet on an object with mass m at a distance r:struct Planet {\n    const Planet(let mass: Float64, let radius: Float64) {}\n\n\n    const func gravity(m: Float64, r: Float64) {\n        G * mass * m / r**2\n    }\n}\n\n\nmain() {\n    const myMass = 71.0\n    const earth = Planet(5.972e24, 6.378e6)\n    println(earth.gravity(myMass, earth.radius))\n}"}
{"text": "Cangjie programming language syntax:\nconst variables, after initialization, make all members of the type instance const (deep const, including members of members), and thus cannot be used as lvalues.\n\nError_case:\nmain() {\n    const myMass = 71.0\n    myMass = 70.0 // Error, cannot assign to immutable value\n}"}
{"text": "Cangjie programming language syntax:\nconst functions are a special type of function that possess the ability to be evaluated at compile time. When called in a const context, these functions execute their computations at compile time. In other non-const contexts, const functions behave like regular functions and execute at runtime.\nBelow is an example of a const function that calculates the distance between two points in a plane. The function `distance` uses `let` to define two local variables, `dx` and `dy`:struct Point {\n    const Point(let x: Float64, let y: Float64) {}\n}\n\n\nconst func distance(a: Point, b: Point) {\n    let dx = a.x - b.x\n    let dy = a.y - b.y\n    (dx**2 + dy**2)**0.5\n}\n\n\nmain() {\n    const a = Point(3.0, 0.0)\n    const b = Point(0.0, 4.0)\n    const d = distance(a, b)\n    println(d)\n}"}
{"text": "Cangjie programming language syntax:\nAdditionally, const functions can also be defined in interfaces.\nIn interfaces, for a function to implement an interface, its implementation must also be a const function.\nNon-const functions in the interface are considered to implement the interface whether they use const or non-const functions.\nConst functions in the interface are the same as static functions of the interface. Only when the interface is used as a generic constraint can the constrained generic parameters or variables use these const functions.\nIn the following example, two const functions are defined in the interface I. Class A implements the interface I, and the upper bound of the parameter type of the generic function g is I.interface I {\n    const func f(): Int64\n    const static func f2(): Int64\n}\n\n\nclass A <: I {\n    public const func f() { 0 }\n    public const static func f2() { 1 }\n    const init() {}\n}\n\n\nconst func g<T>(i: T) where T <: I {\n    return i.f() + T.f2()\n}\n\n\nmain() {\n    println(g(A()))\n}"}
