{"text": "'Cangjie programming language_api_encoding_encoding_module_overview': 'When using Cangjie Code API, The encoding module provides character encoding and decoding capabilities, supporting Base64, Hex, JSON, and URL formats.'"}
{"text": "'Cangjie programming language_api_encoding_encoding_module_overview': 'When using Cangjie Code API, The encoding module provides character encoding and decoding capabilities, supporting Base64, Hex, JSON, and URL formats.\nBase64 encoding converts binary data into a text format consisting of only 64 printable characters (A-Z, a-z, 0-9, +, /), which enables binary data to be securely transmitted and stored in a text environment.\nAPI list：\nThe name of the function\t  function\nfromBase64String(String)\t  Used for the decoding of Base64-encoded strings.\ntoBase64String(Array<Byte>)\tUsed to convert an array of characters into a Base64-encoded string.'\n\nCode_Example:\nimport encoding.base64.*\nmain(): Int64 {\n    var arr = Array<Byte>([77, 97, 110])\n    var str = toBase64String(arr)\n    print(\"${str},\")\n    var opArr: Option<Array<Byte>> = fromBase64String(str)\n    var arr2: Array<Byte> = match (opArr) {\n        case Some(s) => s\n        case None => Array<Byte>()\n    }\n    for (i in 0..arr2.size) {\n        print(\"${arr2[i]},\")\n    }\n    return 0\n}"}
{"text": "'Cangjie programming language_api_encoding_encoding_hex_package': 'When using Cangjie Code API, The hex package provides Hex encoding and decoding for strings.\nHex encoding (also known as hexadecimal encoding) is an encoding method that converts data into a hexadecimal representation. Hex encoding uses 16 characters to represent data, which are numbers 0-9 and letters from A-F (case-insensitive, i.e., A-F and A-F are equivalent).\n The name of the function\t  function\nfromHexString(String)\t  Used for the decoding of Hex-encoded strings.\ntoHexString(Array<Byte>)\t  Used to convert an array of characters into a Hex-encoded string.'\n\nCode_Example:\nimport encoding.hex.*\nmain(): Int64 {\n    var arr = Array<Byte>([65, 66, 94, 97])\n    var str = toHexString(arr)\n    print(\"${str},\")\n    var opArr: Option<Array<Byte>> = fromHexString(str)\n    var arr2: Array<Byte> = match (opArr) {\n        case Some(s) => s\n        case None => Array<Byte>()\n    }\n    for (i in 0..arr2.size) {\n        print(\"${arr2[i]},\")\n    }\n    return 0\n}"}
{"text": "'Cangjie programming language_api_encoding_encoding_json_package': 'When using Cangjie Code API, The json package provides functionalities for processing JSON data, including conversions between String, JsonValue, and DataModel.\nJsonValue is an encapsulation of JSON data formats, including object, array, string, number, true, false, and null.\nFor more information about the DataModel, please refer to the serialization package documentation.\nFor more information about JSON syntax rules, see Introduction to JSON.\n interface：\nThe name of the interface\t  function\nToJson\tIt is used to convert JsonValue and DataModel to and from each other.\n\nClass name\t  function\nJsonArray\t  Create an empty JsonArray.\nJsonBool\tEncapsulate the specified Bool type instance as a JsonBool instance.\nJsonFloat\tEncapsulate the specified Float64 instance as a JsonFloat instance.\nJsonInt\tEncapsulate the specified Int64 instance into a JsonInt instance.\nJsonNull\t  Convert JsonNull to a string.\nJsonObject\t  Create an empty JsonObject.\nJsonString\tEncapsulate the specified String type instance into a JsonString instance.\nJsonValue\tThis class is the JSON data layer, which is mainly used for converting between JsonValue and String data.'\n\nCode_Example:\nimport encoding.json.*\nimport std.collection.*\n\n\nmain() {\n    var a: JsonValue = JsonNull()\n    var b: JsonValue = JsonBool(true)\n    var c: JsonValue = JsonBool(false)\n    var d: JsonValue = JsonInt(7363)\n    var e: JsonValue = JsonFloat(736423.546)\n    var list: ArrayList<JsonValue> = ArrayList<JsonValue>()\n    var list2: ArrayList<JsonValue> = ArrayList<JsonValue>()\n    var map = JsonObject()\n    var map1 = JsonObject()\n    map1.put(\"a\", JsonString(\"jjjjjj\"))\n    map1.put(\"b\", b)\n    map1.put(\"c\", JsonString(\"hhhhh\"))\n    list2.append(b)\n    list2.append(JsonInt(3333333))\n    list2.append(map1)\n    list2.append(JsonString(\"sdfghgfasd\"))\n    list.append(b)\n    list.append(a)\n    list.append(map)\n    list.append(c)\n    list.append(JsonArray(list2))\n    list.append(d)\n    list.append(JsonString(\"ddddddd\"))\n    list.append(e)\n    var result: JsonValue = JsonArray(list)\n    println(\"func toString result is:\")\n    println(result.toString())\n    println(\"func toJsonString result is:\")\n    println(result.toJsonString())\n    0\n}"}
{"text": "'Cangjie programming language_api_encoding_encoding_json_stream_package': 'When using Cangjie Code API, The json.stream package provides functionalities for converting between Cangjie objects and JSON streams.\nThe following types of data flow interchange are supported in the current implementation:\nbasic data:String、Int8、Int16、Int32、Int64、Float16、Float32、Float64、UInt8、UInt16、UInt32、UInt64。\nCollection type<T>: Array, ArrayList<T>, HashMap< String, T>\nOther types: Option<T>, BigInt, Decimal.\n\n interface：\nThe name of the interface\t  function\nJsonDeserializable<T>\tThis interface is used to implement reading a Cangjie object from JsonReader.\nJsonSerializable\t  Provides an interface for types to serialize into JSON data streams.\n\n Class name\t  function\nJsonReader\tThis class provides the ability to deserialize JSON data flow to Cangjie objects.\nJsonWriter\t  constructor to construct an instance that writes data out.'\n\nCode_Example:\nimport encoding.json.stream.*\nimport std.io.*\nimport std.collection.*\nclass A <: JsonDeserializable<A> {\n    var key1: Option<String> = None\n    var key2: Bool = false\n    var key3: Float64 = 0.0\n    var key4: String = \"\"\n    var key5: Array<Int64> = Array<Int64>()\n    var key6: HashMap<String, String> = HashMap<String, String>()\n\n    public static func fromJson(r: JsonReader): A {\n        var res = A()\n        while (let Some(v) <- r.peek()) {\n            match(v) {\n                case BeginObject =>\n                    r.startObject()\n                    while(r.peek() != EndObject) {\n                        let n = r.readName()\n                        match (n) {\n                            case \"key1\" => res.key1 = r.readValue<Option<String>>()\n                            case \"key2\" => res.key2 = r.readValue<Bool>()\n                            case \"key3\" => res.key3 = r.readValue<Float64>()\n                            case \"key4\" => res.key4 = r.readValue<String>()\n                            case \"key5\" => res.key5 = r.readValue<Array<Int64>>()\n                            case \"key6\" => res.key6 = r.readValue<HashMap<String, String>>()\n                            case _ => ()\n                        }\n                    }\n                    r.endObject()\n                    break\n                case _ => throw Exception()\n            }\n        }\n        return res\n    }\n\n\n    func toString(): String {\n        return \"${key1}\\n${key2}\\n${key3}\\n${key4}\\n${key5}\\n${key6}\"\n    }\n}\n\nmain() {\n    let jsonStr = ##\"{\"key1\": null, \"key2\": true, \"key3\": 123.456, \"key4\": \"string\", \"key5\": [123, 456], \"key6\": {\"key7\": \" \", \"key8\": \"\\\\a\"}}\"##\n    var bas = ByteArrayStream()\n    unsafe { bas.write(jsonStr.rawData()) }\n    var reader = JsonReader(bas)\n    var obj = A.fromJson(reader)\n    println(obj.toString())\n}"}
{"text": "'Cangjie programming language_api_encoding_encoding_url_package': 'When using Cangjie Code API, The url package provides functionalities for working with URLs, including parsing URL components, encoding and decoding URLs, and merging URLs or paths.\nURL (Uniform Resource Locator) is an abbreviation for Uniform Resource Locator, which is an address used to identify the location of resources on the Internet. The protocol refers to the protocol used to access the resource (such as HTTP, FTP, etc.), the hostname refers to the domain name or IP address of the server where the resource is located, the path refers to the specific location where the resource is located, and the query parameter refers to the string used to pass the parameters. URLs are the only way to identify resources on the Internet, and various types of resources such as web pages, pictures, and videos can be accessed through URLs.\n\n URLs are typically in the following format:scheme://host[:port]/path[?query][#fragment]\n\nThereinto:\nScheme: protocols, such as HTTP, HTTPS, FTP, etc.\n  host: hostname or IP address;\n  port: port number, optional, default is the default port of the protocol;\npath: the path of the resource, for example, /index.html, /blog/post/123, etc.\nquery: query parameters, such as ?page=2&sort=desc, optional.\nfragment: Document fragment identifier, e.g. #section-1, optional.\n\n Class name\t  function\nForm\tForm stores the parameters of http requests in the form of key-value pairs, the same key can correspond to multiple values, and the value is stored in the form of arrays.\nURL\t  This class provides functions for parsing URLs and other related functions.\nUserInfo\tUserInfo represents the username and password information in the URL.'\n\nCode_Example:\nimport encoding.url.*\nmain(): Int64 {\n    var s = Form(\"1=2&2=3&1=2&&\")\n    print(s.get(\"1\").getOrThrow())\n    return 0\n}"}
