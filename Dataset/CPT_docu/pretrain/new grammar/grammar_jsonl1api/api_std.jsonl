{"text": "'Cangjie programming language_api_std_std_module_overview': 'When using Cangjie Code API, The std module is the standard library that provides a set of predefined functions, classes, and structures to offer common functionalities and tools for developers to write programs more quickly and efficiently.\nThe `std` module refers to the standard library, which is a set of pre-defined functions, classes, structs, etc., in a programming language, designed to provide common functionalities and tools to enable developers to write programs more quickly and efficiently.\nThe capabilities provided by the Changjie standard library include (but are not limited to):\n Input and output: console input/output, file input/output, etc.\n Data structures: arrays, linked lists, hash tables, etc.\n Algorithms: sorting, summation, exponentiation, logarithms, etc.\nDate and time: getting time, formatting time, setting timed tasks, etc.\n Concurrency programming: locks, atomic operations, etc.'"}
{"text": "'Cangjie programming language_api_std_std_core': 'When using Cangjie Code API, The core package is the fundamental package of the standard library, providing the most basic API capabilities for Cangjie language programming.\nProvides built-in types (signed integers, unsigned integers, floating-point types, etc.), common functions (print, println, eprint, etc.), common interfaces (ToString, Hashable, Equatable, Collection, etc.), common classes and structs (Array, String, Range, etc.), and common exception classes (Error, Exception, and some of their subclasses).\nThe core package is imported by default and does not require explicit import.'"}
{"text": "'Cangjie programming language_api_std_std_argopt': 'When using Cangjie Code API, The argopt package provides capabilities for parsing command-line argument strings into argument names and values.\nCommand-line arguments are parameters passed to a program in the command line, used to specify the program's configuration or behavior. For example, a command-line program might have an argument to specify the name of the file it is to process, or an argument to specify the database to be used. These parameters are typically parsed and passed to the program's code so that the program can execute its functionality correctly based on these parameters.\nCommand-line arguments are divided into short command-line arguments and long command-line arguments, distinguished by their length and readability. Short command-line arguments are usually composed of a single letter and are easy to remember; long command-line arguments are typically made up of one or more words and are easy to understand.\nAPI List：（Class name）ArgOpt\nArgOpt is used to parse command line arguments and provides functionality to retrieve the parsing results.\nclass Argopt\ninit(Array<String>)\ninit(Array<String>, String, Array<String>)\ninit(String[], String, String[])\ninit(String)\ninit(String, Array<String>)\nfunc getArg(String)\nfunc getArgumentsMap()\nfunc getUnparseArgs()'\n\nCode_Example:\npublic class ArgOpt {\n    public init(shortArgFormat: String)\n    public init(longArgList: Array<String>)\n    public init(shortArgFormat: String, longArgList: Array<String>)\n    public init(args: Array<String>, shortArgFormat: String, longArgList: Array<String>)\n}"}
{"text": "'Cangjie programming language_api_std_std_ast': 'When using Cangjie Code API, The ast package contains the Cangjie source code syntax parser and Cangjie syntax tree nodes, providing syntax parsing functions.\nThe Cangjie `ast` package provides related functions for Macro With Context, used to obtain context-related information during macro expansion. In nested macro scenarios, inner macros can call the library function `assertParentContext(String)` to ensure that the inner macro call is definitely nested within a specific outer macro call. If the inner macro calls this function without being nested within the given outer macro call, the function will throw an error. Additionally, the function `insideParentContext(String)` is also used to check whether the inner macro call is nested within a specific outer macro call, but it returns a boolean value. Related functions for Macro With Context can only be called directly as functions and cannot be assigned to variables, nor can they be used as actual parameters or return values.\n\nThe related functions for Macro With Context are as follows:\nassertParentContext(String)\n`assertParentContext(String)\ngetChildMessages(String)\ninsideParentContext(String)\nsetItem(String, Bool)\nsetItem(String, Int64)\nsetItem(String, String)'\n\nCode_Example:\nimport std.ast.*\nmain() {\nlet input: Tokens = quote(\nclass Data {\nvar a: Int32\ninit(a_: Int32) {\na = a_\n}\n}\n)\nlet decl = parseDecl(input) // Get a Decl declaration\nvar classDecl = match (decl as ClassDecl) {// decl's concrete type is ClassDecl, cast it.\ncase Some(v) => v\ncase None => throw Exception()\n}\nvar identifier = classDecl.identifier\n// Add a member function to get the value of a\nvar funcdecl = FuncDecl(quote(func getValue() {a}))\nclassDecl.body.decls.append(funcdecl)\nprintln(\"Identifier value is ${identifier.value}\")\nprintln(\"ClassDecl body size is ${classDecl.body.decls.size}\")\n0\n}"}
{"text": "'Cangjie programming language_api_std_std_binary': 'When using Cangjie Code API, The binary package provides interfaces for converting basic data types to and from byte arrays with different endianness, as well as endianness reversal interfaces.\nThe current binary package provides the following functionalities:\nInterface for converting between Cangjie data types and binary byte sequences, divided into big-endian and little-endian conversion types.\nInterface for self-endian conversion of Xianxie data types.\nAPI List：\nInterface name\tFunction\nBigEndianOrder<T>\t\tBig-endian byte sequence conversion interface.\nLittleEndianOrder<T>\tLittle-endian byte sequence conversion interface.\nSwapEndianOrder<T>\tByte order reversal interface.\n\nfunction list：\ninterface BigEndianOrder<T>：\nstatic func readBigEndian(Array<Byte>)\nfunc writeBigEndian(Array<Byte>)\nextend Bool <: BigEndianOrder<Bool>\nextend Float16 <: BigEndianOrder<Float16>\nextend Float32 <: BigEndianOrder<Float32>\nextend Float64 <: BigEndianOrder<Float64>\nextend Int16 <: BigEndianOrder<Int16>\nextend Int32 <: BigEndianOrder<Int32>\nextend Int64 <: BigEndianOrder<Int64>\nextend Int8 <: BigEndianOrder<Int8>\nextend UInt16 <: BigEndianOrder<UInt16>\nextend UInt32 <: BigEndianOrder<UInt32>\nextend UInt64 <: BigEndianOrder<UInt64>\nextend UInt8 <: BigEndianOrder<UInt8>\n\ninterface LittleEndianOrder<T>：\nstatic func readLittleEndian(Array<Byte>)\nfunc writeLittleEndian(Array<Byte>)\nextend Bool <: LittleEndianOrder<Bool>\nextend Float16 <: LittleEndianOrder<Float16>\nextend Float32 <: LittleEndianOrder<Float32>\nextend Float64 <: LittleEndianOrder<Float64>\nextend Int16 <: LittleEndianOrder<Int16>\nextend Int32 <: LittleEndianOrder<Int32>\nextend Int64 <: LittleEndianOrder<Int64>\nextend Int8 <: LittleEndianOrder<Int8>\nextend UInt16 <: LittleEndianOrder<UInt16>\nextend UInt32 <: LittleEndianOrder<UInt32>\nextend UInt64 <: LittleEndianOrder<UInt64>\nextend UInt8 <: LittleEndianOrder<UInt8>\n\ninterface SwapEndianOrder<T>：\nfunc swapBytes()\nextend Int16 <: SwapEndianOrder<Int16>\nextend Int32 <: SwapEndianOrder<Int32>\nextend Int64 <: SwapEndianOrder<Int64>\nextend Int8 <: SwapEndianOrder<Int8>\nextend UInt16 <: SwapEndianOrder<UInt16>\nextend UInt32 <: SwapEndianOrder<UInt32>\nextend UInt64 <: SwapEndianOrder<UInt64>\nextend UInt8 <: SwapEndianOrder<UInt8>'\n\nCode_Example:\nimport std.binary.*"}
{"text": "'Cangjie programming language_api_std_std_collection': 'When using Cangjie Code API, The collection package provides efficient implementations of common data structures, definitions of related abstract interfaces, and commonly used functions for collection types.\n This package implements the following common data structures:\n\nArrayList: A variable-length contiguous array, used when storing an uncertain number of data, or when dynamically adjusting the array size based on runtime conditions. Using ArrayList may lead to increased memory allocation and release overhead, so it should be used with caution.\n\nLinkedList: A linked list structure. The advantage of LinkedList is that it can dynamically add or remove elements without moving other elements. This makes it very useful in situations where elements need to be frequently added or removed. It can also easily perform modification or deletion operations and store multiple elements in the list. The disadvantage of LinkedList is that it requires additional memory to store references to each element, which may lead to memory waste.\n\nHashMap: A hash table that stores key-value pairs and allows for quick access to values based on keys. Used when mapping relationships are needed and quick lookups are required.\n\nHashSet: A collection data structure implemented based on a hash table, which can be used for fast retrieval and deletion of elements, featuring efficient insertion, deletion, and lookup operations.\n\nTreeMap: An ordered map implemented based on a red-black tree. Generally, when you need to sort elements according to natural order or a custom order, you can use TreeMap.\n\nAll collection types provided by the collection package do not support concurrency safety. For concurrent-safe collections, please see the collection.concurrent package.'\n\nCode_Example:\nimport std.collection.*"}
{"text": "'Cangjie programming language_api_std_std_collection_concurrent': 'When using Cangjie Code API, The collection.concurrent package provides implementations of thread-safe collection types.\n\n This package implements the following concurrent-safe collection types:\nArrayBlockingQueue: A bounded queue with fixed size implemented using an array.\nBlockingQueue: A thread-safe queue that supports blocking element retrieval when the queue is empty and blocking element addition when the queue is full.\nConcurrentHashMap: A thread-safe hash table implementation that supports high-concurrency read and write operations.\nNonBlockingQueue: A thread-safe queue data structure that features creating a new Block when the current tail Block is full upon adding elements, rather than blocking and waiting. This ensures that in a multi-threaded environment, queue operations do not cause thread blocking due to blocking, thus improving program performance.\n\nAPI List：\nInterface name\tFunction\nConcurrentMap<K, V> where K <: Equatable<K>\t A Map interface definition that guarantees thread safety and atomicity of operations.'\n\nCode_Example:\nimport std.collection.concurrent.*"}
{"text": "'Cangjie programming language_api_std_std_console': 'When using Cangjie Code API, The console package provides methods for interacting with standard input, output, and error.\nThis package provides the Console class, used to access these three standard streams：\nConsoleReader encapsulates the functionality related to the standard input stream and can read data from the standard input through its relevant read methods.\nConsoleWriter encapsulates the functionality related to the standard output and standard error streams. ConsoleWriter encapsulates a series of write methods, providing the ability to write data to the standard output and standard error.\n\nAPI List：\nClass name\tFunction\nConsole\t\nProvides interfaces to obtain the standard input, standard output, and standard error streams.\nConsoleReader\tProvides the functionality to read characters or strings from standard input.\nConsoleWriter\t\nProvides the functionality to write characters or strings to standard output or standard error stream.'\n\nCode_Example:\nimport std.console.*\nmain() {\nConsole.stdOut.write(\" Please enter message 1: \")\nvar c = Console.stdIn.readln() // Input: Hello, what day is it today?\nvar r = c.getOrThrow()\nConsole.stdOut.writeln(\" The input 1 is: \"+ r)\nConsole.stdOut.write(\" Please enter message 2: \")\nc = Console.stdIn.readln() // Input: Hello, what's the date today?\nr = c.getOrThrow()\nConsole.stdOut.writeln(\" The input 2 is: \"+ r)\nreturn\n}"}
{"text": "'Cangjie programming language_api_std_std_convert': 'When using Cangjie Code API, The convert package provides Convert series functions for converting strings to specific types.\n\nAPI List：\nInterface name\tFunction\nParsable<T>\tAn interface for parsing a string into a specific type.'\n\nCode_Example:\nimport std.convert.*\nmain():Int64 {\n    var strBool_parse : String = \"true\"\n    var strBool_tryParse : String = \"false\"\n    println(\"After the conversion of parse, \\\"true\\\" became ${Bool.parse(strBool_parse)}\")\n    println(\"After the conversion of tryParse, \\\"false\\\" became ${Bool.tryParse(strBool_tryParse)}\")"}
{"text": "'Cangjie programming language_api_std_std_crypto_cipher': 'When using Cangjie Code API, The crypto.cipher package provides a general interface for symmetric encryption and decryption.\nAPI List：\nInterface name\tFunction\nBlockCipher\tThis interface is a general interface for digest algorithms.'"}
{"text": "'Cangjie programming language_api_std_std_crypto_digest': 'When using Cangjie Code API, The crypto.digest package provides a general interface for common digest algorithms, including MD5, SHA1, SHA224, SHA256, SHA384, SHA512, HMAC, and SM3.\n\nAPI List：\nFunction：\nFunction Name\t Function\ndigest<T>(T, Array<Byte>) where T <: Digest\t\nIt provides the digest generic function to perform digest operations using the specified digest algorithm.\ndigest<T>(T, String) where T <: Digest\t\nProvide digest generic functions to perform digest operations using the specified summary algorithm.\n\nInterface：\nInterface name\tFunction\nDigest\tThis interface is a general interface for digest algorithms.'"}
{"text": "'Cangjie programming language_api_std_std_database_sql': 'When using Cangjie Code API, The database.sql package provides interfaces for accessing databases in Cangjie.'"}
{"text": "'Cangjie programming language_api_std_std_format': 'When using Cangjie Code API, The format package provides formatting capabilities, primarily for converting Cangjie type instances to formatted strings.\nWhen converting Rune types to strings, the string format can be specified according to formatting parameters, such as width, alignment, etc. (In the method defined in the Formatter interface, formatting parameters will be passed as function arguments).\nThe detailed syntax for formatting parameters is as follows:\nformat_spec := [flags][width][.precision][specifier]\nflags := '-' | '+' | '#' | '0'\nwidth := integer\nprecision := integer\nspecifier := 'b' | 'B' | 'o' | 'O' | 'x' | 'X' | 'e' | 'E' | 'g' | 'G''\n\nCode_Example:\nimport std.format.*\nmain() {\n    var c : Int32 = -20\n    print(\"\\\"${c.format(\"-10\")}\\\"\")\n}"}
{"text": "'Cangjie programming language_api_std_std_fs': 'When using Cangjie Code API, The fs package provides functions for operating on files, directories, paths, and file metadata.Currently supports use on Linux, macOS, and Windows platforms.\nThe std.fs package includes the following classes:\nClass name\t Function\nDirectory\t\nCorresponds to a directory in the file system, providing capabilities such as creation, moving, copying, deletion, querying attributes, and traversing directories.\nFile\t\nProvides some functions for file operations, including opening, creating, closing, moving, copying, and deleting files, as well as streaming read and write operations on files, querying attributes, and some other functions.'\n\nCode_Example:\nimport std.fs.*\n\nmain() {\n    let testDirPath: Path = Path(\"./testDir\")\n    let subDirPath: Path = Path(\"./testDir/subDir\")\n    if (Directory.exists(testDirPath)) {\n        Directory.delete(testDirPath, recursive: true)\n    }\n\n    /* Recursively create the directory and \"./testDir/subDir\" */\n    let subDir: Directory = Directory.create(subDirPath, recursive: true)\n    if (Directory.exists(subDirPath)) {\n        println(\"The directory './testDir/subDir' is successfully created recursively in current directory.\")\n    }\n\n   /* Create the subdirectory \"dir1\" under \"./testDir/subDir\" */\n    subDir.createSubDirectory(\"dir1\")\n    if (Directory.exists(\"./testDir/subDir/dir1\")) {\n        println(\"The directory 'dir1' is created successfully in directory './testDir/subDir'.\")\n    }\n\n    /* Create the subfile \"file1\" under \"./testDir/subDir\" */\n    subDir.createFile(\"file1\")\n    if (File.exists(\"./testDir/subDir/file1\")) {\n        println(\"The file 'file1' is created successfully in directory './testDir/subDir'.\")\n    }\n\n   /* Create a temporary directory under \"./testDir\" */\n    let tempDir: Directory = Directory.createTemp(testDirPath)\n    let tempDirPath: Path = tempDir.info.path\n    if (Directory.exists(tempDirPath)) {\n        println(\"The temporary directory is created successfully in directory './testDir'.\")\n    }\n\n    /* Move \"subDir\" to the temporary directory and rename it \"subDir_new\" */\n    let newSubDirPath: Path = tempDirPath.join(\"subDir_new\")\n    Directory.move(subDirPath, newSubDirPath, false)\n    if (Directory.exists(newSubDirPath) && !Directory.exists(subDirPath)) {\n        println(\"The directory './testDir/subDir' is moved successfully to the temporary directory and renamed 'subDir_new'.\")\n    }\n\n    /* Copy \"subDir_new\" to \"./testDir\" and rename it to \"subDir\" */\n    Directory.copy(newSubDirPath, subDirPath, false)\n    if (Directory.exists(subDirPath) && Directory.exists(newSubDirPath)) {\n        println(\"The directory 'subDir_new' is copied successfully to directory './testDir' and renamed 'subDir'.\")\n    }\n\n    Directory.delete(testDirPath, recursive: true)\n    return 0\n}"}
{"text": "'Cangjie programming language_api_std_std_io': 'When using Cangjie Code API, The io package provides capabilities for data exchange between programs and external devices.\nI/O operations refer to the operations by which a program exchanges data with external devices. Cangjie provides a general interface for stream-based I/O operations and some special implementations. Input/output streams are similar to a data channel, carrying an ordered sequence of data. Programs read data from input streams (from files, networks, etc.) and write data to output streams (to files, networks, \nInterface name\tFunction\nInputStream\tInput stream interface.\nIOStream\t\tInput/output stream interface.\nOutputStream\tOutput stream interface.\nSeekable\t\tCursor movement interface.\nClass ：\nClass name\tFunction\nBufferedInputStream<T> where T <: InputStream\t\tProvides a buffered input stream.\nBufferedOutputStream<T> where T <: OutputStream\tProvides a buffered output stream.\nByteArrayStream\tInput stream interface.\nChainedInputStream<T> where T <: InputStream\t\t\nProvides the ability to read data sequentially from an array of InputStreams.\nMultiOutputStream<T> where T <: OutputStream\t\t\nProvides the ability to write data to each output stream in an OutputStream array simultaneously.\nStringReader<T> where T <: InputStream\t\nProvides the ability to read data from an InputStream and convert it into characters or strings.\nStringWriter<T> where T <: OutputStream\t\nProvides the ability to convert Strings and some ToString types into strings with specified encoding format and byte order configuration, and write them to an output stream.'"}
{"text": "'Cangjie programming language_api_std_std_math': 'When using Cangjie Code API, The math package provides common mathematical operations, constant definitions, and floating-point number handling functions.\nIncludes the following capabilities:\n1.Definition of scientific and type constants;\n2.Judgment and regularization of floating-point numbers;\n3. Common bit operations;\n4.General mathematical functions, such as absolute value, trigonometric functions, exponentiation, and logarithmic calculations;\n5.Greatest common divisor and least common multiple.'"}
{"text": "'Cangjie programming language_api_std_std_math_numeric': 'When using Cangjie Code API, The math.numeric package provides extended capabilities beyond the range expressible by basic types.\nFor example:\nSupports BigInt (Big Integer);\nSupports high-precision decimal (Decimal) type;\nProvides common mathematical operations capabilities including high-precision operation rules.\n\nAPI List：\nFunction\nFunction Name\tFunction\nabs(BigInt)\tFind the absolute value of a BigInt.\nabs(Decimal)\tFind the absolute value of a Decimal.\nsqrt(BigInt)\tFind the arithmetic square root of BigInt, rounded down.\nsqrt(Decimal)\tFind the arithmetic square root of Decimal. When the result is an infinite decimal, the result is rounded using IEEE 754-2019 decimal128 by default.\ngcd(BigInt, BigInt)\t\nFind the greatest common divisor (GCD) of two BigInts. Always returns a non-negative number (equivalent to the GCD of absolute values).\nlcm(BigInt, BigInt)\t\nFind the least common multiple (LCM) of two BigInts. Returns 0 when the input parameters are 0, otherwise always returns a positive number (equivalent to the LCM of absolute values).\nmax(BigInt, BigInt)\tCompute and return the larger of the two BigInts.\nmin(BigInt, BigInt)\tCompute and return the smaller of the two BigInts.\ncountOne(BigInt)\tCount the number of 1s in the binary complement of the input BigInt.\nround(Decimal, RoundingMode)\t\nCalculate the rounded value of Decimal, rounding to the nearest integer based on the rounding mode.'"}
{"text": "'Cangjie programming language_api_std_std_objectpool': 'When using Cangjie Code API, The objectpool package provides functions for object caching and reuse.'"}
{"text": "'Cangjie programming language_api_std_std_os': 'When using Cangjie Code API, The os package provides capabilities for obtaining and manipulating information about the current process, such as process arguments, environment variables, directory information, registering callback functions, and exiting the current process.Currently, Linux, macOS, Windows and HarmonyOS are supported.\nList of APIs\nfunction：\nThe name of the function\t  function\t\tSupport Platforms\ncurrentDir()\t  Get the current working directory.\tLinux、Windows、macOS、HarmonyOS\nenvVars()\t  Get all environment variables.\tLinux、Windows、macOS、HarmonyOS\ngetArgs()\tReturns a list of command-line arguments, e.g. executing a.out ab cd ef in the command line, where a.out is the program name, and the returned list contains three elements, ab cd ef.\tLinux、Windows、macOS、HarmonyOS\ngetEnv(String)\t  Obtain the value of the environment variable with the specified name.\tLinux、Windows、macOS、HarmonyOS\nhomeDir()\t  Get the home directory.\tLinux、Windows、macOS\nprocessorCount()\t  Get the number of processors.\tLinux、Windows、macOS、HarmonyOS\nremoveEnv(String)\t  Remove environment variables by specifying their names.\tLinux、Windows、macOS、HarmonyOS\nsetEnv(String, String)\t  Used to set a pair of environment variables.\tLinux、Windows、macOS、HarmonyOS\ntempDir()\t  Get a temporary directory.\tLinux、Windows、macOS、HarmonyOS'"}
{"text": "'Cangjie programming language_api_std_std_os_posix': 'When using Cangjie Code API, The os.posix package primarily adapts POSIX system interfaces.This package provides multi-platform unified control capabilities, and currently supports Linux, macOS, Windows, and HarmonyOS platforms.'"}
{"text": "'Cangjie programming language_api_std_std_os_process': 'When using Cangjie Code API, The os.process package provides Process operation interfaces, including process creation, standard stream acquisition, process waiting, and process information queries.\nThis package provides multi-platform unified control capabilities, and currently supports Linux, macOS, Windows, and HarmonyOS platforms.\n List of APIs\n Class name\t  function\nCurrentProcess\tThis class is the current process class, inherits from the Process class, and provides functions related to the operation of the current process.\nProcess\t  This class is a process class that provides functions related to process operations.\nSubProcess\tThis class is a subprocess class, which inherits from the Process class and provides functions related to the operation of the subprocess.'\n\nCode_Example:\nimport std.os.process.*\n\nmain(): Int64 {\n    let curProcess = Process.current\n    println(curProcess.pid)\n    println(curProcess.name)\n    println(curProcess.command)\n    println(curProcess.arguments.toString())\n    println(curProcess.commandLine.toString())\n    println(curProcess.workingDirectory.toString())\n    curProcess.atExit(printText)\n    curProcess.exit(0)\n    return 0\n}\n\nfunc printText(): Unit {\n    println(\"hello cangjie!\")\n}"}
{"text": "'Cangjie programming language_api_std_std_overflow': 'When using Cangjie Code API, The overflow package provides capabilities for handling overflows.In integer arithmetic, an overflow occurs when the result is greater than the maximum value of its type or less than the minimum value of its type. By default, an exception is thrown when an overflow occurs.\n\nThe overflow package provides four overflow handling strategies and defines the corresponding interfaces, which are listed as follows:\n\n  tactics\t  interface\t  description\n  Return to Option\tCheckedOp\t  When an integer operation overflows, None is returned.\n  saturate\tSaturatingOp\tWhen the calculation result is greater than the MAX value of the target type, the MAX value is returned; When the calculation result is less than the MIN value of the target type, the MIN value is returned.\n  Throws an exception\tThrowingOp\t  When an integer operation overflows, an exception is thrown.\n  High-level truncation\tWrappingOp\tWhen an integer operation overflows, the high bits in the operation result that exceed the number of bits of the target type are truncated.\nThe overflow package provides implementations of these interfaces for all integer types by extension, and users can implement overflow interfaces for other types in the same way.\n\n  List of APIs\n  interface\n  The name of the interface\t  function\nCheckedOp\t  When an integer operation overflows, None is returned.\nSaturatingOp\t  When an integer operation overflows, saturation is processed.\nThrowingOp\t  When an integer operation overflows, an exception is thrown.\nWrappingOp\tWhen an integer operation overflows, the high bits in the operation result that exceed the number of bits of the target type are truncated.'"}
{"text": "'Cangjie programming language_api_std_std_random': 'When using Cangjie Code API, The random package provides capabilities for generating pseudo-random numbers.\nList of APIs\nClass name\t  function\nRandom\t  Provides the ability to generate pseudorandom numbers.\n| Function Name                                         | English Description                                                                                                                                           |\n| :---------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `prop seed`                                           | Set or get the seed value; if the same seed is set, the generated pseudo-random number sequence will be the same.                                             |\n| `init()`                                              | Default constructor to create a new Random object without parameters.                                                                                         |\n| `init(UInt64)`                                        | Create a new Random object using a specified seed value.                                                                                                      |\n| `func nextBool()`                                     | Obtain a pseudo-random Boolean value.                                                                                                                         |\n| `func nextGaussianFloat16(Float16, Float16)`          | Obtain a Gaussian-distributed random number of Float16 type with specified mean and standard deviation.                                                       |\n| `func nextGaussianFloat16Implement(Float16, Float16)` | Implementation function for `nextGaussianFloat16`, obtaining a Gaussian-distributed random number of Float16 type with specified mean and standard deviation. |\n| `func nextGaussianFloat32(Float32, Float32)`          | Obtain a Gaussian-distributed random number of Float32 type with specified mean and standard deviation.                                                       |\n| `func nextGaussianFloat32Implement(Float32, Float32)` | Implementation function for `nextGaussianFloat32`, obtaining a Gaussian-distributed random number of Float32 type with specified mean and standard deviation. |\n| `func nextGaussianFloat64(Float64, Float64)`          | Obtain a Gaussian-distributed random number of Float64 type with specified mean and standard deviation.                                                       |\n| `func nextGaussianFloat64Implement(Float64, Float64)` | Implementation function for `nextGaussianFloat64`, obtaining a Gaussian-distributed random number of Float64 type with specified mean and standard deviation. |\n| `func nextInt8()`                                     | Obtain a pseudo-random number of Int8 type.                                                                                                                   |'\n\nCode_Example:\nimport std.random.*\nmain() {\n    let m: Random = Random()\n    /* Create a Random object and set a seed to obtain the random object */\n    m.seed = 3\n    let b: Bool = m.nextBool()\n    let c: Int8 = m.nextInt8()\n    print(\"b=${b is Bool},\")/* Objects can also be of type Bool */\n    println(\"c=${c is Int8}\")\n    return 0\n}"}
{"text": "'Cangjie programming language_api_std_std_regex': 'When using Cangjie Code API, The regex package provides capabilities for analyzing and processing text using regular expressions (supports only Ascii encoded strings), including finding, splitting, replacing, and validating functions.\nregex rule set\nCurrently, the regular expression of Cangjie only supports the following rules, and using unsupported rules will cause the output to be inconsistent with expectations.\n  character\t  description\n\\\tMark the next character as a special character (File Format Escape, see this table for a list), or a literal character (Identity Escape, with ^$()*+?. [{|12 in total), or a backreferences. For example, \"n\" matches the character \"n\". \\nMatch a line break. The sequence \\matches\\, while (then matches (.\n^\tMatches the start position of the input string. If the multi-row mode multiLine() in RegexOption is set, ^ also matches the position after \\n or \\r.\n$\t  Matches the end position of the input string.\n*\tMatches the preceding subexpression zero or more times. For example, zo* matches z, zo, and zoo. *Equivalent to {0,}.\n+\tMatch the preceding subexpression one or more times. For example, zo+ can match zo and zoo, but not z. + is equivalent to {1,}.\n?\tMatch the preceding subexpression zero times or once. For example, do(es) can match do and does in does. Equivalent to {0,1}.\n{n}\tn is a non-negative integer. Matched the identified n times. For example, o{2} can't match the o in Bob, but it can match two o's in food.\n{n,}\tn is a non-negative integer. Match at least n times. For example, o{2,} can't match the o in Bob, but it can match all the o's in foooood. o{1,} is equivalent to o+. o{0,} is equivalent to o*.\n{n,m}\tm and n are both non-negative integers, where n<=m. Minimum match n times and maximum match m times. For example, o{1,3} will match the first three O's in fooooood. o{0,1} is equivalent to o?. Note that there can be no space between a comma and two numbers.\n?\tNon-greedy quantifiers: The matching pattern is non-greedy when the character is immediately followed by any of the other repeating modifiers (*, +,?,{n}, {n,}, {n,m}). The non-greedy mode matches as few strings as possible, while the default greedy mode matches as many strings as possible. For example, for the string oooo, O+?, which will match a single O, and O+, will match all O's.\n.\tMatches any single character except \\n. To match any character, including \\n, use a character like (.| \\n).\n(pattern)\tMatch the pattern and get the substring of that match. This substring is used for backward references. The resulting matches can be obtained from the resulting Matches collection. To match parenthesis characters, use \\ (or \\). It can be suffix quantity.\nx|y\tIt is not enclosed in (), and its scope is the entire regular expression. For example, z|food can match z or food. (?:z|f)ood matches zood or food.\n[xyz]\tCharacter class. Match any of the characters it contains. For example, [abc] can match a in plain. Special characters only have a backslash\\ to keep a special meaning and are used to escape characters. Other special characters such as asterisks, plus signs, and various parentheses are treated as normal characters. The caret ^, if it appears in the first place, indicates a collection of negative characters; If it appears in the middle of a string, it is only a normal character. Hyphen - if appears in the middle of the string, it indicates a character range description; If it appears at the beginning (or end), it is only as a normal character. The opening bracket should be escaped and can also appear as the first character.\n[^xyz]\tNegated character classes. Matches any character that is not listed. For example, [^abc] can match plin in plain.\n[a-z]\tCharacter range. Matches any character within the specified range. For example, [a-z] can match any lowercase letter character in the range A to Z.\n[^a-z]\tThe range of excluded characters. Matches any arbitrary character that is not within the specified range. For example, [^a-z] can match any character that is not in the range a to z.\n\\b\tMatch a word boundary, which is the position between the word and the space. For example, er\\b can match the er in never, but not the er in verb.\n\\B\tMatch non-word boundaries. er\\B can match the er in verb, but not the er in never.\n\\d\t  Match a numeric character. Equivalent to [0-9].\n\\D\t  Match a non-numeric character. Equivalent to [^0-9].\n\\f\t  Match a page break. Equivalent to \\x0c.\n\\n\t  Match a line break. Equivalent to \\x0a.\n\\r\t  Match a carriage return. Equivalent to \\x0d.\n\\s\tMatch any whitespace character, including spaces, tabs, page breaks, and more. Equivalent to [\\f\\n\\r\\t\\v].\n\\S\tMatches any non-whitespace characters. Equivalent to [^\\f\\n\\r\\t\\v].\n\\t\t  Match a tab. Equivalent to \\x09.\n\\v\t  Match\\n\\v\\f\\r\\x85.\n  \\in\tMatches any word character that includes underscores. Equivalent to [A-Za-z0-9_].\n  \\In\tMatch any non-word characters. Equivalent to [^A-Za-z0-9_].\n\\xnm\tHexadecimal escape character sequence. Match the characters represented by the two hexadecimal digits nm. For example, \\x41 matches A. ASCII codes can be used in regular expressions.\n  \\A\tBack-reference a substring that matches the num parenthetically enclosed capture group subexpression of the regular expression. where num is a decimal positive integer starting at 1, and the Regex capture group is capped at 63. For example: (.) \\1 matches two consecutive identical characters.\n  (?:p attern)\tMatching patterns but not getting matching substrings (shy groups), i.e. this is a non-getting match, and the matching substrings are not stored for backward reference. This is done in the use of the or character (|) It's useful to combine the parts of a pattern.\n(?=pattern)\tLook ahead positive assert, which matches the lookup string at the beginning of any string that matches the pattern. This is a non-acquisition match, that is, the match does not need to be acquired for later use. For example, Windows(?=95|98| NT|2000) can match Windows in Windows 2000, but not Windows in Windows 3.1. Prelookup does not consume characters, that is, after one match occurs, the search for the next match starts immediately after the last match, rather than after the character that contains the prelook.\n  (?! pattern)\tNegative assert, which matches the lookup string at the beginning of any string that does not match the pattern. This is a non-acquisition match, that is, the match does not need to be acquired for later use. e.g. Windows (?!) 95|98| NT|2000) can match Windows in Windows 3.1, but not Windows in Windows 2000. Prelookup does not consume characters, that is, after one match occurs, the search for the next match starts immediately after the last match, rather than after the character that contains the prelook.\n(?<=pattern)\tA look behind positive pre-check is similar to a positive positive pre-check, but in the opposite direction. For example, (?<=95|98| NT|2000) Windows can match Windows in 2000Windows, but not Windows in 3.1.\n(?<!pattern)\tA reverse negative pre-check is similar to a positive negative pre-check, but in the opposite direction. For example, (?<!95|98| NT|2000) Windows can match Windows in 3.1Windows, but not Windows in 2000.\n(?i)\tSpecify that some rules ignore case by specifying a rule. Currently, Regex only supports global case ignorance, and when this option is specified, it will be treated as a global case ignorance.\n(?-i)\tUse rules to specify that some rules are case-sensitive. Currently, Regex is case-sensitive by default, and this option is only compiled-compatible, not sensitive.\n+\t  A single plus sign, not an escaped \\+.\n*\t  A single asterisk, not an escaped \\*.\n-\t  A single minus, not an escaped \\-.\n]\t  A single closing bracket, not an escaped \\].\n}\t  A single closing curly brace, not an escaped \\}.\n[[:alpha:]]\t  Indicates arbitrary uppercase and lowercase letters.\n[[:^alpha:]]\t  Represents any character other than uppercase and lowercase letters.\n[[:lower:]]\t  Indicates any lowercase letter.\n[[:^lower:]]\t  Represents any character other than lowercase letters.\n[[:upper:]]\t  Indicates any capital letter.\n[[:^upper:]]\t  Represents any character other than capital letters.\n[[:digit:]]\t  Represents any single number between 0 and 9.\n[[:^digit:]]\t  Represents any character other than a single number between 0 and 9.\n[[:xdigit:]]\t  Letters and numbers that represent hexadecimal.\n[[:^xdigit:]]\t  Represents any character other than hexadecimal letters and numbers.\n[[:alnum:]]\t  Indicates any number or letter.\n[[:^alnum:]]\t  Represents any character other than numbers or letters.\n[[:space:]]\tRepresents any whitespace character, including \"space\", \"tab key\", etc.\n[[:^space:]]\t  Represents any character other than whitespace.\n[[:punct:]]\t  Indicates arbitrary punctuation.\n[[:^punct:]]\t  Represents any character other than any punctuation marks.\n  In Cangjie, there are some special rules:\n\nIf the characters in front of ?, +, and * are not quantifiable, they will be ignored; Special case: (*, |*, * are treated as normal characters when they start with *, |*, *.)\n\n*? In matching all *? If you form a string of previous characters, the characters will not be matched.\n\nThe maximum number of capture groups for regular expressions is 63, and the maximum length of the compiled rule is 65535.\n\nTemporarily unsupported scenarios: ((pattern1){m1,n1}pattern2){m2,n2}, that is:\nGroup definition 1 is modified by {m1,n1};\nGroup Definition 1 is wrapped by Group Definition 2;\nGroup definition 2 is modified by {m2,n2}.'"}
{"text": "'Cangjie programming language_api_std_std_runtime': 'When using Cangjie Code API, The runtime package provides functions and variables for interacting with the program's runtime environment, used for controlling, managing, and monitoring program execution.\nThe CangJie language uses an automatic garbage collection mechanism to manage memory, and the runtime package provides functions such as manually triggering garbage collection, setting garbage collection thresholds, and obtaining memory statistics to regulate and monitor garbage collection.\nThe name of the function\t  function\nGC(Bool)\t  Perform GC.\nSetGCThreshold(UInt64)\tModify the memory threshold that the user expects to trigger GC, and trigger GC in KB when the size of the Cangjie heap exceeds this value.'"}
{"text": "'Cangjie programming language_api_std_std_socket': 'When using Cangjie Code API, The socket package provides capabilities for network communication, including starting a Socket server, connecting to a Socket server, sending data, and receiving data.\nWe support three socket types: UDP/TCP/UDS, which users can choose according to their needs.\nUDP (User Datagram Protocol) is a connectionless transport protocol that does not provide reliability and flow control, but has low latency and low network overhead. UDP is mainly used in applications that require high real-time performance, such as live video streaming and online games.\n\nTCP (Transmission Control Protocol) is a connection-oriented and reliable transmission protocol. It provides reliable data transmission, flow control, congestion control, error detection, and traffic management, and is one of the most commonly used transport protocols on the Internet.\n\nUDS (Unix Domain Socket) is a mechanism for communication between processes on the same computer. Unlike network sockets, UDS does not require a network protocol stack and network equipment, so it can communicate faster, with lower latency and higher throughput.'"}
{"text": "'Cangjie programming language_api_std_std_sort': 'When using Cangjie Code API, The sort package provides sorting functions for array types.\nAccording to the sorting method, this package provides two sets of implementations: stable sorting and unstable sorting. Stable ordering means that the order of equal elements remains the same before and after the sorting. Conversely, unstable ordering means that there is no guarantee that the order of equal elements will be consistent before and after sorting.\nThis package provides a set of sorting functions with generics that can be used to sort an array of elements of type T. Sorting necessarily requires that the elements are comparable, so this set of functions is further divided into two categories: 1) T is required to implement the Comparable<T> interface, and 2) T is passed into the function as a parameter.\n\nList of APIs\nfunction：\nThe name of the function\t  function\nstableSort<T>(Array<T>) where T <: Comparable<T>\t  Sort arrays in a steady ascending order.\nstableSort<T>(Array<T>, (T, T) -> Ordering)\t  Sort arrays in a steady ascending order.\nunstableSort<T>(Array<T>) where T <: Comparable<T>\t  Perform an unstable ascending sort of array.\nunstableSort<T>(Array<T>, (T, T) -> Ordering)\t  Perform an unstable ascending sort of array.\ninterface：\nThe name of the interface\t  function\nSortByExtension\t  This interface acts as a sorting-related secondary interface and is empty internally.\nSortExtension\t  This interface acts as a sorting-related secondary interface and is empty internally.'\n\nCode_Example:\nimport std.sort.*\nimport std.random.*\nmain(): Unit {\n    let r: Random = Random()\n    let arr: Array<Int64> = Array<Int64>(70000, { _ => r.nextInt64() })\n    arr.sortBy(stable: true){ rht: Int64, lht: Int64 =>\n        if (rht < lht) {\n            return Ordering.LT\n        }\n        if (rht > lht) {\n            return Ordering.GT\n        }\n        return Ordering.EQ\n    }\n\n    println(isAsc(arr))\n}\n\nfunc isAsc(t: Array<Int64>) {\n    var item: Int64 = t[0]\n    for (i in 1..t.size) {\n        if (item > t[i]) {\n            return false\n        }\n        item = t[i]\n    }\n    return true\n}"}
{"text": "'Cangjie programming language_api_std_std_sync': 'When using Cangjie Code API, The sync package provides capabilities for concurrent programming.\nList of APIs\n  Constants & Variables\n  Constant & variable name\t  function\nDefaultMemoryOrder\tThe default memory order is listed in the enumeration MemoryOrder.\n  function\n  The name of the function\t  function\nsleep(Duration)\t  Hibernate the current thread.\n  interface\n  The name of the interface\t  function\nIReentrantMutex\t  A reentrant mutex interface is provided.'\n\nCode_Example:\nimport std.sync.sleep\nimport std.time.Duration\nmain () {\n    spawn {\n       // Execute in a new thread\n        println(\"Thread: ${Thread.currentThread.id}\")\n    }\n    // Execute in the main thread\n    println(\"Thread: ${Thread.currentThread.id}\")\n    sleep(Duration.second)\n\n    0\n}"}
{"text": "'Cangjie programming language_api_std_std_time': 'When using Cangjie Code API, The time package provides types related to time, including date and time, time intervals, monotonic time, and time zones, along with functions for calculation and comparison.\nTime string format:The string parsing time has the following requirements:\nThe string must contain information that describes the specific year, month, and day: such as A.D. (y) + month (M) and day (d), or A.D. (y) and the day of the year (D).\nIt defaults to 0 if it does not contain a description of hours, minutes and seconds, and to the current time zone TimeZone.Local if it does not contain time zone information.\nThe format of the same letter is not allowed to be taken twice, for example, it is not allowed to assign the value twice to the format of the first year (y); The two formats O and Z, which represent the time zone, are also not allowed to appear together.\nFor example, when \"2023-04-24-Mon\" is parsed with the format \"yyyy-MM-dd-www\", the correctness of \"Mon\" will be verified.'\n\nCode_Example:\nimport std.time.*\nmain() {\n    let datetime = DateTime.of(\n        year: 2024,\n        month: May,\n        dayOfMonth: 22,\n        hour: 12,\n        minute: 34,\n        second: 56,\n        nanosecond: 789000000,\n        timeZone: TimeZone.load(\"Asia/Shanghai\")\n    )\n\n    let yr = datetime.year\n    let mon = datetime.month\n    let day = datetime.dayOfMonth\n    let hr = datetime.hour\n    let min = datetime.minute\n    let sec = datetime.second\n    let ns = datetime.nanosecond\n    let zoneId = datetime.zoneId\n    let offset = datetime.zoneOffset\n    let dayOfWeek = datetime.dayOfWeek\n    let dayOfYear = datetime.dayOfYear\n    let (isoYear, isoWeek) = datetime.isoWeek\n\n    println(\"datetime is ${yr}, ${mon}, ${day}, ${hr}, ${min}, ${sec}, ${ns}, ${zoneId}, ${offset}\")\n    println(\"datetime.toString() = ${datetime}\")\n    println(\"${dayOfWeek}, ${dayOfYear}th day, ${isoWeek}th week of ${isoYear}\")\n}"}
{"text": "'Cangjie programming language_api_std_std_unicode': 'When using Cangjie Code API, The unicode package provides capabilities for handling characters according to the Unicode encoding standard.'"}
{"text": "'Cangjie programming language_api_std_std_unittest': 'When using Cangjie Code API, The unittest package is used for writing unit test code in Cangjie projects, providing basic functions for code writing, running, and debugging.'"}
{"text": "'Cangjie programming language_api_std_std_unittest_mock': 'When using Cangjie Code API, The unittest.mock package provides a mock framework for unit testing, offering APIs for creating and configuring mock objects that have the same API signatures as real objects.\nThe mock framework has the following features:\n\nCreate mock and spy objects: You don't need to modify your production code when testing.\nSimple configuration API: Configurable behavior of mock/spy objects.\nUnit Test Framework Part: Seamlessly integrates other features of the unit test framework, and the error output is readable.\nAutomatic validation of configuration behavior: In most cases, no redundant verification code is required.\nProvides a validation API for testing complex interactions inside the system.\n  User use cases include:\n\n  Simplify test setup and code.\n  Test anomalous scenarios.\nImprove test performance by replacing costly dependencies with lightweight mock objects.\n  Validate test complex scenarios such as the order/number of calls.'"}
{"text": "'Cangjie programming language_api_std_std_unittest_testmacro': 'When using Cangjie Code API, The unittest.testmacro package provides macros required by the unit testing framework.'"}
{"text": "'Cangjie programming language_api_std_std_unittest_mock_mockmacro': 'When using Cangjie Code API, The unittest.mock.mockmacro package provides macros required by the mock framework.'"}
{"text": "'Cangjie programming language_api_std_std_unittest_common': 'When using Cangjie Code API, The unittest.common package provides types and common methods required for printing in the unit testing framework.'"}
{"text": "'Cangjie programming language_api_std_std_unittest_diff': 'When using Cangjie Code API, The unittest.diff package provides APIs required for printing difference comparison information in the unit testing framework.'"}
{"text": "'Cangjie programming language_api_std_std_unittest_prop_test': 'When using Cangjie Code API, The unittest.prop_test package provides types and common methods required for parameterized testing in the unit testing framework.'"}
